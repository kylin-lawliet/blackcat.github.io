<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>问答 | BlackCat</title>
  <meta name="keywords" content=" Java ">
  <meta name="description" content="问答 | BlackCat">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="strong a {         color: #747474;     }     .player {         text-align: center;         margin: .5em auto 0;         width: 100%;         max-width: 22em;     }     .player br {         displa">
<meta property="og:type" content="website">
<meta property="og:title" content="关于我">
<meta property="og:url" content="https:&#x2F;&#x2F;kylin-blackcat.com&#x2F;about&#x2F;index.html">
<meta property="og:site_name" content="BlackCat">
<meta property="og:description" content="strong a {         color: #747474;     }     .player {         text-align: center;         margin: .5em auto 0;         width: 100%;         max-width: 22em;     }     .player br {         displa">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2019-12-22T03:08:52.000Z">
<meta property="article:modified_time" content="2020-01-26T02:07:51.239Z">
<meta property="article:author" content="blackcat">
<meta name="twitter:card" content="summary">


<link rel="icon" href="/img/avatar.jpg">

<link href="/css/style.css?v=1.0.1" rel="stylesheet">

<link href="/css/hl_theme/gruvbox-light.css?v=1.0.1" rel="stylesheet">

<link href="//cdn.bootcss.com/animate.css/3.5.2/animate.min.css" rel="stylesheet">
<link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="/js/jquery.autocomplete.min.js?v=1.0.1" ></script>

<script src="//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.js"></script>



<script src="//cdn.bootcss.com/jquery-cookie/1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.0.1" ></script>

<meta name="generator" content="Hexo 4.1.1"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="false">
  <input class="theme_blog_path" value="">
</div>

<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/" class="avatar_target">
    <img class="avatar" src="/img/avatar.jpg" />
</a>
<div class="author">
    <span>blackcat</span>
</div>

<div class="icon">
    
        
        <a title="github" href="https://github.com/kylin-lawliet" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-github"></use>
                </svg>
            
        </a>
        
    
        
        <a title="email" href="mailto:kylin_lawliet@163.com" target="_blank">
            
                <svg class="iconfont-svg" aria-hidden="true">
                    <use xlink:href="#icon-email"></use>
                </svg>
            
        </a>
        
    
</div>




<ul>
    <li><div class="all active">全部文章<small>(32)</small></div></li>
    
        
            
            <li><div data-rel="前端"><i class="fold iconfont icon-right"></i>前端<small>(5)</small></div>
                
                    <ul class="sub hide">
                        
                        <li><div data-rel="easyUI">easyUI<small>(1)</small></div>
                            
                        </li>
                            
                        <li><div data-rel="javascript">javascript<small>(2)</small></div>
                            
                        </li>
                            
                        <li><div data-rel="jquery">jquery<small>(1)</small></div>
                            
                        </li>
                            
                        <li><div data-rel="Bootstrap">Bootstrap<small>(1)</small></div>
                            
                        </li>
                            
                    </ul>
                
            </li>
            
        
    
        
            
            <li><div data-rel="hexo">hexo<small>(2)</small></div>
                
            </li>
            
        
    
        
            
            <li><div data-rel="工具"><i class="fold iconfont icon-right"></i>工具<small>(5)</small></div>
                
                    <ul class="sub hide">
                        
                        <li><div data-rel="Idea">Idea<small>(1)</small></div>
                            
                        </li>
                            
                        <li><div data-rel="postman">postman<small>(1)</small></div>
                            
                        </li>
                            
                        <li><div data-rel="docker">docker<small>(3)</small></div>
                            
                        </li>
                            
                    </ul>
                
            </li>
            
        
    
        
            
        
    
        
            
        
    
        
            
            <li><div data-rel="Linux"><i class="fold iconfont icon-right"></i>Linux<small>(2)</small></div>
                
                    <ul class="sub hide">
                        
                        <li><div data-rel="docker">docker<small>(1)</small></div>
                            
                        </li>
                            
                        <li><div data-rel="VMware">VMware<small>(1)</small></div>
                            
                        </li>
                            
                    </ul>
                
            </li>
            
        
    
        
            
            <li><div data-rel="数据库"><i class="fold iconfont icon-right"></i>数据库<small>(3)</small></div>
                
                    <ul class="sub hide">
                        
                        <li><div data-rel="MySQL">MySQL<small>(2)</small></div>
                            
                        </li>
                            
                    </ul>
                
            </li>
            
        
    
        
            
        
    
        
            
        
    
        
            
            <li><div data-rel="Java"><i class="fold iconfont icon-right"></i>Java<small>(11)</small></div>
                
                    <ul class="sub hide">
                        
                        <li><div data-rel="ssm">ssm<small>(1)</small></div>
                            
                        </li>
                            
                        <li><div data-rel="SpringBoot">SpringBoot<small>(3)</small></div>
                            
                        </li>
                            
                        <li><div data-rel="MyBatis">MyBatis<small>(1)</small></div>
                            
                        </li>
                            
                        <li><div data-rel="Maven">Maven<small>(1)</small></div>
                            
                        </li>
                            
                        <li><div data-rel="lombok">lombok<small>(1)</small></div>
                            
                        </li>
                            
                        <li><div data-rel="JVM">JVM<small>(1)</small></div>
                            
                        </li>
                            
                        <li><div data-rel="问答">问答<small>(1)</small></div>
                            
                        </li>
                            
                        <li><div data-rel="Shiro">Shiro<small>(1)</small></div>
                            
                        </li>
                            
                        <li><div data-rel="设计模式">设计模式<small>(1)</small></div>
                            
                        </li>
                            
                    </ul>
                
            </li>
            
        
    
        
            
        
    
        
            
        
    
        
            
            <li><div data-rel="网址">网址<small>(2)</small></div>
                
            </li>
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
            <li><div data-rel="SpringBoot">SpringBoot<small>(1)</small></div>
                
            </li>
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
    
    
    
    
    </div>
    <div><a class="about  hasFriend  site_url"  href="/about">关于</a><a style="width: 50%"  class="friends">友链</a></div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="32">
<input type="hidden" id="yelog_site_word_count" value="141.7k">
<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        友情链接
        <i class="back-title-list"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="https://yelog.org">叶落阁</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <form onkeydown="if(event.keyCode==13){return false;}">
        <input class="search" type="text" placeholder="以 in: 开头进行全文搜索" autocomplete="off"id="local-search-input" >
        <i class="cross"></i>
        <span>
            <label for="tagswitch">Tags:</label>
            <input id="tagswitch" type="checkbox" style="display: none" />
            <i id="tagsWitchIcon"></i>
        </span>
    </form>
    <div class="tags-list">
    
    <li class="article-tag-list-item">
        <a class="color1">javascript</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color5">hexo</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color5">Idea</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color2">easyUI</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color4">git，hexo</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color2">docker</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color1">MySQL</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color4">web</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color2">jquery</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color2">spring boot</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color2">spring</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color3">mybatis</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color3">postman</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color1">SpringBoot</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color5">Java</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color2">VMware</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color3">website</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color3">MyBatis</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color1">MySql</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color1">Maven</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color3">Mybatis</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color2">lombok</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color5">Bootstrap</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color5">Solr</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color4">JVM</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color4">SQL</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color3">生活</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color1">redis</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color1">Shiro</a>
    </li>
    
    <li class="article-tag-list-item">
        <a class="color5">设计模式</a>
    </li>
    
    <div class="clearfix"></div>
</div>

    
    <div id="local-search-result">

    </div>
    
    <nav id="title-list-nav">
        
        <a  class=""
           href="/2019/12/28/freemaker/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="freemaker学习笔记">freemaker学习笔记</span>
            <span class="post-date" title="2019-12-28 08:44:41">2019/12/28</span>
        </a>
        
        <a  class="前端 javascript "
           href="/2019/12/24/javascript/"
           data-tag="javascript"
           data-author="" >
            <span class="post-title" title="javascript使用示例">javascript使用示例</span>
            <span class="post-date" title="2019-12-24 08:52:35">2019/12/24</span>
        </a>
        
        <a id="top" class="hexo "
           href="/2019/12/23/hexo-dome/"
           data-tag="hexo"
           data-author="" >
            <span class="post-title" title="hexo文章格式示例">hexo文章格式示例</span>
            <span class="post-date" title="2019-12-23 10:24:34">2019/12/23</span>
        </a>
        
        <a  class="工具 Idea "
           href="/2019/12/25/idea/"
           data-tag="Idea"
           data-author="" >
            <span class="post-title" title="Idea笔记">Idea笔记</span>
            <span class="post-date" title="2019-12-25 08:51:24">2019/12/25</span>
        </a>
        
        <a  class="前端 easyUI "
           href="/2019/12/24/easyui/"
           data-tag="easyUI"
           data-author="" >
            <span class="post-title" title="easyui记录使用过程中出现的问题">easyui记录使用过程中出现的问题</span>
            <span class="post-date" title="2019-12-24 16:56:43">2019/12/24</span>
        </a>
        
        <a  class="hexo "
           href="/2019/12/22/hexo/"
           data-tag="git，hexo"
           data-author="" >
            <span class="post-title" title="hexo建站相关">hexo建站相关</span>
            <span class="post-date" title="2019-12-22 14:18:18">2019/12/22</span>
        </a>
        
        <a  class="Linux docker "
           href="/2020/01/03/docker/"
           data-tag="docker"
           data-author="" >
            <span class="post-title" title="Linux安装docker使用及一些问题记录">Linux安装docker使用及一些问题记录</span>
            <span class="post-date" title="2020-01-03 17:17:35">2020/01/03</span>
        </a>
        
        <a  class="数据库 MySQL "
           href="/2020/01/03/mysql-quiz/"
           data-tag="MySQL"
           data-author="" >
            <span class="post-title" title="mysql问答">mysql问答</span>
            <span class="post-date" title="2020-01-03 08:04:03">2020/01/03</span>
        </a>
        
        <a  class="前端 jquery "
           href="/2019/12/24/jquery/"
           data-tag="web,jquery"
           data-author="" >
            <span class="post-title" title="jquery各种函数使用示例">jquery各种函数使用示例</span>
            <span class="post-date" title="2019-12-24 16:54:54">2019/12/24</span>
        </a>
        
        <a id="top" class="Java ssm "
           href="/2020/01/01/ssm/"
           data-tag="spring boot,spring,mybatis"
           data-author="" >
            <span class="post-title" title="ssm项目搭建及后续开发记录">ssm项目搭建及后续开发记录</span>
            <span class="post-date" title="2020-01-01 12:01:23">2020/01/01</span>
        </a>
        
        <a  class="工具 postman "
           href="/2020/01/13/postman/"
           data-tag="postman"
           data-author="" >
            <span class="post-title" title="postman相关">postman相关</span>
            <span class="post-date" title="2020-01-13 18:10:17">2020/01/13</span>
        </a>
        
        <a  class="Java SpringBoot "
           href="/2020/01/07/SpringBoot-Create/"
           data-tag="SpringBoot,Java"
           data-author="" >
            <span class="post-title" title="创建SpringBoot项目">创建SpringBoot项目</span>
            <span class="post-date" title="2020-01-07 14:50:44">2020/01/07</span>
        </a>
        
        <a  class="工具 docker "
           href="/2020/01/07/docker-command/"
           data-tag="docker"
           data-author="" >
            <span class="post-title" title="docker命令">docker命令</span>
            <span class="post-date" title="2020-01-07 15:50:15">2020/01/07</span>
        </a>
        
        <a  class="Linux VMware "
           href="/2020/01/03/VMware-CentOS/"
           data-tag="VMware"
           data-author="" >
            <span class="post-title" title="win10下VMware安装Centos">win10下VMware安装Centos</span>
            <span class="post-date" title="2020-01-03 10:13:22">2020/01/03</span>
        </a>
        
        <a id="top" class="网址 "
           href="/2020/01/06/website-official/"
           data-tag="website"
           data-author="" >
            <span class="post-title" title="网站收藏（工作）">网站收藏（工作）</span>
            <span class="post-date" title="2020-01-06 17:25:41">2020/01/06</span>
        </a>
        
        <a  class="Java MyBatis "
           href="/2020/01/07/mybatis-plus-generator/"
           data-tag="MyBatis,MySql"
           data-author="" >
            <span class="post-title" title="mybatis plus mysql 代码生成器">mybatis plus mysql 代码生成器</span>
            <span class="post-date" title="2020-01-07 14:45:10">2020/01/07</span>
        </a>
        
        <a  class="Java Maven "
           href="/2020/01/16/maven-common/"
           data-tag="Maven"
           data-author="" >
            <span class="post-title" title="Maven pom.xml常用">Maven pom.xml常用</span>
            <span class="post-date" title="2020-01-16 14:49:45">2020/01/16</span>
        </a>
        
        <a  class="Java SpringBoot "
           href="/2020/01/18/springboot-mybatis-plus/"
           data-tag="Mybatis"
           data-author="" >
            <span class="post-title" title="springboot 2.2 集成mybatis-plus">springboot 2.2 集成mybatis-plus</span>
            <span class="post-date" title="2020-01-18 13:14:46">2020/01/18</span>
        </a>
        
        <a  class="工具 docker "
           href="/2020/01/13/docker-mysql/"
           data-tag="docker,MySql"
           data-author="" >
            <span class="post-title" title="docker安装MySql及相关命令">docker安装MySql及相关命令</span>
            <span class="post-date" title="2020-01-13 13:31:12">2020/01/13</span>
        </a>
        
        <a  class="Java lombok "
           href="/2020/01/18/lombok-annotation/"
           data-tag="lombok"
           data-author="" >
            <span class="post-title" title="lombok常用注解">lombok常用注解</span>
            <span class="post-date" title="2020-01-18 13:39:18">2020/01/18</span>
        </a>
        
        <a  class="前端 Bootstrap "
           href="/2020/01/19/bootstrap/"
           data-tag="Bootstrap"
           data-author="" >
            <span class="post-title" title="Bootstrap相关整理">Bootstrap相关整理</span>
            <span class="post-date" title="2020-01-19 14:15:31">2020/01/19</span>
        </a>
        
        <a  class="数据库 MySQL "
           href="/2020/01/19/mysql-konwledge/"
           data-tag="MySQL"
           data-author="" >
            <span class="post-title" title="MySQL相关命令及SQL语句整理">MySQL相关命令及SQL语句整理</span>
            <span class="post-date" title="2020-01-19 10:43:33">2020/01/19</span>
        </a>
        
        <a  class="前端 javascript "
           href="/2020/03/05/javascript-menutree/"
           data-tag="javascript"
           data-author="" >
            <span class="post-title" title="实现无限极目录树/下拉框（递归）">实现无限极目录树/下拉框（递归）</span>
            <span class="post-date" title="2020-03-05 14:14:55">2020/03/05</span>
        </a>
        
        <a  class="SpringBoot "
           href="/2020/02/16/springboot-solr/"
           data-tag="SpringBoot,Solr"
           data-author="" >
            <span class="post-title" title="springboot 集成 solr">springboot 集成 solr</span>
            <span class="post-date" title="2020-02-16 14:49:32">2020/02/16</span>
        </a>
        
        <a  class="Java JVM "
           href="/2020/01/24/jvm-tuning/"
           data-tag="JVM"
           data-author="" >
            <span class="post-title" title="JVM回收与调优">JVM回收与调优</span>
            <span class="post-date" title="2020-01-24 13:39:18">2020/01/24</span>
        </a>
        
        <a  class="Java SpringBoot "
           href="/2020/01/16/springboot-error/"
           data-tag="SpringBoot"
           data-author="" >
            <span class="post-title" title="SpringBoot问题记录">SpringBoot问题记录</span>
            <span class="post-date" title="2020-01-16 12:49:46">2020/01/16</span>
        </a>
        
        <a  class="数据库 "
           href="/2020/03/05/sql_join/"
           data-tag="SQL"
           data-author="" >
            <span class="post-title" title="SQL中left join,right join,inner join之间的区别">SQL中left join,right join,inner join之间的区别</span>
            <span class="post-date" title="2020-03-05 16:35:10">2020/03/05</span>
        </a>
        
        <a  class="网址 "
           href="/2020/02/17/website-life/"
           data-tag="生活"
           data-author="" >
            <span class="post-title" title="收藏网站（生活）">收藏网站（生活）</span>
            <span class="post-date" title="2020-02-17 13:06:26">2020/02/17</span>
        </a>
        
        <a  class="Java 问答 "
           href="/2020/01/03/interview/"
           data-tag="Java"
           data-author="" >
            <span class="post-title" title="问答">问答</span>
            <span class="post-date" title="2020-01-03 08:00:18">2020/01/03</span>
        </a>
        
        <a  class="工具 docker "
           href="/2020/04/09/docker-redis/"
           data-tag="redis"
           data-author="" >
            <span class="post-title" title="docker安装redis 及相关">docker安装redis 及相关</span>
            <span class="post-date" title="2020-04-09 16:40:37">2020/04/09</span>
        </a>
        
        <a  class="Java Shiro "
           href="/2020/02/01/springboot-shiro/"
           data-tag="Shiro"
           data-author="" >
            <span class="post-title" title="Springboot 集成 Shiro">Springboot 集成 Shiro</span>
            <span class="post-date" title="2020-02-01 12:16:53">2020/02/01</span>
        </a>
        
        <a  class="Java 设计模式 "
           href="/2020/03/27/design_pattern/"
           data-tag="设计模式"
           data-author="" >
            <span class="post-title" title="设计模式">设计模式</span>
            <span class="post-date" title="2020-03-27 16:40:06">2020/03/27</span>
        </a>
        
    </nav>
</div>
    </div>
    <div class="hide-list">
        <div class="semicircle">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div class="post">
    <div class="pjax">
        <article id="post-interview" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">问答</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            
                <a  data-rel="Java">Java</a>/
            
                <a  data-rel="问答">问答</a>
            
        </span>
        
        
        <span class="tag">
            
            <a class="color5">Java</a>
            
        </span>
        
    </div>
    <div class="article-meta">
        
        创建时间:<time class="date" title='更新时间: 2020-04-07 19:20:14'>2020-01-03 08:00</time>
        
    </div>
    <div class="article-meta">
        
        <span>字数:28.3k</span>
        
        
        <span id="busuanzi_container_page_pv">
            阅读:<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
        <span class="top-comment" title="跳转至评论区">
            <a href="#comments">
                评论:<span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </a>
        </span>
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#java基础"><span class="toc-text">java基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基本数据类型"><span class="toc-text">基本数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-的引用类型有哪几种"><span class="toc-text">Java 的引用类型有哪几种</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String-类的常用方法"><span class="toc-text">String 类的常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#string、stringbuilder、stringbuffer区别"><span class="toc-text">string、stringbuilder、stringbuffer区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么-Java-中的-String-是不可变的"><span class="toc-text">为什么 Java 中的 String 是不可变的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-中的构造器链是什么"><span class="toc-text">Java 中的构造器链是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#抽象类和接口的区别"><span class="toc-text">抽象类和接口的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hashCode-与-equals"><span class="toc-text">hashCode() 与 equals()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#是不是每个对象都要重写这两个方法，到底什么时候重写？"><span class="toc-text">是不是每个对象都要重写这两个方法，到底什么时候重写？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么需要hashCode"><span class="toc-text">为什么需要hashCode</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#a-hashCode-有什么用？与-a-equals-b-有什么关系"><span class="toc-text">a.hashCode() 有什么用？与 a.equals(b) 有什么关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#“a-b”和”a-equals-b-”有什么区别"><span class="toc-text">“a&#x3D;&#x3D;b”和”a.equals(b)”有什么区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-中的编译期常量是什么？使用它又什么风险？"><span class="toc-text">Java 中的编译期常量是什么？使用它又什么风险？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#描述Java中的重载与重写？什么时候用重载，什么时候用重写？"><span class="toc-text">描述Java中的重载与重写？什么时候用重载，什么时候用重写？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BeanFactory和ApplicationContext的区别"><span class="toc-text">BeanFactory和ApplicationContext的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java7、Java8的新特性"><span class="toc-text">Java7、Java8的新特性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JAVA-集合"><span class="toc-text">JAVA 集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#List"><span class="toc-text">List</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayList（数组）"><span class="toc-text">ArrayList（数组）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Vector（数组实现、线程同步）"><span class="toc-text">Vector（数组实现、线程同步）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LinkList（链表）"><span class="toc-text">LinkList（链表）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Set"><span class="toc-text">Set</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HashSet（Hash-表）"><span class="toc-text">HashSet（Hash 表）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TreeSet（二叉树）"><span class="toc-text">TreeSet（二叉树）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LinkHashSet（HashSet-LinkedHashMap）"><span class="toc-text">LinkHashSet（HashSet+LinkedHashMap）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Map"><span class="toc-text">Map</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap（数组-链表-红黑树）"><span class="toc-text">HashMap（数组+链表+红黑树）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashTable（线程安全）"><span class="toc-text">HashTable（线程安全）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TreeMap-（可排序）"><span class="toc-text">TreeMap**（可排序）**</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LinkHashMap（记录插入顺序）"><span class="toc-text">LinkHashMap（记录插入顺序）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayList和LinkedList各自实现和区别"><span class="toc-text">ArrayList和LinkedList各自实现和区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#怎么给List排序？"><span class="toc-text">怎么给List排序？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#都知道哪些常用的Map集合"><span class="toc-text">都知道哪些常用的Map集合?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#hashtable和hashmap的区别"><span class="toc-text">hashtable和hashmap的区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java异常"><span class="toc-text">Java异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java检查异常、非检查异常、运行时异常、非运行时异常的区别"><span class="toc-text">Java检查异常、非检查异常、运行时异常、非运行时异常的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#框架"><span class="toc-text">框架</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#jsp和servlet的区别"><span class="toc-text">jsp和servlet的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#hibernate跟Mybatis-ibatis-的区别"><span class="toc-text">hibernate跟Mybatis&#x2F; ibatis 的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Hibernate的原理体系架构，五大核心接口，Hibernate对象的三种状态转换，事务管理。"><span class="toc-text">Hibernate的原理体系架构，五大核心接口，Hibernate对象的三种状态转换，事务管理。</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MyBatis"><span class="toc-text">MyBatis</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#MyBatis框架的缺点？"><span class="toc-text">MyBatis框架的缺点？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MyBatis框架适用场合？"><span class="toc-text">MyBatis框架适用场合？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Mybatis动态sql有什么用？执行原理？有哪些动态sql？"><span class="toc-text">Mybatis动态sql有什么用？执行原理？有哪些动态sql？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Xml映射文件中，除了常见的select-insert-updae-delete标签之外，还有哪些标签？"><span class="toc-text">Xml映射文件中，除了常见的select|insert|updae|delete标签之外，还有哪些标签？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？"><span class="toc-text">为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MyBatis实现一对一有几种方式-具体怎么操作的？"><span class="toc-text">MyBatis实现一对一有几种方式?具体怎么操作的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MyBatis实现一对多有几种方式-怎么操作的？"><span class="toc-text">MyBatis实现一对多有几种方式,怎么操作的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Mybatis的一级、二级缓存"><span class="toc-text">Mybatis的一级、二级缓存</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring"><span class="toc-text">Spring</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#使用Spring框架的好处是什么？"><span class="toc-text">使用Spring框架的好处是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#springMVC流程说明"><span class="toc-text">springMVC流程说明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#什么是Spring-MVC框架的控制器？"><span class="toc-text">什么是Spring MVC框架的控制器？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#spring注入的几种方式（循环注入）"><span class="toc-text">spring注入的几种方式（循环注入）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring框架的事务管理有哪些优点？"><span class="toc-text">Spring框架的事务管理有哪些优点？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#spring如何实现事物管理的"><span class="toc-text">spring如何实现事物管理的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#为什么说Spring是一个容器？"><span class="toc-text">为什么说Spring是一个容器？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#springIOC-控制反转"><span class="toc-text">springIOC 控制反转</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IOC的优点是什么？"><span class="toc-text">IOC的优点是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#spring-AOP的原理"><span class="toc-text">spring AOP的原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AOP-核心概念"><span class="toc-text">AOP 核心概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#在SpringAOP中，关注点和横切关注的区别是什么？"><span class="toc-text">在SpringAOP中，关注点和横切关注的区别是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#你怎样定义类的作用域"><span class="toc-text">你怎样定义类的作用域?</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM"><span class="toc-text">JVM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是-JVM-？"><span class="toc-text">什么是 JVM ？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM-由哪些部分组成？"><span class="toc-text">JVM 由哪些部分组成？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类加载器是有了解吗？"><span class="toc-text">类加载器是有了解吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-虚拟机是如何判定两个-Java-类是相同的？"><span class="toc-text">Java 虚拟机是如何判定两个 Java 类是相同的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-是如何实现跨平台的？"><span class="toc-text">Java 是如何实现跨平台的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#说说Java虚拟机的生命周期及体系结构。"><span class="toc-text">说说Java虚拟机的生命周期及体系结构。</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#多线程"><span class="toc-text">多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized-关键字？"><span class="toc-text">synchronized 关键字？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#volatile-关键字？"><span class="toc-text">volatile 关键字？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#volatile-能使得一个非原子操作变成原子操作吗？"><span class="toc-text">volatile 能使得一个非原子操作变成原子操作吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如果拿到synchronized的线程异常退出了，那么等待锁的线程是否会一直等待呢？"><span class="toc-text">如果拿到synchronized的线程异常退出了，那么等待锁的线程是否会一直等待呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#了解可重入锁的含义，以及ReentrantLock-和synchronized的区别"><span class="toc-text">了解可重入锁的含义，以及ReentrantLock 和synchronized的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#atomicinteger和Volatile等线程安全操作的关键字的理解和使用"><span class="toc-text">atomicinteger和Volatile等线程安全操作的关键字的理解和使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java创建线程之后，直接调用start-方法和run-的区别"><span class="toc-text">Java创建线程之后，直接调用start()方法和run()的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sleep-和-wait-n-、wait-的区别？"><span class="toc-text">sleep( ) 和 wait( n)、wait( ) 的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#我们为什么要使用线程池？核心线程池内部实现了解吗？"><span class="toc-text">我们为什么要使用线程池？核心线程池内部实现了解吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#核心线程池内部实现了解吗？"><span class="toc-text">核心线程池内部实现了解吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#常用的线程池模式以及不同线程池的使用场景"><span class="toc-text">常用的线程池模式以及不同线程池的使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多线程之间通信的同步问题"><span class="toc-text">多线程之间通信的同步问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#定时线程的使用"><span class="toc-text">定时线程的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#进程和线程的区别"><span class="toc-text">进程和线程的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么叫线程安全"><span class="toc-text">什么叫线程安全</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程的几种状态"><span class="toc-text">线程的几种状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap-是否线程安全"><span class="toc-text">HashMap 是否线程安全</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-IO"><span class="toc-text">Java IO</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#操作的数据是否是纯文本数据？"><span class="toc-text">操作的数据是否是纯文本数据？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-IO体系中有太多的对象，到底用哪个呢？"><span class="toc-text">Java IO体系中有太多的对象，到底用哪个呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java中有几种类型的流？"><span class="toc-text">java中有几种类型的流？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字符流和字节流有什么区别？"><span class="toc-text">字符流和字节流有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IO里面的常见类，字节流、字符流、接口、实现类、方法阻塞"><span class="toc-text">IO里面的常见类，字节流、字符流、接口、实现类、方法阻塞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String-编码UTF-8-和GBK的区别"><span class="toc-text">String 编码UTF-8 和GBK的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#session和cookie的区别和联系"><span class="toc-text">session和cookie的区别和联系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#设计模式"><span class="toc-text">设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是里氏替换原则？"><span class="toc-text">什么是里氏替换原则？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#适配器模式是什么？什么时候使用？"><span class="toc-text">适配器模式是什么？什么时候使用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么时候使用访问者模式？"><span class="toc-text">什么时候使用访问者模式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#适配器模式与装饰器模式有什么区别？"><span class="toc-text">适配器模式与装饰器模式有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#继承和组合之间有什么不同？"><span class="toc-text">继承和组合之间有什么不同？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#讲一下模版模式和策略模式的区别？"><span class="toc-text">讲一下模版模式和策略模式的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#工厂模式与抽象工厂模式的区别？"><span class="toc-text">工厂模式与抽象工厂模式的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么时候使用享元模式？"><span class="toc-text">什么时候使用享元模式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#你可以说出几个在JDK库中使用的设计模式吗？"><span class="toc-text">你可以说出几个在JDK库中使用的设计模式吗？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis"><span class="toc-text">Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#使用redis优缺点？"><span class="toc-text">使用redis优缺点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis支持的数据类型？"><span class="toc-text">Redis支持的数据类型？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是Redis持久化？Redis有哪几种持久化方式？优缺点是什么？"><span class="toc-text">什么是Redis持久化？Redis有哪几种持久化方式？优缺点是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis的内存淘汰策略有哪些？"><span class="toc-text">Redis的内存淘汰策略有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-有哪些架构模式？"><span class="toc-text">Redis 有哪些架构模式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是缓存穿透？如何避免？什么是缓存雪崩？何如避免？"><span class="toc-text">什么是缓存穿透？如何避免？什么是缓存雪崩？何如避免？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#事务管理（ACID）概述"><span class="toc-text">事务管理（ACID）概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis事务支持隔离性吗"><span class="toc-text">Redis事务支持隔离性吗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis事务保证原子性吗，支持回滚吗"><span class="toc-text">Redis事务保证原子性吗，支持回滚吗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis事务其他实现"><span class="toc-text">Redis事务其他实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Tomcat"><span class="toc-text">Tomcat</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Tomcat有几种部署方式？"><span class="toc-text">Tomcat有几种部署方式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#请解释servlet如何完成生命周期"><span class="toc-text">请解释servlet如何完成生命周期?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tomcat有哪几种Connector运行模式？"><span class="toc-text">tomcat有哪几种Connector运行模式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#你平时怎么给tomcat调优"><span class="toc-text">你平时怎么给tomcat调优?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#网络通信"><span class="toc-text">网络通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#http是无状态通信，http的请求方式有哪些，可以自己定义新的请求方式么"><span class="toc-text">http是无状态通信，http的请求方式有哪些，可以自己定义新的请求方式么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#socket通信模型的使用，AIO和NIO"><span class="toc-text">socket通信模型的使用，AIO和NIO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NIO的实现原理，为什么是异步非阻塞"><span class="toc-text">NIO的实现原理，为什么是异步非阻塞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#同步和异步，阻塞和非阻塞"><span class="toc-text">同步和异步，阻塞和非阻塞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#http中，get-post的区别"><span class="toc-text">http中，get post的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#http-tcp-udp之间关系和区别"><span class="toc-text">http,tcp,udp之间关系和区别</span></a></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-4 i,
    .toc-level-4 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <a id="more"></a>


<h2 id="java基础"><a href="#java基础" class="headerlink" title="java基础"></a>java基础</h2><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>内置数据类型<br>Java语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。<br><code>byte</code>  <code>short</code>  <code>int</code>  <code>long</code>  <code>float</code>  <code>double</code>  <code>boolean</code>  <code>char</code></p>
<p><strong>自动类型转换</strong></p>
<p>整型、实型（常量）、字符型数据可以混合运算。运算中，不同类型的数据先转化为同一类型，然后进行运算。<br>数据类型转换必须满足如下规则：</p>
<ul>
<li><p>不能对boolean类型进行类型转换。</p>
</li>
<li><p>不能把对象类型转换成不相关类的对象。</p>
</li>
<li><p>在把容量大的类型转换为容量小的类型时必须使用强制类型转换。</p>
</li>
<li><p>转换过程中可能导致溢出或损失精度</p>
</li>
<li><p>浮点数到整数的转换是通过舍弃小数得到，而不是四舍五入</p>
</li>
</ul>
<p><strong>强制类型转换</strong></p>
<ul>
<li><p>条件是转换的数据类型必须是兼容的。</p>
</li>
<li><p>格式：<code>(type)value</code> <code>type</code>是要强制类型转换后的数据类型</p>
</li>
</ul>
<p><strong>隐含强制类型转换</strong></p>
<ul>
<li><p>整数的默认类型是 <code>int</code>。</p>
</li>
<li><p>浮点型不存在这种情况，因为在定义<code>float</code> 类型时必须在数字后面跟上<code>F</code>或者<code>f</code>。</p>
</li>
</ul>
<h3 id="Java-的引用类型有哪几种"><a href="#Java-的引用类型有哪几种" class="headerlink" title="Java 的引用类型有哪几种"></a>Java 的引用类型有哪几种</h3><p>对象、数组都是引用数据类型。<br>所有引用类型的默认值都是<code>null</code>。<br>常量在程序运行时是 <strong><em>不能被修改</em></strong>  的。<br>在 <code>Java</code> 中使用 <code>final</code> 关键字来修饰常量，声明方式和变量类似。</p>
<h3 id="String-类的常用方法"><a href="#String-类的常用方法" class="headerlink" title="String 类的常用方法"></a>String 类的常用方法</h3><p><code>new String(value)</code>用字符数组value创建一个String对象<br><code>new String(value, 1, 2)</code> 用字符数组以x开始的n个字符创建一个String对象<br><code>str.length()</code> 获取字符串长度<br><code>str.charAt(4)</code> 获取字符串某一位置的字符<br><code>str1.substring(2,5)</code> 获取字符串的子串<br><code>str1.compareTo(str2)</code> <code>str1.equals(str2)</code> 字符串的比较<br><code>indexOf(String str)</code> 查找子串在字符串中的位置<br><code>str.toLowerCase()</code> <code>str.toUpperCase()</code>字符串中字符的大小写转换<br><code>str.trim()</code> 字符串两端去空格<br><code>str.split(&quot;#&quot;)</code> 将字符串分割成字符串数组<br><code>String.valueOf(12.99)</code> 基本类型转换为字符串<br><code>str.replace(&#39;h&#39;,&#39;g&#39;)</code> 替换字符串</p>
<h3 id="string、stringbuilder、stringbuffer区别"><a href="#string、stringbuilder、stringbuffer区别" class="headerlink" title="string、stringbuilder、stringbuffer区别"></a>string、stringbuilder、stringbuffer区别</h3><p><code>String</code>是只读字符串，所引用的字符串不能被改变，<code>Stringbuffer</code>和<code>Stringbuilder</code>定义的可以通过各种方法来达到简单的增删改；</p>
<p>每次+操作 ： 隐式在堆上<code>new</code>了一个跟原字符串相同的<code>StringBuilder</code>对象，再调用<code>append</code>方法 拼接+后面的字符。</p>
<p><code>String</code>和<code>Stringbuilder</code>在单线程环境下使用；<br><code>StringBuffer</code>在多线程环境下使用，可以保证线程同步；<br><code>Stringbuilder</code> 和<code>StringBuffer</code> 实现方法类似，均表示可变字符序列，不过<code>StringBuffer</code> 用<code>synchronized</code>关键字修饰（保证线程同步）</p>
<p>当需要对某一字符串大量重复+操作时：<br><code>Stringbuilder</code> 最快，不需要考虑线程同步；<code>StringBuffer</code>次之；<br><code>String</code>最慢，因为每次都要重新开辟内存，产生很多匿名对象，影响系统性能。</p>
<p>Java6和6之前，常量池是存放在方法区中的。<br>Java7，将常量池是存放到了堆中，常量池就相当于是在永久代中，所以永久代存放在堆中。<br>Java8之后，取消了整个永久代区域，取而代之的是元空间。没有再对常量池进行调整。</p>
<h3 id="为什么-Java-中的-String-是不可变的"><a href="#为什么-Java-中的-String-是不可变的" class="headerlink" title="为什么 Java 中的 String 是不可变的"></a>为什么 Java 中的 String 是不可变的</h3><p>Java 中的 String 不可变是因为 Java 的设计者认为字符串使用非常频繁，将字符串设置为不可变可以允许多个客户端之间共享相同的字符串</p>
<h3 id="Java-中的构造器链是什么"><a href="#Java-中的构造器链是什么" class="headerlink" title="Java 中的构造器链是什么"></a>Java 中的构造器链是什么</h3><p>当你从一个构造器中调用另一个构造器，就是Java 中的构造器链。这种情况只在重载了类的构造器的时候才会出现。</p>
<h3 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别"></a>抽象类和接口的区别</h3><p><strong>抽象类：</strong></p>
<ul>
<li>抽象类使用<code>abstract</code>修饰；</li>
<li>抽象类不能实例化，即不能使用new关键字来实例化对象；</li>
<li>含有抽象方法（使用<code>abstract</code>关键字修饰的方法）的类是抽象类，必须使用<code>abstract</code>关键字修饰；</li>
<li>抽象类可以含有抽象方法，也可以不包含抽象方法，抽象类中可以有具体的方法；</li>
<li>如果一个子类实现了父类（抽象类）的所有抽象方法，那么该子类可以不必是抽象类，否则就是抽象类；</li>
<li>抽象类中的抽象方法只有方法体，没有具体实现；</li>
</ul>
<p><strong>接口：</strong></p>
<ul>
<li>接口使用<code>interface</code>修饰；</li>
<li>接口不能被实例化；</li>
<li>一个类只能继承一个类，但是可以实现多个接口；</li>
<li>接口中方法均为抽象方法；</li>
<li>接口中不能包含实例域或静态方法（静态方法必须实现，接口中方法是抽象方法，不能实现）</li>
</ul>
<h3 id="hashCode-与-equals"><a href="#hashCode-与-equals" class="headerlink" title="hashCode() 与 equals()"></a>hashCode() 与 equals()</h3><p>对象在不重写的情况下使用的是Object的equals方法和hashcode方法，从Object类的源码我们知道，默认的equals 判断的是两个对象的引用指向的是不是同一个对象；而hashcode也是根据对象地址生成一个整数数值；</p>
<p><strong>equals()</strong></p>
<ul>
<li><p>判断是否等于自身.</p>
</li>
<li><p>使用<code>instanceof</code>运算符判断 other 是否为Coder类型的对象.</p>
</li>
</ul>
<ul>
<li>比较Coder类中你自定义的数据域，name和age，一个都不能少.</li>
</ul>
<p><strong>hashcode</strong></p>
<ul>
<li><p>两个对象相等，hashcode一定相等</p>
</li>
<li><p>两个对象不等，hashcode不一定不等</p>
</li>
<li><p>hashcode相等，两个对象不一定相等</p>
</li>
<li><p>hashcode不等，两个对象一定不等</p>
</li>
</ul>
<p>在重写equals()后，一定要重写hashCode()方法</p>
<p>相关文章：</p>
<p><a href="https://blog.csdn.net/u012557538/article/details/89861552" target="_blank" rel="noopener">重写hashcode和equals方法</a></p>
<p><a href="https://blog.csdn.net/xl_1803/article/details/80445481" target="_blank" rel="noopener">为什么重写equals一定要重写hashcode？</a></p>
<p><a href="https://blog.csdn.net/neosmith/article/details/17068365" target="_blank" rel="noopener">如何重写hashCode()和equals()方法</a></p>
<h3 id="是不是每个对象都要重写这两个方法，到底什么时候重写？"><a href="#是不是每个对象都要重写这两个方法，到底什么时候重写？" class="headerlink" title="是不是每个对象都要重写这两个方法，到底什么时候重写？"></a>是不是每个对象都要重写这两个方法，到底什么时候重写？</h3><p>事实上一般情况下，我们并不需要重写这两个方法，只有该类被应用到集合框架中去的时候，才应该重写。</p>
<h3 id="为什么需要hashCode"><a href="#为什么需要hashCode" class="headerlink" title="为什么需要hashCode"></a>为什么需要hashCode</h3><p>通过hashCode可以提高对比的性能</p>
<h3 id="a-hashCode-有什么用？与-a-equals-b-有什么关系"><a href="#a-hashCode-有什么用？与-a-equals-b-有什么关系" class="headerlink" title="a.hashCode() 有什么用？与 a.equals(b) 有什么关系"></a>a.hashCode() 有什么用？与 a.equals(b) 有什么关系</h3><p>hashCode() 方法是相应对象整型的 hash 值。它常用于基于 hash 的集合类，如 Hashtable、HashMap、LinkedHashMap等等。它与 equals() 方法关系特别紧密。根据 Java 规范，两个使用 equal() 方法来判断相等的对象，必须具有相同的 hash code。</p>
<h3 id="“a-b”和”a-equals-b-”有什么区别"><a href="#“a-b”和”a-equals-b-”有什么区别" class="headerlink" title="“a==b”和”a.equals(b)”有什么区别"></a>“a==b”和”a.equals(b)”有什么区别</h3><p>如果 a 和 b 都是对象，则 a==b 是比较两个对象的引用，只有当 a 和 b 指向的是堆中的同一个对象才会返回 true，而 a.equals(b) 是进行逻辑比较，所以通常需要重写该方法来提供逻辑一致性的比较。例如，String 类重写 equals() 方法，所以可以用于两个不同对象，但是包含的字母相同的比较。</p>
<h3 id="Java-中的编译期常量是什么？使用它又什么风险？"><a href="#Java-中的编译期常量是什么？使用它又什么风险？" class="headerlink" title="Java 中的编译期常量是什么？使用它又什么风险？"></a>Java 中的编译期常量是什么？使用它又什么风险？</h3><p>公共静态不可变（<code>public</code> <code>static</code> <code>final</code>）变量也就是我们所说的编译期常量，这里的public可选的。<br>实际上这些变量在编译时会被替换掉，因为编译器知道这些变量的值，并且知道这些变量在运行时不能改变。<br>这种方式存在的一个问题是你使用了一个内部的或第三方库中的公有编译时常量，但是这个值后面被其他人改变了，但是你的客户端仍然在使用老的值，甚至你已经部署了一个新的jar。为了避免这种情况，当你在更新依赖JAR文件时，确保重新编译你的程序。 </p>
<h3 id="描述Java中的重载与重写？什么时候用重载，什么时候用重写？"><a href="#描述Java中的重载与重写？什么时候用重载，什么时候用重写？" class="headerlink" title="描述Java中的重载与重写？什么时候用重载，什么时候用重写？"></a>描述Java中的重载与重写？什么时候用重载，什么时候用重写？</h3><p>重载和重写都允许你用相同的名称来实现不同的功能，但是重载是编译时活动，而重写是运行时活动。你可以在同一个类中重载方法，但是只能在子类中重写方法。重写必须要有继承。</p>
<p>如果你看到一个类的不同实现有着不同的方式来做同一件事，那么就应该用重写（overriding），而重载（overloading）是用不同的输入做同一件事。在Java中，重载的方法签名不同，而重写并不是。</p>
<h3 id="BeanFactory和ApplicationContext的区别"><a href="#BeanFactory和ApplicationContext的区别" class="headerlink" title="BeanFactory和ApplicationContext的区别"></a>BeanFactory和ApplicationContext的区别</h3><blockquote>
<p>相关文章：[面试还不知道BeanFactory和ApplicationContext的区别？][3]</p>
</blockquote>
<h3 id="Java7、Java8的新特性"><a href="#Java7、Java8的新特性" class="headerlink" title="Java7、Java8的新特性"></a>Java7、Java8的新特性</h3><blockquote>
<p>相关文章：<a href="https://blog.csdn.net/csdnlijingran/article/details/88855000" target="_blank" rel="noopener">JDK7和JDK8新特性</a></p>
</blockquote>
<h2 id="JAVA-集合"><a href="#JAVA-集合" class="headerlink" title="JAVA 集合"></a>JAVA 集合</h2><p><strong>Collection</strong>：Collection 是集合 List、Set、Queue 的最基本的接口。</p>
<p><strong>Iterator</strong>：迭代器，可以通过迭代器遍历集合中的数据。</p>
<p><strong>Map</strong>：是映射表的基础接口。</p>
<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>Java 的 List 是非常常用的数据类型。List 是有序的 Collection。</p>
<p>Java List 一共三个实现类：分别是 ArrayList、Vector 和 LinkedList。</p>
<h4 id="ArrayList（数组）"><a href="#ArrayList（数组）" class="headerlink" title="ArrayList（数组）"></a>ArrayList（数组）</h4><p>ArrayList 是最常用的 List 实现类，内部是通过数组实现的，它允许对元素进行快速随机访问。数</p>
<p>组的缺点是每个元素之间不能有间隔，当数组大小不满足时需要增加存储能力，就要将已经有数</p>
<p>组的数据复制到新的存储空间中。当从 ArrayList 的中间位置插入或者删除元素时，需要对数组进</p>
<p>行复制、移动、代价比较高。因此，它适合随机查找和遍历，不适合插入和删除。</p>
<h4 id="Vector（数组实现、线程同步）"><a href="#Vector（数组实现、线程同步）" class="headerlink" title="Vector（数组实现、线程同步）"></a>Vector（数组实现、线程同步）</h4><p>Vector 与 ArrayList 一样，也是通过数组实现的，不同的是它支持线程的同步，即某一时刻只有一</p>
<p>个线程能够写 Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，因此，</p>
<p>访问它比访问 ArrayList 慢。</p>
<h4 id="LinkList（链表）"><a href="#LinkList（链表）" class="headerlink" title="LinkList（链表）"></a>LinkList（链表）</h4><p>LinkedList 是用链表结构存储数据的，很适合数据的动态插入和删除，随机访问和遍历速度比较</p>
<p>慢。另外，他还提供了 List 接口中没有定义的方法，专门用于操作表头和表尾元素，可以当作堆</p>
<p>栈、队列和双向队列使用。</p>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>Set 注重独一无二的性质,该体系集合用于存储无序(存入和取出的顺序不一定相同)元素，值不能重<br>复。对象的相等性本质是对象 hashCode 值（java 是依据对象的内存地址计算出的此序号）判断<br>的，如果想要让两个不同的对象视为相等的，就必须覆盖 Object 的 hashCode 方法和 equals 方<br>法</p>
<h4 id="HashSet（Hash-表）"><a href="#HashSet（Hash-表）" class="headerlink" title="HashSet（Hash 表）"></a>HashSet（Hash 表）</h4><p>哈希表边存放的是哈希值。HashSet 存储元素的顺序并不是按照存入时的顺序（和 List 显然不</p>
<p>同） 而是按照哈希值来存的所以取数据也是按照哈希值取得。元素的哈希值是通过元素的</p>
<p>hashcode 方法来获取的, HashSet 首先判断两个元素的哈希值，如果哈希值一样，接着会比较</p>
<p>equals 方法 如果 equls 结果为 true ，HashSet 就视为同一个元素。如果 equals 为 false 就不是</p>
<p>同一个元素。</p>
<p>哈希值相同 equals 为 false 的元素是怎么存储呢,就是在同样的哈希值下顺延（可以认为哈希值相</p>
<p>同的元素放在一个哈希桶中）。也就是哈希一样的存一列。如图 1 表示 hashCode 值不相同的情</p>
<p>况；图 2 表示 hashCode 值相同，但 equals 不相同的情况。</p>
<p>HashSet 通过 hashCode 值来确定元素在内存中的位置。一个 hashCode 位置上可以存放多个元</p>
<p>素。</p>
<h4 id="TreeSet（二叉树）"><a href="#TreeSet（二叉树）" class="headerlink" title="TreeSet（二叉树）"></a>TreeSet（二叉树）</h4><ol>
<li>TreeSet()是使用二叉树的原理对新 add()的对象按照指定的顺序排序（升序、降序），每增</li>
</ol>
<p>加一个对象都会进行排序，将对象插入的二叉树指定的位置。</p>
<ol start="2">
<li>Integer 和 String 对象都可以进行默认的 TreeSet 排序，而自定义类的对象是不可以的，自</li>
</ol>
<p>己定义的类必须实现 Comparable 接口，并且覆写相应的 compareTo()函数，才可以正常使</p>
<p>用。</p>
<ol start="3">
<li><p>在覆写 compare()函数时，要返回相应的值才能使 TreeSet 按照一定的规则来排序</p>
</li>
<li><p>比较此对象与指定对象的顺序。如果该对象小于、等于或大于指定对象，则分别返回负整</p>
</li>
</ol>
<p>数、零或正整数。</p>
<h4 id="LinkHashSet（HashSet-LinkedHashMap）"><a href="#LinkHashSet（HashSet-LinkedHashMap）" class="headerlink" title="LinkHashSet（HashSet+LinkedHashMap）"></a>LinkHashSet（HashSet+LinkedHashMap）</h4><p>对于 LinkedHashSet 而言，它继承与 HashSet、又基于 LinkedHashMap 来实现的。</p>
<p>LinkedHashSet 底层使用 LinkedHashMap 来保存所有元素，它继承与 HashSet，其所有的方法</p>
<p>操作上又与 HashSet 相同，因此 LinkedHashSet 的实现上非常简单，只提供了四个构造方法，并</p>
<p>通过传递一个标识参数，调用父类的构造器，底层构造一个 LinkedHashMap 来实现，在相关操</p>
<p>作上与父类 HashSet 的操作相同，直接调用父类 HashSet 的方法即可。</p>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a><strong>Map</strong></h3><h4 id="HashMap（数组-链表-红黑树）"><a href="#HashMap（数组-链表-红黑树）" class="headerlink" title="HashMap（数组+链表+红黑树）"></a>HashMap（数组+链表+红黑树）</h4><p>HashMap 根据键的 hashCode 值存储数据，大多数情况下可以直接定位到它的值，因而具有很快</p>
<p>的访问速度，但遍历顺序却是不确定的。</p>
<p> HashMap 最多只允许一条记录的键为 null，允许多条记</p>
<p>录的值为 null。</p>
<p>HashMap 非线程安全，即任一时刻可以有多个线程同时写 HashMap，可能会导</p>
<p>致数据的不一致。如果需要满足线程安全，可以用 Collections 的 synchronizedMap 方法使</p>
<p>HashMap 具有线程安全的能力，或者使用 ConcurrentHashMap。我们用下面这张图来介绍</p>
<p>HashMap 的结构。</p>
<h4 id="HashTable（线程安全）"><a href="#HashTable（线程安全）" class="headerlink" title="HashTable（线程安全）"></a>HashTable（线程安全）</h4><p>Hashtable 是遗留类，很多映射的常用功能与 HashMap 类似，不同的是它承自 Dictionary 类，</p>
<p>并且是线程安全的，任一时间只有一个线程能写 Hashtable，并发性不如 ConcurrentHashMap，</p>
<p>因为 ConcurrentHashMap 引入了分段锁。Hashtable 不建议在新代码中使用，不需要线程安全</p>
<p>的场合可以用 HashMap 替换，需要线程安全的场合可以用 ConcurrentHashMap 替换。</p>
<h4 id="TreeMap-（可排序）"><a href="#TreeMap-（可排序）" class="headerlink" title="TreeMap**（可排序）**"></a><strong>TreeMap**</strong>（可排序）**</h4><p>TreeMap 实现 SortedMap 接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，</p>
<p>也可以指定排序的比较器，当用 Iterator 遍历 TreeMap 时，得到的记录是排过序的。</p>
<p>如果使用排序的映射，建议使用 TreeMap。</p>
<p>在使用 TreeMap 时，key 必须实现 Comparable 接口或者在构造 TreeMap 传入自定义的</p>
<p>Comparator，否则会在运行时抛出 java.lang.ClassCastException 类型的异常。</p>
<p>参考：<a href="https://www.ibm.com/developerworks/cn/java/j-lo-tree/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-lo-tree/index.html</a></p>
<h4 id="LinkHashMap（记录插入顺序）"><a href="#LinkHashMap（记录插入顺序）" class="headerlink" title="LinkHashMap（记录插入顺序）"></a>LinkHashMap（记录插入顺序）</h4><p>LinkedHashMap 是 HashMap 的一个子类，保存了记录的插入顺序，在用 Iterator 遍历</p>
<p>LinkedHashMap 时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。</p>
<p>参考 1：<a href="http://www.importnew.com/28263.html" target="_blank" rel="noopener">http://www.importnew.com/28263.html</a></p>
<p>参考 2：<a href="http://www.importnew.com/20386.html#comment-648123" target="_blank" rel="noopener">http://www.importnew.com/20386.html#comment-648123</a></p>
<h4 id="ArrayList和LinkedList各自实现和区别"><a href="#ArrayList和LinkedList各自实现和区别" class="headerlink" title="ArrayList和LinkedList各自实现和区别"></a>ArrayList和LinkedList各自实现和区别</h4><ul>
<li><code>ArrayList</code>是实现了基于动态数组的数据结构，<code>LinkedList</code>基于链表的数据结构。 （<code>LinkedList</code>是双向链表，有next也有previous）</li>
<li><code>ArrayList</code>和<code>LinkedList</code>而言，在列表末尾增加一个元素所花的开销都是固定的。对<code>ArrayList</code>而言，主要是在内部数组中增加一项，指向所添加的元素，偶尔可能会导致对数组重新进行分配；而对<code>LinkedList</code>而言，这个开销是统一的，分配一个内部<code>Entry</code>对象。</li>
<li><code>ArrayList</code>的中间插入或删除一个元素意味着这个列表中剩余的元素都会被移动；而在<code>LinkedList</code>的中间插入或删除一个元素的开销是固定的。</li>
<li><code>LinkedList</code>不支持高效的随机元素访问。</li>
<li><code>ArrayList</code>的空间浪费主要体现在在list列表的结尾预留一定的容量空间，而<code>LinkedList</code>的空间花费则体现在它的每一个元素都需要消耗相当的空间</li>
</ul>
<p>场景：<br><code>LinkedList</code>链表，插入删除快，查找修改慢。 适用于频繁增删的场景。<br><code>ArrayList</code>数组，查找快，插入删除慢。 适用于频繁查找和修改的场景。</p>
<h4 id="怎么给List排序？"><a href="#怎么给List排序？" class="headerlink" title="怎么给List排序？"></a>怎么给List排序？</h4><ul>
<li>使用  Collections.sort 默认正序，可以传第二个参数自定义排序。</li>
<li>自定义bean实现 Comparable 接口。</li>
<li>实现Comparator接口自定义比较器。</li>
</ul>
<h4 id="都知道哪些常用的Map集合"><a href="#都知道哪些常用的Map集合" class="headerlink" title="都知道哪些常用的Map集合?"></a>都知道哪些常用的Map集合?</h4><p>HashMap、HashTable、TreeMap、LinkedHashMap</p>
<p><strong>HashMap介绍</strong></p>
<p><code>HashMap</code>中的数据结构为散列表，又名哈希表。<code>HashMap</code>是基于哈希表的<code>Map</code>接口的非同步实现。此实现提供所有可选的映射操作，并<strong><em>允许使用null值和null键</em></strong>。<br><code>HashMap</code>使用散列存储的方式保存kay-value键值对，因此其<strong><em>不支持数据保存的顺序</em></strong>。如果想要使用有序容器可以使用<code>LinkedHashMap</code>。<br><code>HashMap</code>是<strong><em>非线程安全的类</em></strong>，当作为共享可变资源使用的时候会出现线程安全问题。</p>
<ul>
<li><strong>数组</strong>：数组删除、插入性能不佳，寻址性能极优。其结构决定了其访问效率非常高，时间复杂度为 O(1)。这样的结构同时造成了对其进行插入和删除改动范围大的问题，影响了修改效率，时间复杂度为 O(n)。</li>
<li><strong>链表</strong>：链表查询性能不佳，删除、插入性能极优。链表的存储是通过一条（或两条）引用链条串联起来的，所以数据可以离散存储，对存储空间要求比较低。但其结构同样造成了其访问效率比较低，时间复杂度为 O(n)。数据的变更最多只会影响其相邻的两个数据节点，其时间复杂度仅仅为 O(1)。</li>
</ul>
<p><code>HashMap</code>使用数组+链表+树形结构的数据结构。除了数据本身的形式外，主要就是数据项查询和修改的效率。<br>哈希表的思想实际是基于数组可以通过下标随机访问数据的特性实现的。</p>
<p>参考：<br><a href="https://www.jianshu.com/p/b1d2d2711ccf" target="_blank" rel="noopener">HashMap实现原理</a><br><a href="https://www.jianshu.com/p/c561bab28e19" target="_blank" rel="noopener">HashMap实现原理</a><br><a href="https://www.cnblogs.com/vitasyuan/p/9220773.html" target="_blank" rel="noopener">HashMap实现原理及源码分析</a><br><a href="https://www.cnblogs.com/yuanblog/p/4441017.html" target="_blank" rel="noopener">Java中HashMap的实现原理</a></p>
<h4 id="hashtable和hashmap的区别"><a href="#hashtable和hashmap的区别" class="headerlink" title="hashtable和hashmap的区别"></a>hashtable和hashmap的区别</h4><p><strong>继承的父类不同</strong></p>
<p><code>Hashtable</code>继承自<code>Dictionary</code>类，而<code>HashMap</code>继承自<code>AbstractMap</code>类。但二者都实现了<code>Map</code>接口。</p>
<p><strong>线程安全性不同</strong></p>
<p><code>javadoc</code>中关于<code>hashmap</code>的一段描述如下：此实现不是同步的。如果多个线程同时访问一个哈希映射，而其中至少一个线程从结构上修改了该映射，则它必须保持外部同步。</p>
<p><strong>是否提供contains方法</strong></p>
<p><code>HashMap</code>把<code>Hashtable</code>的<code>contains</code>方法去掉了，改成<code>containsValue</code>和<code>containsKey</code>，因为<code>contains</code>方法容易让人引起误解。<br><code>Hashtable</code>则保留了<code>contains</code>，<code>containsValue</code>和<code>containsKey</code>三个方法，其中<code>contains</code>和<code>containsValue</code>功能相同。</p>
<p><strong>key和value是否允许null值</strong></p>
<p>其中key和value都是对象，并且不能包含重复key，但可以包含重复的value。<br><code>Hashtable</code>中，key和value都不允许出现null值。但是如果在<code>Hashtable</code>中有类似<code>put(null,null)</code>的操作，编译同样可以通过，<br>因为key和value都是<code>Object</code>类型，但运行时会抛出<code>NullPointerException</code>异常，这是JDK的规范规定的。</p>
<p><code>HashMap</code>中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null。<br>当<code>get()</code>方法返回null值时，可能是 <code>HashMap</code>中没有该键，也可能使该键所对应的值为null。<br>因此，在<code>HashMap</code>中不能由<code>get()</code>方法来判断<code>HashMap</code>中是否存在某个键， 而应该用<code>containsKey()</code>方法来判断。</p>
<p><strong>两个遍历方式的内部实现上不同</strong></p>
<p><code>Hashtable</code>、<code>HashMap</code>都使用了<code>Iterator</code>。而由于历史原因，<code>Hashtable</code>还使用了<code>Enumeration</code>的方式 。</p>
<p><strong>hash值不同</strong></p>
<p>哈希值的使用不同，<code>HashTable</code>直接使用对象的<code>hashCode</code>。而<code>HashMap</code>重新计算hash值。<br><code>hashCode</code>是jdk根据对象的地址或者字符串或者数字算出来的<code>int</code>类型的数值。<br><code>Hashtable</code>计算hash值，直接用key的<code>hashCode()</code>，而<code>HashMap</code>重新计算了key的hash值，<code>Hashtable</code>在求hash值对应的位置索引时，用取模运算，而<code>HashMap</code>在求位置索引时，则用与运算，且这里一般先用hash&amp;0x7FFFFFFF后，再对length取模，&amp;0x7FFFFFFF的目的是为了将负的hash值转化为正值，因为hash值有可能为负数，而&amp;0x7FFFFFFF后，只有符号外改变，而后面的位都不变。</p>
<p><strong>内部实现使用的数组初始化和扩容方式不同</strong></p>
<p><code>HashTable</code>在不指定容量的情况下的默认容量为11，而<code>HashMap</code>为16，<code>Hashtable</code>不要求底层数组的容量一定要为2的整数次幂，而<code>HashMap</code>则要求一定为2的整数次幂。<br><code>Hashtable</code>扩容时，将容量变为原来的2倍加1，而<code>HashMap</code>扩容时，将容量变为原来的2倍。<br><code>Hashtable</code>和<code>HashMap</code>它们两个内部实现方式的数组的初始大小和扩容的方式。<code>HashTable</code>中hash数组默认大小是11，增加的方式是 old*2+1。</p>
<p><code>Hashtable</code> 中的方法是<code>Synchronize</code>的，而<code>HashMap</code>中的方法在缺省情况下是非<code>Synchronize</code>的。在多线程并发的环境下，可以直接使用<code>Hashtable</code>，不需要自己为它的方法实现同步，但使用<code>HashMap</code>时就必须要自己增加同步处理。（结构上的修改是指添加或删除一个或多个映射关系的任何操作；仅改变与实例已经包含的键关联的值不是结构上的修改。）这一般通过对自然封装该映射的对象进行同步操作来完成。</p>
<p>如果不存在这样的对象，则应该使用 <code>Collections.synchronizedMap</code> 方法来“包装”该映射。最好在创建时完成这一操作，以防止对映射进行意外的非同步访问，如下所示：</p>
<pre><code class="java">Map m = Collections.synchronizedMap(new HashMap(...));</code></pre>
<p><code>Hashtable</code> 线程安全很好理解，因为它每个方法中都加入了<code>Synchronize</code>。<br><code>HashMap</code>底层是一个<code>Entry</code>数组，当发生hash冲突的时候，hashmap是采用链表的方式来解决的，在对应的数组位置存放链表的头结点。对链表而言，新加入的节点会从头结点加入。</p>
<h2 id="Java异常"><a href="#Java异常" class="headerlink" title="Java异常"></a>Java异常</h2><h3 id="Java检查异常、非检查异常、运行时异常、非运行时异常的区别"><a href="#Java检查异常、非检查异常、运行时异常、非运行时异常的区别" class="headerlink" title="Java检查异常、非检查异常、运行时异常、非运行时异常的区别"></a>Java检查异常、非检查异常、运行时异常、非运行时异常的区别</h3><p>Java把所有的非正常情况分为两种： <strong>异常（Exception）</strong>和 <strong>错误（Error） __，它们都继承<code>Throwable</code>父类。<br>Java的异常分为 __检查异常</strong> 和 <strong>非检查的异常</strong>。<br>其中根据<code>Exception</code>异常进行分类，可分为 <strong>运行时异常</strong>和 <strong>非运行时异常</strong>。</p>
<p><strong>异常：</strong></p>
<p>就是编译器要求你必须处理的异常。比如我们在编程某个文件的读于写时，编译器要求你必须要对某段代码try….catch… 或者 throws exception，这就是检查异常.简单的来说，你代码还没有运行，编码器就会检查你的代码，对可能出现的异常必须做出相对的处理。（比如当文件不存在时..）</p>
<p><strong>处理检查异常：</strong></p>
<ul>
<li>续往上抛出，（这是一个消极的方法），一直可以抛到java虚拟机来处理，通过throw exception抛出。</li>
<li>try…catch捕获</li>
</ul>
<p>(提示) 对于检查时的异常必须处理，或者必须捕获或者必须抛出</p>
<p><strong>检查异常大概有哪些？</strong></p>
<p>除了<code>RuntimeException</code>与其派生类(子类),以及错误(Error)。其他的差不多都是检查异常。</p>
<p><strong>检查异常：</strong></p>
<p>编译器不要求强制处置的异常，虽然有可能出现错误，但是我不会在编译的时候检查。</p>
<p><strong>如何处理非检查异常：</strong></p>
<ul>
<li>try….catch捕获</li>
<li>续抛出</li>
<li>处理</li>
</ul>
<p>这类异常一般我们是不处理的，因为会很判断会出现什么问题，而且有些异常你也无法运行时处理，比如空指针。</p>
<p><strong>非检查异常有哪些：</strong></p>
<p><code>RuntimeException</code>与其子类，以及错误(Error)</p>
<p><code>Exception</code>异常进行划分，它可分为运行时异常和非运行时异常。</p>
<p><strong>运行时异常:</strong></p>
<p>都是<code>RuntimeException</code>类及其子类异常，如<code>NullPointerException</code>(空指针异常)、<code>IndexOutOfBoundsException</code>(下标越界异常)等，这些异常是非检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。</p>
<p>运行时异常的特点是Java编译器不会检查它，也就是说，当程序中可能出现这类异常，即使没有用try-catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过</p>
<p><strong>非运行时异常：</strong></p>
<p>是<code>RuntimeException</code>以外的异常，类型上都属于<code>Exception</code>类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如<code>IOException</code>、<code>SQLException</code>等以及用户自定义的<code>Exception</code>异常，一般情况下不要自定义检查异常。</p>
<h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><h4 id="jsp和servlet的区别"><a href="#jsp和servlet的区别" class="headerlink" title="jsp和servlet的区别"></a>jsp和servlet的区别</h4><p><strong>什么是servlet:</strong></p>
<ul>
<li><code>Servlet</code>是一种服务器端的Java应用程序，具有独立于平台和协议的特性,可以生成动态的Web页面。 </li>
<li>它担当客户请求（Web浏览器或其他HTTP客户程序）与服务器响应（HTTP服务器上的数据库或应用程序）的中间层。</li>
</ul>
<p><strong>什么是jsp：</strong></p>
<ul>
<li><code>JSP</code>全名为<code>Java Server Pages</code>，中文名叫java服务器页面，其根本是一个简化的<code>Servlet</code>设计，它  是由Sun Microsystems公司倡导、许多公司参与一起建立的一种动态网页技术标准。</li>
<li><code>jsp</code>就是在html里面写java代码，<code>servlet</code>就是在java里面写html代码</li>
<li><code>jsp</code>更侧重于前端页面显示，<code>servlet</code>更侧重于业务逻辑。</li>
<li><code>Jsp</code> 本质上是<code>servle</code>t，用<code>jsp</code>实现的页面用<code>servlet</code>也能实现。</li>
</ul>
<p><strong>servlet和jsp的共同点和不同点：</strong></p>
<ul>
<li><code>servlet</code>在java代码中通过http servlet response来动态的生成一个html页面 </li>
<li><code>jsp</code>是通过吧java代码嵌入到html中去生成一个动态的html页面 </li>
</ul>
<p>一个是在java中写html，另一个是在html中写java代码</p>
<p><strong>jsp和servlet出现的意义：</strong></p>
<ul>
<li>当我们使用<code>servlet</code>来生成动态页面的时候，会非常的复杂。因为需要在out.println()来写入html语句。但是<code>servlet</code>在处理前端和后台数据交互的时候有特别的优秀。 </li>
<li>因此在这个时候我们引入<code>jsp</code>技术来替代<code>servlet</code>生成html的功能。让<code>serlvet</code>只专注前端页面和后台数据的交互。从而也是实现来mvc的思想。</li>
</ul>
<h4 id="hibernate跟Mybatis-ibatis-的区别"><a href="#hibernate跟Mybatis-ibatis-的区别" class="headerlink" title="hibernate跟Mybatis/ ibatis 的区别"></a>hibernate跟Mybatis/ ibatis 的区别</h4><blockquote>
<p>相关文章：[Hibernate与 MyBatis的比较][0]</p>
</blockquote>
<p><strong>两者相同点</strong></p>
<ul>
<li>Hibernate与MyBatis都可以是通过<code>SessionFactoryBuider</code>由XML配置文件生成<code>SessionFactory</code>，然后由<code>SessionFactory</code>生成<code>Session</code>，最后由<code>Session</code>来开启执行事务和SQL语句。其中<code>SessionFactoryBuider</code>，<code>SessionFactory</code>，<code>Session</code>的生命周期都是差不多的。</li>
<li>Hibernate和MyBatis都支持JDBC和JTA事务处理。</li>
</ul>
<p><strong>Mybatis优势</strong></p>
<ul>
<li>MyBatis可以进行更为细致的SQL优化，可以减少查询字段。MyBatis容易掌握，而Hibernate门槛较高。</li>
</ul>
<p><strong>Hibernate优势</strong></p>
<ul>
<li>Hibernate的DAO层开发比MyBatis简单，Mybatis需要维护SQL和结果映射。</li>
<li>Hibernate对对象的维护和缓存要比MyBatis好，对增删改查的对象的维护要方便。</li>
<li>Hibernate数据库移植性很好，MyBatis的数据库移植性不好，不同的数据库需要写不同SQL。</li>
<li>Hibernate有更好的二级缓存机制，可以使用第三方缓存。MyBatis本身提供的缓存机制不佳。</li>
</ul>
<h4 id="Hibernate的原理体系架构，五大核心接口，Hibernate对象的三种状态转换，事务管理。"><a href="#Hibernate的原理体系架构，五大核心接口，Hibernate对象的三种状态转换，事务管理。" class="headerlink" title="Hibernate的原理体系架构，五大核心接口，Hibernate对象的三种状态转换，事务管理。"></a>Hibernate的原理体系架构，五大核心接口，Hibernate对象的三种状态转换，事务管理。</h4><p>五大核心接口：</p>
<p><code>Configuration</code>接口：配置<code>Hibernate</code>,根启动<code>Hibernate</code>，创建<code>SessionFactory</code>对象。</p>
<p><code>SessionFactory</code>接口：初始化<code>Hibernate</code>，充当数据存储源的代理，创建<code>Session</code>对象。</p>
<p><code>Session</code>接口：负责保存、更新、删除、加载和查询对象。</p>
<p><code>Transaction</code>接口：管理事务。</p>
<p><code>Query</code>和<code>Criteria</code>接口：执行数据库查询。</p>
<p>三种状：<a href="https://www.cnblogs.com/smellpawn/p/10789369.html" target="_blank" rel="noopener">三种状态的转换</a></p>
<p>*<em>瞬时状态 (Transient) *</em></p>
<p>当我们通过Java的<code>new</code>关键字来生成一个实体对象时，这时这个实体对象就处于自由状态</p>
<p><strong>瞬时对象特点：</strong></p>
<p>不和<code>Session</code>实例关联 在数据库中没有和瞬时对象关联的记录</p>
<p><strong>持久状态 (Persistent)</strong></p>
<p>持久化对象就是已经被保存进数据库的实体对象，并且这个实体对象现在还处于<code>Hibernate</code>的缓存管理之中。这是对该实体对象的任何修改，都会在清理缓存时同步到数据库中。</p>
<p><strong>瞬时对象转为持久对象：</strong></p>
<p>通过 <code>Session</code> 的 <code>save()</code> 和 <code>saveOrUpdate()</code> 方法把一个瞬时对象与数据库相关联，这个瞬时对象就成为持久化对象。<br>使用 <code>fine()</code>,<code>get()</code>,<code>load()</code> 和<code>iterater()</code>待方法查询到的数据对象，将成为持久化对象。</p>
<p><strong>持久化对象的特点：</strong></p>
<p>和<code>Session</code>实例关联 在数据库中有和持久对象关联的记录</p>
<p><strong>脱管状态 (Detached) 游离状态</strong></p>
<p>当一个持久化对象，脱离开<code>Hibernate</code>的缓存管理后，它就处于游离状态，游离对象和自由对象的最大区别在于，游离对象在数据库中可能还存在一条与它对应的记录。</p>
<p>只是现在这个游离对象脱离了<code>Hibernate</code>的缓存管理，而自由对象不会在数据库中出现与它对应的数据记录。</p>
<p><strong>脱管对象特点：</strong></p>
<p>本质上和瞬时对象相同 只是比爱瞬时对象多了一个数据库记录标识值 id.</p>
<p><strong>持久对象转为脱管对象：</strong></p>
<p>当执行<code>close()</code>或<code>clear()</code>,<code>evict()</code>之后，持久对象会变为脱管对象。</p>
<p><strong>瞬时对象转为持久对象：</strong></p>
<p>通过 <code>Session</code> 的 <code>update()</code>,<code>saveOrUpdate()</code> 和 <code>lock()</code> 等方法，把脱管对象变为持久对象。</p>
<p><strong>事务管理：</strong></p>
<p>事务就是逻辑上的一组操作，组成这组操作的各个单元要么全部成功，要么全都失败。</p>
<p><strong>事务四个特性</strong></p>
<ul>
<li><p><strong>原子性</strong>: 不可分割</p>
</li>
<li><p><strong>一致性</strong>: 事务在执行前后，要保证数据的一致。</p>
</li>
<li><p><strong>隔离性</strong>: 一个事务在执行的过程中，不应该受到其它事务的干扰。</p>
</li>
<li><p><strong>持久性</strong>: 事务一旦结束，数据持久化到数据库。</p>
</li>
</ul>
<p><strong>问题:不考虑事务的隔离性，会产生什么问题?</strong></p>
<ul>
<li><strong>脏读</strong>: 一个事务读取到另一个事务的未提交数据</li>
<li><strong>不可重复读</strong>: 一个事务读取到另一个事务提交的数据(主要是指update)，会导致两次读取的结果不一致。</li>
<li><strong>虚读(幻读)</strong>: 一个事务读取到另一个事务提交的数据(主要是指insert),会导致两次读取结果不一致.</li>
</ul>
<p><strong>问题:对于上述问题如何解决?</strong></p>
<p>我们可以通过设置隔离级别来解决.</p>
<ul>
<li><code>READ_UNCOMMITED</code> 读取未提交， 它引发所有的隔离问题</li>
<li><code>READ_COMMITTED</code> 读已提交, 阻止脏读，可能发生不可重复读与虚读.</li>
<li><code>REPEATABLE_READ</code> 重复读 阻止脏读，不可重复读 可能发生虚读</li>
<li><code>SERIALIZABLE</code> 串行化 解决所有问题 不允许两个事务，同时操作一个目标数据。（效率低下）</li>
<li><code>ORACLE</code> 默认的是事务隔离级别 <code>READ_COMMITTED</code></li>
<li><code>MYSQL</code> 默认的事务隔离级别 <code>REPEATABLE_READ</code></li>
</ul>
<p><strong>Hibernate提供了三种管理session的方式:</strong></p>
<ul>
<li><code>Session</code>对象的生命周期与本地线程绑定(<code>ThreadLocal</code>)</li>
<li><code>Session</code>对象的生命周期与<code>JTA</code>事务绑定(分布式事务管理)</li>
<li><code>Hibernate</code>委托程序来管理<code>Session</code>的生命周期</li>
</ul>
<h3 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h3><h4 id="MyBatis框架的缺点？"><a href="#MyBatis框架的缺点？" class="headerlink" title="MyBatis框架的缺点？"></a>MyBatis框架的缺点？</h4><ul>
<li>SQL语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写SQL语句的功底有一定要求。</li>
<li>SQL语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。</li>
</ul>
<h4 id="MyBatis框架适用场合？"><a href="#MyBatis框架适用场合？" class="headerlink" title="MyBatis框架适用场合？"></a>MyBatis框架适用场合？</h4><ul>
<li>MyBatis专注于SQL本身，是一个足够灵活的DAO层解决方案。</li>
<li>对性能的要求很高，或者需求变化较多的项目，如互联网项目，MyBatis将是不错的选择。</li>
</ul>
<h4 id="Mybatis动态sql有什么用？执行原理？有哪些动态sql？"><a href="#Mybatis动态sql有什么用？执行原理？有哪些动态sql？" class="headerlink" title="Mybatis动态sql有什么用？执行原理？有哪些动态sql？"></a>Mybatis动态sql有什么用？执行原理？有哪些动态sql？</h4><p>Mybatis动态sql可以在Xml映射文件内，以标签的形式编写动态sql，执行原理是根据表达式的值 完成逻辑判断并动态拼接sql的功能。</p>
<p>Mybatis提供了9种动态sql标签：trim | where | set | foreach | if | choose | when | otherwise | bind。</p>
<h4 id="Xml映射文件中，除了常见的select-insert-updae-delete标签之外，还有哪些标签？"><a href="#Xml映射文件中，除了常见的select-insert-updae-delete标签之外，还有哪些标签？" class="headerlink" title="Xml映射文件中，除了常见的select|insert|updae|delete标签之外，还有哪些标签？"></a>Xml映射文件中，除了常见的select|insert|updae|delete标签之外，还有哪些标签？</h4><p><code>&lt;resultMap&gt;</code>、<code>&lt;parameterMap&gt;</code>、<code>&lt;sql&gt;</code>、<code>&lt;include&gt;</code>、<code>&lt;selectKey&gt;</code>，加上动态sql的9个标签，其中<code>&lt;sql&gt;</code>为sql片段标签，通过<code>&lt;include&gt;</code>标签引入sql片段，<code>&lt;selectKey&gt;</code>为不支持自增的主键生成策略标签。</p>
<h4 id="为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？"><a href="#为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？" class="headerlink" title="为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？"></a>为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？</h4><p>Hibernate属于全自动ORM映射工具，使用Hibernate查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。而Mybatis在查询关联对象或关联集合对象时，需要手动编写sql来完成，所以，称之为半自动ORM映射工具。</p>
<h4 id="MyBatis实现一对一有几种方式-具体怎么操作的？"><a href="#MyBatis实现一对一有几种方式-具体怎么操作的？" class="headerlink" title="MyBatis实现一对一有几种方式?具体怎么操作的？"></a>MyBatis实现一对一有几种方式?具体怎么操作的？</h4><p>有联合查询和嵌套查询,联合查询是几个表联合查询,只查询一次, 通过在resultMap里面配置association节点配置一对一的类就可以完成；</p>
<p>嵌套查询是先查一个表，根据这个表里面的结果的 外键id，去再另外一个表里面查询数据,也是通过association配置，但另外一个表的查询通过select属性配置。</p>
<h4 id="MyBatis实现一对多有几种方式-怎么操作的？"><a href="#MyBatis实现一对多有几种方式-怎么操作的？" class="headerlink" title="MyBatis实现一对多有几种方式,怎么操作的？"></a>MyBatis实现一对多有几种方式,怎么操作的？</h4><p>有联合查询和嵌套查询。联合查询是几个表联合查询,只查询一次,通过在resultMap里面的collection节点配置一对多的类就可以完成；嵌套查询是先查一个表,根据这个表里面的 结果的外键id,去再另外一个表里面查询数据,也是通过配置collection,但另外一个表的查询通过select节点配置</p>
<h4 id="Mybatis的一级、二级缓存"><a href="#Mybatis的一级、二级缓存" class="headerlink" title="Mybatis的一级、二级缓存"></a>Mybatis的一级、二级缓存</h4><p><strong>一级缓存</strong>: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认打开一级缓存。</p>
<p><strong>二级缓存</strong>: 与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储，不同在于其存储作用域为 Mapper(Namespace)，并且可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现Serializable序列化接口(可用来保存对象的状态),可在它的映射文件中配置<code>&lt;cache/&gt;</code></p>
<p>对于缓存数据更新机制，当某一个作用域(一级缓存 Session/二级缓存Namespaces)的进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear。 </p>
<h3 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h3><h4 id="使用Spring框架的好处是什么？"><a href="#使用Spring框架的好处是什么？" class="headerlink" title="使用Spring框架的好处是什么？"></a>使用Spring框架的好处是什么？</h4><p><strong><em>轻量：</em></strong> Spring 是轻量的，基本的版本大约2MB。<br><strong><em>控制反转：</em></strong> Spring通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是创建或查找依赖的对象们。<br><strong><em>面向切面的编程(AOP)：</em></strong> Spring支持面向切面的编程，并且把应用业务逻辑和系统服务分开。<br><strong><em>容器：</em></strong> Spring 包含并管理应用中对象的生命周期和配置。<br><strong><em>MVC框架：</em></strong> Spring的WEB框架是个精心设计的框架，是Web框架的一个很好的替代品。<br><strong><em>事务管理：</em></strong> Spring 提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事务（JTA）。<br><strong><em>异常处理：</em></strong> Spring 提供方便的API把具体技术相关的异常（比如由JDBC，Hibernate or JDO抛出的）转化为一致的unchecked 异常。</p>
<h4 id="springMVC流程说明"><a href="#springMVC流程说明" class="headerlink" title="springMVC流程说明"></a>springMVC流程说明</h4><ul>
<li>客户端（浏览器）发送请求，直接请求到<code>DispatcherServlet</code>。</li>
<li>由 DispatcherServlet 控制器查询一个或多个 HandlerMapping，找到处理请求的Controller。</li>
<li>DispatcherServlet 将请求提交到 Controller。</li>
<li>Controller 调用业务逻辑处理</li>
<li>处理器处理完业务后，会返回一个<code>ModelAndView</code>对象，<code>Model</code>是返回的数据对象<code>View</code>是个逻辑上的<code>View</code>。</li>
<li><code>ViewResolver</code>会根据逻辑<code>View</code>查找实际的<code>View</code>。</li>
<li><code>DispaterServlet</code>把返回的<code>Model</code>传给<code>View</code>。</li>
<li>通过<code>View</code>返回给请求者（浏览器）</li>
</ul>
<h4 id="什么是Spring-MVC框架的控制器？"><a href="#什么是Spring-MVC框架的控制器？" class="headerlink" title="什么是Spring MVC框架的控制器？"></a>什么是Spring MVC框架的控制器？</h4><p>控制器提供一个访问应用程序的行为，此行为通常通过服务接口实现。控制器解析用户输入并将其转换为一个由视图呈现给用户的模型。Spring用一个非常抽象的方式实现了一个控制层，允许用户创建多种用途的控制器。</p>
<h4 id="spring注入的几种方式（循环注入）"><a href="#spring注入的几种方式（循环注入）" class="headerlink" title="spring注入的几种方式（循环注入）"></a>spring注入的几种方式（循环注入）</h4><p><strong>构造方法注入 构造函数注入</strong></p>
<p>构造函数注入是除属性注入之外的另一种常用的注入方式，它可以保证一些必要的属性在bean实例化时就得到了设置，并在实例化后就可以使用。<br>循环依赖问题</p>
<p>Spring容器对构造函数配置Bean进行实例化有一个前提，即Bean构造函数入参引用的对象必须已经准备就绪。由于这个机制，如果两个Bean都相互引用，都采用构造函数注入方式，就会发生类似于线程死锁的循环依赖问题。</p>
<p><strong>构造函数注入方式：</strong></p>
<p><strong>优点：</strong></p>
<ul>
<li>构造函数可以保证一些重要的属性在bean实例化的时候就设置好，避免因为一些重要的属性没有提供而导致一个无用的Bean 实例情况</li>
<li>不需要为每个属性提供Setter方法，减少了类的方法个数</li>
<li>可以更好的封装类变量，不需要为每个属性提供Setter方法，避免外部错误的调用</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>如果一个类属性太多，那么构造函数的参数将变成一个庞然大物，可读性较差</li>
<li>灵活性不强，在有些属性是可选的情况下，如果通过构造函数注入，也需要为可选的参数提供一个null值</li>
<li>如果有多个构造函数，则需要考虑配置文件和具体构造函数匹配歧义的问题，配置上相对复杂</li>
<li>构造函数不利于类的继承和拓展，因为子类需要引用父类复杂的构造函数</li>
<li>构造函数注入有时会造成循环依赖的问题</li>
</ul>
<p><strong>setter注入 属性注入</strong><br>属性注入即通过<code>setXXX( )</code>方法注入bean的属性值或依赖对象。由于属性注入方式具有可选择性和灵活性高的特点，因此它也是实际开发中最常用的注入方式。</p>
<p><strong>基于注解的注入 工厂方法注入</strong><br>工厂方法是应用中被经常使用的设计模式，也是 控制反转 和 单实例设计思想 的主要实现方法。工厂类负责创建一个或多个工厂类实例，工厂类方法一般以接口或抽象类变量的形式返回目标类实例。</p>
<p><strong>Spring工厂注入的方法可以分为 静态 和 非静态 两种。</strong></p>
<p><strong>【非静态工厂方法】</strong></p>
<p>有些工厂方法是非静态的，必须实例化工厂类之后才能调用工厂方法。下面通过一个实例来演示。</p>
<p><strong>【静态工厂方法】</strong></p>
<p>很多工厂类方法都是静态的，这意味着无需创建工厂类实例的情况下就可以调用工厂类方法。因此静态工程方法比非静态工厂方法的调用更加方便简洁。下面通过一个实例来演示静态工厂方法。</p>
<p><strong>构造函数注入理由：</strong></p>
<p>构造函数保证重要属性预先设置；<br>无需提供每个属性的setter方法，减少类的方法个数；<br>可以更好地封装类变量，避免外部错误调用。</p>
<p><strong>属性注入理由：</strong></p>
<p>属性过多时，构造函数变的臃肿；<br>构造函数注入灵活性不强，有时需要为属性注入null值；<br>多个构造函数时，配置上产生歧义，复杂度升高；<br>构造函数不利于类的继承和扩展；<br>构造函数注入会引起循环依赖的问题。 </p>
<p>相关文章:</p>
<p><a href="https://blog.csdn.net/qq_37464248/article/details/82463889" target="_blank" rel="noopener">Spring 依赖注入三种方式的实现，及循环依赖问题的解决（源码+XML配置）</a></p>
<p><a href="https://blog.csdn.net/shadow_zed/article/details/72566611" target="_blank" rel="noopener">Spring的五种依赖注入方式</a></p>
<h4 id="Spring框架的事务管理有哪些优点？"><a href="#Spring框架的事务管理有哪些优点？" class="headerlink" title="Spring框架的事务管理有哪些优点？"></a>Spring框架的事务管理有哪些优点？</h4><p>它为不同的事务API 如 JTA，JDBC，Hibernate，JPA 和JDO，提供一个不变的编程模式。<br>它为编程式事务管理提供了一套简单的API而不是一些复杂的事务API如<br>它支持声明式事务管理。<br>它和Spring各种数据访问抽象层很好得集成。</p>
<h4 id="spring如何实现事物管理的"><a href="#spring如何实现事物管理的" class="headerlink" title="spring如何实现事物管理的"></a>spring如何实现事物管理的</h4><p><strong>Spring内置AOP默认使用动态代理模式实现</strong></p>
<ul>
<li>编程式事务管理对基于 <code>POJO</code> 的应用来说是唯一选择。我们需要在代码中调用<code>beginTransaction()</code>、<code>commit()</code>、<code>rollback()</code>等事务管理相关的方法，这就是编程式事务管理。</li>
<li>基于 <code>TransactionProxyFactoryBean</code>的声明式事务管理</li>
<li>基于 <code>@Transactional</code> 的声明式事务管理</li>
<li>基于<code>Aspectj AOP</code>配置事务</li>
</ul>
<p>相关文章:<a href="https://www.cnblogs.com/yixianyixian/p/8372832.html" target="_blank" rel="noopener">spring事务管理(详解和实例)</a></p>
<h4 id="为什么说Spring是一个容器？"><a href="#为什么说Spring是一个容器？" class="headerlink" title="为什么说Spring是一个容器？"></a>为什么说Spring是一个容器？</h4><p>Spring的核心理念就是更方便地管理Java Bean，而被管理的Java Bean存缓存在一个Map中，这个Map就可以理解为用来装Java Bean的容器，即IOC容器</p>
<h4 id="springIOC-控制反转"><a href="#springIOC-控制反转" class="headerlink" title="springIOC 控制反转"></a>springIOC 控制反转</h4><p><code>IOC</code>的别名：<strong>依赖注入(DI)</strong><br><code>IOC</code>是<code>Inversion of Control</code>的缩写，多数书籍翻译成“控制反转”，还有些书籍翻译成为“控制反向”或者“控制倒置”。</p>
<p>为了解决对象之间的耦合度过高的问题 <strong>依赖注入(DI) __ 和 __控制反转(IOC)</strong> 是从不同的角度的描述的同一件事情，就是指通过引入<code>IOC</code>容器，利用依赖关系注入的方式，实现对象之间的解耦。</p>
<p>可以把<code>IOC</code>容器的工作模式看做是工厂模式的升华，可以把<code>IOC</code>容器看作是一个工厂，这个工厂里要生产的对象都在配置文件中给出定义，然后利用编程语言的的反射编程，根据配置文件中给出的类名生成相应的对象。</p>
<p>从实现来看，<code>IOC</code>是把以前在工厂方法里写死的对象生成代码，改变为由配置文件来定义，也就是把工厂和对象生成这两者独立分隔开来，目的就是提高灵活性和可维护性。</p>
<p>相关文章:[<a href="https://www.cnblogs.com/superjt/p/4311577.html" target="_blank" rel="noopener">Spring的IOC原理通俗解释一下</a></p>
<h4 id="IOC的优点是什么？"><a href="#IOC的优点是什么？" class="headerlink" title="IOC的优点是什么？"></a>IOC的优点是什么？</h4><p>IOC 或 依赖注入把应用的代码量降到最低。它使应用容易测试，单元测试不再需要单例和JNDI查找机制。</p>
<p>最小的代价和最小的侵入性使松散耦合得以实现。IOC容器支持加载服务时的饿汉式初始化和懒加载。</p>
<h4 id="spring-AOP的原理"><a href="#spring-AOP的原理" class="headerlink" title="spring AOP的原理"></a>spring AOP的原理</h4><p><code>Spring AOP</code>的面向切面编程，是面向对象编程的一种补充，用于处理系统中分布的各个模块的横切关注点，比如说事务管理、日志、缓存等。</p>
<p>它是使用动态代理实现的，在内存中临时为方法生成一个<code>AOP</code>对象，这个对象包含目标对象的所有方法，在特定的切点做了增强处理，并回调原来的方法。</p>
<p><code>Spring AOP</code>的动态代理主要有两种方式实现，<code>JDK</code>动态代理和<code>cglib</code>动态代理。</p>
<p><code>JDK</code>动态代理通过反射来接收被代理的类，但是被代理的类必须实现接口，核心是<code>InvocationHandler</code>和<code>Proxy</code>类。</p>
<p><code>cglib</code>动态代理的类一般是没有实现接口的类，<code>cglib</code>是一个代码生成的类库，可以在运行时动态生成某个类的子类，所以，<code>CGLIB</code>是通过继承的方式做的动态代理，因此如果某个类被标记为<code>final</code>，那么它是无法使用<code>CGLIB</code>做动态代理的。</p>
<p>相关文章:</p>
<p><a href="https://blog.csdn.net/moreevan/article/details/11977115/" target="_blank" rel="noopener">Spring AOP 实现原理</a></p>
<p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-springaopcglib/index.html" target="_blank" rel="noopener">Spring AOP 实现原理与 CGLIB 应用</a></p>
<h4 id="AOP-核心概念"><a href="#AOP-核心概念" class="headerlink" title="AOP 核心概念"></a>AOP 核心概念</h4><p>1、切面（aspect）：类是对物体特征的抽象，切面就是对横切关注点的抽象<br>2、横切关注点：对哪些方法进行拦截，拦截后怎么处理，这些关注点称之为横切关注点。 3、连接点（joinpoint）：被拦截到的点，因为 Spring 只支持方法类型的连接点，所以在 Spring<br>中连接点指的就是被拦截到的方法，实际上连接点还可以是字段或者构造器。 4、切入点（pointcut）：对连接点进行拦截的定义<br>5、通知（advice）：所谓通知指的就是指拦截到连接点之后要执行的代码，通知分为前置、后置、<br>异常、最终、环绕通知五类。 6、目标对象：代理的目标对象<br>7、织入（weave）：将切面应用到目标对象并导致代理对象创建的过程<br>8、引入（introduction）：在不修改代码的前提下，引入可以在运行期为类动态地添加一些方法<br>或字段。</p>
<h4 id="在SpringAOP中，关注点和横切关注的区别是什么？"><a href="#在SpringAOP中，关注点和横切关注的区别是什么？" class="headerlink" title="在SpringAOP中，关注点和横切关注的区别是什么？"></a>在SpringAOP中，关注点和横切关注的区别是什么？</h4><p>关注点是应用中一个模块的行为，一个关注点可能会被定义成一个我们想实现的一个功能。<br>横切关注点是一个关注点，此关注点是整个应用都会使用的功能，并影响整个应用，比如日志，安全和数据传输，几乎应用的每个模块都需要的功能。因此这些都属于横切关注点。</p>
<h4 id="你怎样定义类的作用域"><a href="#你怎样定义类的作用域" class="headerlink" title="你怎样定义类的作用域?"></a>你怎样定义类的作用域?</h4><p>当定义一个 在Spring里，我们还能给这个bean声明一个作用域。它可以通过bean 定义中的scope属性来定义。如，当Spring要在需要的时候每次生产一个新的bean实例，bean的scope属性被指定为prototype。</p>
<p>另一方面，一个bean每次使用的时候必须返回同一个实例，这个bean的scope 属性 必须设为 singleton。</p>
<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="什么是-JVM-？"><a href="#什么是-JVM-？" class="headerlink" title="什么是 JVM ？"></a>什么是 JVM ？</h3><p>JVM，即 Java Virtual Machine，Java 虚拟机。它通过模拟一个计算机来达到一个计算机所具有的的计算功能。JVM 能够跨计算机体系结构来执行 Java 字节码，主要是由于 JVM 屏蔽了与各个计算机平台相关的软件或者硬件之间的差异，使得与平台相关的耦合统一由 JVM 提供者来实现。</p>
<h3 id="JVM-由哪些部分组成？"><a href="#JVM-由哪些部分组成？" class="headerlink" title="JVM 由哪些部分组成？"></a>JVM 由哪些部分组成？</h3><p>*<em>类加载器 *</em> : 在 JVM 启动时或者类运行时将需要的 class 加载到 JVM 中</p>
<p><strong>执行引擎</strong> : 执行引擎的任务是负责执行 class 文件中包含的字节码指令，相当于实际机器上的 CPU</p>
<p><strong>内存区</strong> : 将内存划分成若干个区以模拟实际机器上的存储、记录和调度功能模块，如实际机器上的各种功能的寄存器或者 PC 指针的记录器等</p>
<p><strong>本地方法调用</strong> : 调用 C 或 C++ 实现的本地方法的代码返回结果</p>
<h3 id="类加载器是有了解吗？"><a href="#类加载器是有了解吗？" class="headerlink" title="类加载器是有了解吗？"></a>类加载器是有了解吗？</h3><p>类加载器（class loader）用来加载 Java 类到 Java 虚拟机中。</p>
<p>一般来说，Java 虚拟机使用 Java 类的方式如下：</p>
<p>Java 源程序（.java 文件）在经过 Java 编译器编译之后就被转换成 Java 字节代码（.class 文件）。</p>
<p>类加载器负责读取 Java 字节代码，并转换成 java.lang.Class类的一个实例。每个这样的实例用来表示一个 Java 类。通过此实例的 newInstance()方法就可以创建出该类的一个对象。实际的情况可能更加复杂，比如 Java 字节代码可能是通过工具动态生成的，也可能是通过网络下载的。</p>
<h3 id="Java-虚拟机是如何判定两个-Java-类是相同的？"><a href="#Java-虚拟机是如何判定两个-Java-类是相同的？" class="headerlink" title="Java 虚拟机是如何判定两个 Java 类是相同的？"></a>Java 虚拟机是如何判定两个 Java 类是相同的？</h3><p>Java 虚拟机不仅要看类的全名是否相同，还要看加载此类的类加载器是否一样。</p>
<p>只有两者都相同的情况，才认为两个类是相同的。即便是同样的字节代码，被不同的类加载器加载之后所得到的类，也是不同的。</p>
<p>比如一个 Java 类 com.example.Sample，编译之后生成了字节代码文件 Sample.class。</p>
<p>两个不同的类加载器 ClassLoaderA和 ClassLoaderB分别读取了这个 Sample.class文件，并定义出两个 java.lang.Class类的实例来表示这个类。</p>
<p>这两个实例是不相同的。对于 Java 虚拟机来说，它们是不同的类。试图对这两个类的对象进行相互赋值，会抛出运行时异常 ClassCastException。</p>
<h3 id="Java-是如何实现跨平台的？"><a href="#Java-是如何实现跨平台的？" class="headerlink" title="Java 是如何实现跨平台的？"></a>Java 是如何实现跨平台的？</h3><p>我们编写的 Java 源码，编译后会生成一种 .class 文件，称为字节码文件。Java 虚拟机（JVM）就是负责将字节码文件翻译成特定平台下的机器码然后运行，也就是说，只要在不同平台上安装对应的 JVM，就可以运行字节码文件，运行我们编写的 Java 程序。</p>
<p>而这个过程，我们编写的 Java 程序没有做任何改变，仅仅是通过 JVM 这一 “中间层” ，就能在不同平台上运行，真正实现了 “一次编译，到处运行” 的目的。</p>
<p><strong>注意</strong>：跨平台的是 Java 程序，而不是 JVM。JVM 是用 C/C++ 开发的，是编译后的机器码，不能跨平台，不同平台下需要安装不同版本的 JVM</p>
<h3 id="说说Java虚拟机的生命周期及体系结构。"><a href="#说说Java虚拟机的生命周期及体系结构。" class="headerlink" title="说说Java虚拟机的生命周期及体系结构。"></a>说说Java虚拟机的生命周期及体系结构。</h3><blockquote>
<p>相关文章 <a href="https://www.iteye.com/blog/maozj-697376" target="_blank" rel="noopener">Java虚拟机生命周期和体系结构</a></p>
</blockquote>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="synchronized-关键字？"><a href="#synchronized-关键字？" class="headerlink" title="synchronized 关键字？"></a>synchronized 关键字？</h3><p>进入时，执行 monitorenter，将计数器 +1，释放锁 monitorexit 时，计数器-1；<br>当一个线程判断到计数器为 0 时，则当前锁空闲，可以占用；反之，当前线程进入等待状态。<br>含义：（monitor 机制）<br>Synchronized 是在加锁，加对象锁。</p>
<p>对象锁是一种重量锁（monitor），synchronized 的锁机制会根据线程竞争情况在运行时会有偏向锁（单一线程）、轻量锁（多个线程访问 synchronized 区域）、对象锁（重量锁，多个线程存在竞争的情况）、自旋锁等。<br>该关键字是一个几种锁的封装。</p>
<h3 id="volatile-关键字？"><a href="#volatile-关键字？" class="headerlink" title="volatile 关键字？"></a>volatile 关键字？</h3><p>该关键字可以保证可见性不保证原子性。</p>
<p>功能：<br>主内存和工作内存，直接与主内存产生交互，进行读写操作，保证可见性；禁止 JVM 进行的指令重排序。<br>解析：</p>
<p>关于指令重排序的问题，可以查阅 DCL 双检锁失效相关资料。</p>
<h3 id="volatile-能使得一个非原子操作变成原子操作吗？"><a href="#volatile-能使得一个非原子操作变成原子操作吗？" class="headerlink" title="volatile 能使得一个非原子操作变成原子操作吗？"></a>volatile 能使得一个非原子操作变成原子操作吗？</h3><p>能。</p>
<p>一个典型的例子是在类中有一个 long 类型的成员变量。如果你知道该成员变量会被多个线程访问，如计数器、价格等，你最好是将其设置为 volatile。为什么？因为 Java 中读取 long 类型变量不是原子的，需要分成两步，如果一个线程正在修改该 long 变量的值，另一个线程可能只能看到该值的一半（前 32 位）。但是对一个 volatile 型的 long 或 double 变量的读写是原子。</p>
<h3 id="如果拿到synchronized的线程异常退出了，那么等待锁的线程是否会一直等待呢？"><a href="#如果拿到synchronized的线程异常退出了，那么等待锁的线程是否会一直等待呢？" class="headerlink" title="如果拿到synchronized的线程异常退出了，那么等待锁的线程是否会一直等待呢？"></a>如果拿到synchronized的线程异常退出了，那么等待锁的线程是否会一直等待呢？</h3><p>否定的，当<code>JVM</code>发现有锁的线程异常了之后会将它的锁自动释放，再由其它等待的线程拿到锁。</p>
<h3 id="了解可重入锁的含义，以及ReentrantLock-和synchronized的区别"><a href="#了解可重入锁的含义，以及ReentrantLock-和synchronized的区别" class="headerlink" title="了解可重入锁的含义，以及ReentrantLock 和synchronized的区别"></a>了解可重入锁的含义，以及ReentrantLock 和synchronized的区别</h3><p><code>Lock</code>是一个接口，不是Java语言内置的，<code>synchronized</code>是java语言内置的关键字。</p>
<p><code>Lock</code>与<code>synchronized</code>有一点非常大的不同，采用<code>synchronized</code>不需要用户区手动释放锁，当<code>synchronized</code>方法或者<code>synchronized</code>代码块执行完之后，系统会自动让线程释放对锁的占用；而<code>Lock</code>则必须要用户区手动释放锁，如果没有主动释放锁，就有可能导致出现死锁。</p>
<h3 id="atomicinteger和Volatile等线程安全操作的关键字的理解和使用"><a href="#atomicinteger和Volatile等线程安全操作的关键字的理解和使用" class="headerlink" title="atomicinteger和Volatile等线程安全操作的关键字的理解和使用"></a>atomicinteger和Volatile等线程安全操作的关键字的理解和使用</h3><p>多个线程访问一个共享变量时会发生线程安全问题。<br>AtomicInteger关键字能保证变量值得准确性，但不能保证它们能按顺序输出。但一般我们都只是获取它的值，而不是打印它的值。如果你既想保证数字的准确性又想保证能按顺序输出，你只能用Synchronized关键字了</p>
<p>volatile关键字它保证了变量在线程之间的可见性。让程序不要去缓存中取值，而是去主存中取值。被volatile修饰的变量，在多个线程下是可见的，其作用是让该变量在多哥线程下是透明的（让程序从内存中加载，不允许在缓存中加载）。可以保证变量的修改让所有线程可见;</p>
<p>可重入锁<br>一个线程获取它本身的锁是可以成功的，多个线程同时抢占同一个锁会失败。因为他们之间是互斥的。但是一个线程再次获取一个自己已经拿过的锁是可以成功的，这叫可重入锁机制 。</p>
<h3 id="Java创建线程之后，直接调用start-方法和run-的区别"><a href="#Java创建线程之后，直接调用start-方法和run-的区别" class="headerlink" title="Java创建线程之后，直接调用start()方法和run()的区别"></a>Java创建线程之后，直接调用start()方法和run()的区别</h3><p><code>run()</code>方法:在本线程内调用该<code>Runnable</code>对象的<code>run()</code>方法，可以重复多次调用；</p>
<p><code>start()</code>方法:启动一个线程，调用该<code>Runnable</code>对象的<code>run()</code>方法，不能多次启动一个线程；</p>
<ul>
<li><p><code>start()</code>用来启动一个线程，当调用<code>start()</code>方法时，系统才会开启一个线程，通过<code>Thead</code>类中<code>start()</code>方法来启动的线程处于就绪状态（可运行状态），此时并没有运行，一旦得到<code>CPU</code>时间片，就自动开始执行<code>run()</code>方法。此时不需要等待<code>run()</code>方法执行完也可以继续执行下面的代码，所以也由此看出<code>run()</code>方法并没有实现多线程。 </p>
</li>
<li><p><code>run()</code>方法是在本线程里的，只是线程里的一个函数,而不是多线程的。如果直接调用<code>run()</code>,其实就相当于是调用了一个普通函数而已，直接待用<code>run()</code>方法必须等待<code>run()</code>方法执行完毕才能执行下面的代码，所以执行路径还是只有一条，根本就没有线程的特征，所以在多线程执行时要使用<code>start()</code>方法而不是<code>run()</code>方法。</p>
</li>
<li><p>把需要处理的代码放到<code>run()</code>方法中，<code>start()</code>方法启动线程将自动调用<code>run()</code>方法，这个由java的内存机制规定的。并且<code>run()</code>方法必需是<code>public</code>访问权限，返回值类型为<code>void</code>。</p>
</li>
<li><p>当程序调用<code>start()</code>方法一个新线程将会被创建，并且在<code>run()</code>方法中的代码将会在新线程上运行</p>
</li>
</ul>
<h3 id="sleep-和-wait-n-、wait-的区别？"><a href="#sleep-和-wait-n-、wait-的区别？" class="headerlink" title="sleep( ) 和 wait( n)、wait( ) 的区别？"></a>sleep( ) 和 wait( n)、wait( ) 的区别？</h3><p>sleep 方法： 是 Thread 类的静态方法，当前线程将睡眠 n 毫秒，线程进入阻塞状态。当睡眠时间到了，会解除阻塞，进行可运行状态，等待 CPU 的到来。睡眠不释放锁（如果有的话）；<br>wait 方法： 是 Object 的方法，必须与 synchronized 关键字一起使用，线程进入阻塞状态，当 notify 或者 notifyall 被调用后，会解除阻塞。但是，只有重新占用互斥锁之后才会进入可运行状态。睡眠时，释放互斥锁。</p>
<h3 id="我们为什么要使用线程池？核心线程池内部实现了解吗？"><a href="#我们为什么要使用线程池？核心线程池内部实现了解吗？" class="headerlink" title="我们为什么要使用线程池？核心线程池内部实现了解吗？"></a>我们为什么要使用线程池？核心线程池内部实现了解吗？</h3><p>减少创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。<br>可以根据系统的承受能力，调整线程池中工作线程的数目，放置因为消耗过多的内存，而把服务器累趴下（每个线程大约需要 1 MB 内存，线程开的越多，消耗的内存也就越大，最后死机）</p>
<h3 id="核心线程池内部实现了解吗？"><a href="#核心线程池内部实现了解吗？" class="headerlink" title="核心线程池内部实现了解吗？"></a>核心线程池内部实现了解吗？</h3><p>对于核心的几个线程池，无论是 newFixedThreadPool() 方法，newSingleThreadExecutor() 还是 newCachedThreadPool() 方法，虽然看起来创建的线程有着完全不同的功能特点，但其实内部实现均使用了 ThreadPoolExecutor 实现，其实都只是 ThreadPoolExecutor 类的封装。</p>
<h3 id="常用的线程池模式以及不同线程池的使用场景"><a href="#常用的线程池模式以及不同线程池的使用场景" class="headerlink" title="常用的线程池模式以及不同线程池的使用场景"></a>常用的线程池模式以及不同线程池的使用场景</h3><p><strong>newCachedThreadPool：</strong></p>
<p><strong>底层：</strong>返回ThreadPoolExecutor实例，corePoolSize为0；maximumPoolSize为Integer.MAX_VALUE；keepAliveTime为60L；unit为TimeUnit.SECONDS；workQueue为SynchronousQueue(同步队列)</p>
<p><strong>通俗：</strong>当有新任务到来，则插入到SynchronousQueue中，由于SynchronousQueue是同步队列，因此会在池中寻找可用线程来执行，若有可以线程则执行，若没有可用线程则创建一个线程来执行该任务；若池中线程空闲时间超过指定大小，则该线程会被销毁。</p>
<p><strong>适用：</strong>执行很多短期异步的小程序或者负载较轻的服务器</p>
<p><strong>newFixedThreadPool：</strong></p>
<p><strong>底层：</strong>返回ThreadPoolExecutor实例，接收参数为所设定线程数量nThread，corePoolSize为nThread，maximumPoolSize为nThread；keepAliveTime为0L(不限时)；unit为：TimeUnit.MILLISECONDS；WorkQueue为：new LinkedBlockingQueue<Runnable>() 无解阻塞队列</p>
<p><strong>通俗：</strong>创建可容纳固定数量线程的池子，每隔线程的存活时间是无限的，当池子满了就不在添加线程了；如果池中的所有线程均在繁忙状态，对于新任务会进入阻塞队列中(无界的阻塞队列)</p>
<p><strong>适用：</strong>执行长期的任务，性能好很多</p>
<p><strong>newSingleThreadExecutor:</strong></p>
<p><strong>底层：</strong>FinalizableDelegatedExecutorService包装的ThreadPoolExecutor实例，corePoolSize为1；maximumPoolSize为1；keepAliveTime为0L；unit为：TimeUnit.MILLISECONDS；workQueue为：new LinkedBlockingQueue<Runnable>() 无解阻塞队列</p>
<p><strong>通俗：</strong>创建只有一个线程的线程池，且线程的存活时间是无限的；当该线程正繁忙时，对于新任务会进入阻塞队列中(无界的阻塞队列)</p>
<p><strong>适用：</strong>一个任务一个任务执行的场景</p>
<p><strong>NewScheduledThreadPool:</strong></p>
<p><strong>底层：</strong>创建ScheduledThreadPoolExecutor实例，corePoolSize为传递来的参数，maximumPoolSize为Integer.MAX_VALUE；keepAliveTime为0；unit为：TimeUnit.NANOSECONDS；workQueue为：new DelayedWorkQueue() 一个按超时时间升序排序的队列</p>
<p><strong>通俗：</strong>创建一个固定大小的线程池，线程池内线程存活时间无限制，线程池可以支持定时及周期性任务执行，如果所有线程均处于繁忙状态，对于新任务会进入DelayedWorkQueue队列中，这是一种按照超时时间排序的队列结构</p>
<p><strong>适用：</strong>周期性执行任务的场景</p>
<p><strong>线程池任务执行流程：</strong></p>
<p>当线程池小于corePoolSize时，新提交任务将创建一个新线程执行任务，即使此时线程池中存在空闲线程。<br>当线程池达到corePoolSize时，新提交任务将被放入workQueue中，等待线程池中任务调度执行<br>当workQueue已满，且maximumPoolSize&gt;corePoolSize时，新提交任务会创建新线程执行任务<br>当提交任务数超过maximumPoolSize时，新提交任务由RejectedExecutionHandler处理<br>当线程池中超过corePoolSize线程，空闲时间达到keepAliveTime时，关闭空闲线程<br>当设置allowCoreThreadTimeOut(true)时，线程池中corePoolSize线程空闲时间达到keepAliveTime也将关闭</p>
<p><strong>备注：</strong></p>
<p>一般如果线程池任务队列采用LinkedBlockingQueue队列的话，那么不会拒绝任何任务（因为队列大小没有限制），这种情况下，ThreadPoolExecutor最多仅会按照最小线程数来创建线程，也就是说线程池大小被忽略了。</p>
<p>如果线程池任务队列采用ArrayBlockingQueue队列的话，那么ThreadPoolExecutor将会采取一个非常负责的算法，比如假定线程池的最小线程数为4，最大为8所用的ArrayBlockingQueue最大为10。随着任务到达并被放到队列中，线程池中最多运行4个线程（即最小线程数）。即使队列完全填满，也就是说有10个处于等待状态的任务，ThreadPoolExecutor也只会利用4个线程。如果队列已满，而又有新任务进来，此时才会启动一个新线程，这里不会因为队列已满而拒接该任务，相反会启动一个新线程。新线程会运行队列中的第一个任务，为新来的任务腾出空间。</p>
<p>这个算法背后的理念是：该池大部分时间仅使用核心线程（4个），即使有适量的任务在队列中等待运行。这时线程池就可以用作节流阀。如果挤压的请求变得非常多，这时该池就会尝试运行更多的线程来清理；这时第二个节流阀—最大线程数就起作用了。</p>
<h3 id="多线程之间通信的同步问题"><a href="#多线程之间通信的同步问题" class="headerlink" title="多线程之间通信的同步问题"></a>多线程之间通信的同步问题</h3><p>在 Windows 系统中线程之间的通信有两种方式</p>
<p>使用全局变量进行通信<br>使用自定义消息进行通信<br>使隶属于同一进程的线程协调一致的工作就是线程间的同步。<br>在多线程环境里，需要对线程进行同步。<br>常用的同步对象有临界区（Critical Section）、互斥（Mutex）、信号量（Semaphore）和事件（event）等。<br>用于解决线程访问顺序引发的问题。<br>需要同步的情况可以从以下两方面考虑：<br>同时访问同一内存空间时发生的情况。<br>需要指定访问同一内存空间的线程执行顺序的情况。</p>
<p>相关文章:</p>
<p><a href="https://www.cnblogs.com/JNovice/p/9425361.html" target="_blank" rel="noopener">关于Java多线程的线程同步和线程通信的一些小问题（顺便分享几篇高质量的博文）</a></p>
<p><a href="https://blog.csdn.net/qq_41291253/article/details/92065354" target="_blank" rel="noopener">多线程间的通信和同步</a></p>
<h3 id="定时线程的使用"><a href="#定时线程的使用" class="headerlink" title="定时线程的使用"></a>定时线程的使用</h3><p>方法<code>schedule(TimerTask task,Date time)</code></p>
<p>在指定的日期执行一次某一任务。</p>
<p>方法<code>schedule(TimerTask task,Date firstTime,long period)</code></p>
<p>在指定的日期之后，按指定的间隔周期性地无限循环的执行某一任务。</p>
<p>方法<code>schedule(TimerTask task,long delay)</code></p>
<p>作用：以执行schedule(TimerTask task,long delay)方法当前的时间为参考时间，在此时间基础上延迟指定的毫秒数后执行一次TimerTask任务。</p>
<p>方法<code>schedule(TimerTask task,long delay,long period)</code></p>
<p>作用：以执行schedule(TimerTask task,long delay,long period)方法当前的时间为参考时间，在此时间基础上延迟指定的毫秒数，再以某一时间间隔无限次数执行某一任务。</p>
<p><a href="https://blog.csdn.net/xiao714041/article/details/73727417" target="_blank" rel="noopener">https://blog.csdn.net/xiao714041/article/details/73727417</a></p>
<h3 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h3><p><strong>根本区别：</strong></p>
<p>进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位在开销方面：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；<br>线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。</p>
<p><strong>所处环境：</strong></p>
<p>在操作系统中能同时运行多个进程（程序）；<br>而在同一个进程（程序）中有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行）</p>
<p><strong>内存分配方面：</strong></p>
<p>系统在运行的时候会为每个进程分配不同的内存空间；<br>而对线程而言，除了CPU外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），线程组之间只能共享资源。</p>
<p><strong>包含关系：</strong></p>
<p>没有线程的进程可以看做是单线程的，如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；<br>线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。</p>
<h3 id="什么叫线程安全"><a href="#什么叫线程安全" class="headerlink" title="什么叫线程安全"></a>什么叫线程安全</h3><p>死锁和脏数据就是典型的线程安全问题。</p>
<p>简单来说，线程安全就是： 在多线程环境中，能永远保证程序的正确性</p>
<p>只有存在共享数据时才需要考虑线程安全问题</p>
<p>线程安全的代码是多个线程同时执行也能工作的代码<br>如果一段代码可以保证多个线程访问的时候正确操作共享数据，那么它是线程安全的<br>当一个类被多个线程进行访问并且正确运行，它就是线程安全的</p>
<p>当多个线程访问某各类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步或者协同，这个类都能表现出正确的行为，那么就称这个类是线程安全的。</p>
<p>线程安全的级别或者粒度有三种，如下：</p>
<p><strong>线程安全</strong></p>
<p>这种情况下其实没有线程安全问题，比如上面的例子中，每个人都有自己专用的卫生间，所以不会存在竞争问题。</p>
<p><strong>条件安全</strong></p>
<p>条件安全，顾名思义是有条件的，所有人共用几个卫生间，抢到资源的就把门关上，通过门来隔离资源，后面的人就在外面等待直到里面的人出来。</p>
<p><strong>不安全</strong></p>
<p>这种情况下连门都没有，所以并不能很好保证资源安全，所以这种情况***不能让同时让多个人直接使用。</p>
<p>实现线程安全的方式</p>
<p>方式一：</p>
<p>不共享状态：</p>
<ul>
<li><p>无状态对象： 无状态对象一定是线程安全的，因为不会影响到其他线程</p>
</li>
<li><p>线程关闭： 仅在单线程环境下使用</p>
</li>
</ul>
<p>核心思路是避免共享数据结构，共享状态。包括：</p>
<ul>
<li><p>使用线程local变量</p>
</li>
<li><p>使用不可变对象</p>
</li>
</ul>
<p>方式二：</p>
<p>核心思路是共享不可避免，需要通过条件来确保按照。包括：</p>
<p><strong>互斥锁</strong></p>
<p>加锁：</p>
<ul>
<li><p>锁能使其保护的代码以串行的形式来访问，当给一个复合操作加锁后，能使其成为原子操作。一种错误的思想是只要对写数据的方法加锁，其实这是错的，对数据进行操作的所有方法都需加锁，不管是读还是写</p>
</li>
<li><p>加锁时需要考虑性能问题，不能总是一味地给整个方法加锁synchronized2就了事了，应该将方法中不影响共享状态且执行时间比较长的代码分离出去</p>
</li>
<li><p>加锁的含义不仅仅局限于互斥，还包括可见性。为了确保所有线程都能看见最新值，读操作和写操作必须使用同样的锁对象</p>
</li>
</ul>
<p><strong>CAS原子操作</strong></p>
<p>不可变对象：</p>
<p>可以使用final修饰的对象保证线程安全，由于final修饰的引用型变量(除String外)不可变是指引用不可变，但其指向的对象是可变的，所以此类必须安全发布，也即不能对外提供可以修改final对象的接口</p>
<h3 id="线程的几种状态"><a href="#线程的几种状态" class="headerlink" title="线程的几种状态"></a>线程的几种状态</h3><p><strong>新建(NEW)：</strong>新创建了一个线程对象。</p>
<p><strong>可运行(RUNNABLE)：</strong>线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取cpu 的使用权 。</p>
<p><strong>运行(RUNNING)：</strong>可运行状态(runnable)的线程获得了cpu 时间片（timeslice） ，执行程序代码。</p>
<p><strong>阻塞(BLOCKED)：</strong>阻塞状态是指线程因为某种原因放弃了cpu 使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有机会再次获得cpu timeslice 转到运行(running)状态。阻塞的情况分三种： </p>
<ul>
<li>等待阻塞：运行(running)的线程执行o.wait()方法，JVM会把该线程放入等待队列(waitting queue)中。</li>
<li>同步阻塞：运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。</li>
<li>其他阻塞：运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。</li>
</ul>
<p><strong>死亡(DEAD)：</strong>线程run()、main() 方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。</p>
<p>相关文章:<a href="https://blog.csdn.net/xingjing1226/article/details/81977129" target="_blank" rel="noopener">线程的5种状态详解</a></p>
<h3 id="HashMap-是否线程安全"><a href="#HashMap-是否线程安全" class="headerlink" title="HashMap 是否线程安全"></a>HashMap 是否线程安全</h3><p>不是线程安全<br>当多个线程同时检测到总数量超过门限值的时候就会同时调用resize操作，各自生成新的数组并rehash后赋给该map底层的数组table，结果最终只有最后一个线程生成的新数组被赋给table变量，其他线程的均会丢失。而且当某些线程已经完成赋值而其他线程刚开始的时候，就会用已经被赋值的table作为原始数组，这样也会有问题。</p>
<p>相关文章:<a href="https://blog.csdn.net/mydreamongo/article/details/8960667" target="_blank" rel="noopener">HashMap为什么是线程不安全的？</a></p>
<h2 id="Java-IO"><a href="#Java-IO" class="headerlink" title="Java IO"></a>Java IO</h2><h3 id="操作的数据是否是纯文本数据？"><a href="#操作的数据是否是纯文本数据？" class="headerlink" title="操作的数据是否是纯文本数据？"></a>操作的数据是否是纯文本数据？</h3><p><strong>如果是：</strong></p>
<ul>
<li><p>数据source：Reader</p>
</li>
<li><p>数据destination：Writer </p>
</li>
</ul>
<p><strong>如果不是：</strong></p>
<ul>
<li><p>数据source：InputStream</p>
</li>
<li><p>数据destination：OutputStream123456</p>
</li>
</ul>
<h3 id="Java-IO体系中有太多的对象，到底用哪个呢？"><a href="#Java-IO体系中有太多的对象，到底用哪个呢？" class="headerlink" title="Java IO体系中有太多的对象，到底用哪个呢？"></a>Java IO体系中有太多的对象，到底用哪个呢？</h3><p>   明确操作的数据设备。<br>   数据source对应的设备：硬盘(File)，内存(数组)，键盘(System.in)<br>   数据destination对应的设备：硬盘(File)，内存(数组)，控制台(System.out)。</p>
<h3 id="java中有几种类型的流？"><a href="#java中有几种类型的流？" class="headerlink" title="java中有几种类型的流？"></a>java中有几种类型的流？</h3><p>字符流和字节流。</p>
<p>字节流继承inputStream和OutputStream</p>
<p>字符流继承自InputSteamReader和OutputStreamWriter。</p>
<h3 id="字符流和字节流有什么区别？"><a href="#字符流和字节流有什么区别？" class="headerlink" title="字符流和字节流有什么区别？"></a>字符流和字节流有什么区别？</h3><p>要把一片二进制数据数据逐一输出到某个设备中，或者从某个设备中逐一读取一片二进制数据，不管输入输出设备是什么，我们要用统一的方式来完成这些操作，用一种抽象的方式进行描述，这个抽象描述方式起名为IO流，不同的实现类就代表不同的输入和输出设备，它们都是针对字节进行操作的。</p>
<p>*<em>应用中，经常要完全是字符的一段文本输出去或读进来，用字节流可以吗？ *</em></p>
<p>计算机中的一切最终都是二进制的字节形式存在。对于“中国”这些字符，首先要得到其对应的字节，然后将字节写入到输出流。读取时，首先读到的是字节，可是我们要把它显示为字符，我们需要将字节转换成字符。由于这样的需求很广泛，人家专门提供了字符流的包装类。</p>
<p>底层设备永远只接受字节数据，有时候要写字符串到底层设备，需要将字符串转成字节再进行写入。字符流是字节流的包装，字符流则是直接接受字符串，它内部将串转成字节，再写入底层设备，这为我们向IO设别写入或读取字符串提供了一点点方便。</p>
<h3 id="IO里面的常见类，字节流、字符流、接口、实现类、方法阻塞"><a href="#IO里面的常见类，字节流、字符流、接口、实现类、方法阻塞" class="headerlink" title="IO里面的常见类，字节流、字符流、接口、实现类、方法阻塞"></a>IO里面的常见类，字节流、字符流、接口、实现类、方法阻塞</h3><p>输入流就是从外部文件输入到内存，输出流主要是从内存输出到文件。 </p>
<p><code>IO</code>里面常见的类，第一印象就只知道<code>IO</code>流中有很多类，<code>IO</code>流主要分为字符流和字节流。</p>
<p>字符流中有抽象类<code>InputStream</code>和<code>OutputStream</code>，它们的子类<code>FileInputStream</code>，<code>FileOutputStream</code>,<code>BufferedOutputStream</code>等。字符流<code>BufferedReader</code>和<code>Writer</code>等。都实现了<code>Closeable</code>, <code>Flushable</code>,<code>Appendable</code>这些接口。</p>
<p>程序中的输入输出都是以流的形式保存的，流中保存的实际上全都是字节文件。<br>java中的阻塞式方法是指在程序调用改方法时，必须等待输入数据可用或者检测到输入结束或者抛出异常，否则程序会一直停留在该语句上，不会执行下面的语句。比如<code>read()</code>和<code>readLine()</code>方法。</p>
<h3 id="String-编码UTF-8-和GBK的区别"><a href="#String-编码UTF-8-和GBK的区别" class="headerlink" title="String 编码UTF-8 和GBK的区别"></a>String 编码UTF-8 和GBK的区别</h3><p><code>GBK</code>字符均使用双字节来表示，只不过为区分中文，将其最高位都定成1。</p>
<p><code>UTF－8</code>编码则是用以解决国际上字符的一种多字节编码，它对英文使用8位（即一个字节），中文使用24位（三个字节）来编码。对于英文字符较多的论坛则用UTF－8节省空间。</p>
<p><code>GBK</code>包含全部中文字符；</p>
<p><code>UTF-8</code>则包含全世界所有国家需要用到的字符。</p>
<p><code>GBK</code>是在国家标准<code>GB2312</code>基础上扩容后兼容<code>GB2312</code>的标准；（好像还不是国家标准）</p>
<p><code>UTF-8</code>编码的文字可以在各国各种支持<code>UTF8</code>字符集的浏览器上显示。</p>
<p>总结：</p>
<p><code>GBK</code>就是在保存你的帖子的时候，一个汉字占用两个字节。外国人看会出现乱码，此为我中华为自己汉字编码而形成之解决方案。</p>
<p><code>UTF8</code>就是在保存你的帖子的时候，一个汉字占用3个字节。但是外国人看的话不会乱码，此为西人为了解决多字节字符而形成之解决方案。</p>
<pre><code>   GBK编码方式的编码是以中国国情而创造的，在国际上的兼容性不好，这也是为什么大多数的网页是使用UTF-8编码而不是GBK。</code></pre><h3 id="session和cookie的区别和联系"><a href="#session和cookie的区别和联系" class="headerlink" title="session和cookie的区别和联系"></a>session和cookie的区别和联系</h3><p>1、Cookie定义</p>
<pre><code>   Cookie是服务器在本地机器上存储的小段文本并随每一个请求发送至同一服务器。Cookies保存在客户端，主要内容包括：名字，值，过期时间，路径等等。  </code></pre><p>2、会话cookie和持久cookie的区别</p>
<p>会话cookie：不设置过期时间，只要关闭浏览器窗口cookie就消失了。会话cookie不保存在硬盘上，保存在内存里。</p>
<p>持久cookie：设置过期时间，浏览器就会把cookie保存到硬盘上，关闭后再次打开浏览器，这些cookie依然有效直到超过设定的过期时间。存储在硬盘上的cookie可以在不同的浏览器进程间共享。而对于保存在内存的cookie，不同的浏览器有不同的处理方式。</p>
<pre><code>   利用持久Cookie自动登录：当用户在某个网站注册后，就会收到一个惟一用户ID的cookie。客户后来重新连接时，这个用户ID会自动返回，服务器对它进行检查，确定它是否为注册用户且选择了自动登录，从而使用户无需给出明确的用户名和密码，就可以访问服务器上的资源。</code></pre><p>3、Session定义</p>
<pre><code>  Session是在服务器端保存用户数据。浏览器第一次发送请求时，服务器自动生成了Session ID来唯一标识这个并将其通过响应发送到浏览器。浏览器第二次发送请求会将前一次服务器响应中的Session ID放在请求中一并发送到服务器上，服务器从请求中提取出Session ID，并和保存的所有Session ID进行对比，找到这个用户的信息。一般这个Session ID会有个时间限制，默认30分钟超时后毁掉这次Session ID。</code></pre><p>  Session和Cookie有一定关系，Session id存在Cookie中，每次访问的时候将Session id传到服务器进行对比。</p>
<p>4、Cookie和Session的区别</p>
<p>Cookie 在客户端（浏览器、易伪造、不安全），Session 在服务器端（会消耗服务器资源）。</p>
<p>Cookie 只能保存ASCII字符串，如果是Unicode字符或者二进制数据需要先进行编码。</p>
<p>Cookie中也不能直接存取Java对象。</p>
<p> Session能够存取很多类型的数据，包括String、Integer、List、Map等，Session中也可以保存JJava对象。</p>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="什么是里氏替换原则？"><a href="#什么是里氏替换原则？" class="headerlink" title="什么是里氏替换原则？"></a>什么是里氏替换原则？</h3><p>1、开闭原则（Open Close Principle）</p>
<p>开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。</p>
<p>2、里氏代换原则（Liskov Substitution Principle）</p>
<p>里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。—— From Baidu 百科</p>
<p>3、依赖倒转原则（Dependence Inversion Principle）</p>
<p>这个是开闭原则的基础，具体内容：真对接口编程，依赖于抽象而不依赖于具体。</p>
<p>4、接口隔离原则（Interface Segregation Principle）</p>
<p>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。</p>
<p>5、迪米特法则（最少知道原则）（Demeter Principle）</p>
<p>为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。</p>
<p>6、合成复用原则（Composite Reuse Principle）</p>
<p>原则是尽量使用合成/聚合的方式，而不是使用继承</p>
<h3 id="适配器模式是什么？什么时候使用？"><a href="#适配器模式是什么？什么时候使用？" class="headerlink" title="适配器模式是什么？什么时候使用？"></a>适配器模式是什么？什么时候使用？</h3><p>适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。适配器模式提供对接口的转换。如果你的客户端使用某些接口，但是你有另外一些接口，你就可以写一个适配去来连接这些接口。</p>
<h3 id="什么时候使用访问者模式？"><a href="#什么时候使用访问者模式？" class="headerlink" title="什么时候使用访问者模式？"></a>什么时候使用访问者模式？</h3><p>访问者模式用于解决在类的继承层次上增加操作，但是不直接与之关联。这种模式采用双派发的形式来增加中间层。</p>
<h3 id="适配器模式与装饰器模式有什么区别？"><a href="#适配器模式与装饰器模式有什么区别？" class="headerlink" title="适配器模式与装饰器模式有什么区别？"></a>适配器模式与装饰器模式有什么区别？</h3><p>适配器模式被用于桥接两个接口，而装饰模式的目的是在不修改类的情况下给类增加新的功能。</p>
<p>装饰者模式：动态地将责任附加到对象上，若要扩展功能，装饰者模提供了比继承更有弹性的替代方案。</p>
<p>通俗的解释：装饰模式就是给一个对象增加一些新的功能，而且是动态的，要求装饰对象和被装饰对象实现同一个接口，装饰对象持有被装饰对象的实例。</p>
<p>适配器模式：将一个类的接口，转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间。</p>
<p>适配器模式有三种：类的适配器模式、对象的适配器模式、接口的适配器模式。</p>
<p>通俗的说法：适配器模式将某个类的接口转换成客户端期望的另一个接口表示，目的是消除由于接口不匹配所造成的类的兼容性问题。</p>
<h3 id="继承和组合之间有什么不同？"><a href="#继承和组合之间有什么不同？" class="headerlink" title="继承和组合之间有什么不同？"></a>继承和组合之间有什么不同？</h3><p>虽然两种都可以实现代码复用，但是组合比继承共灵活，因为组合允许你在运行时选择不同的实现。用组合实现的代码也比继承测试起来更加简单。</p>
<h3 id="讲一下模版模式和策略模式的区别？"><a href="#讲一下模版模式和策略模式的区别？" class="headerlink" title="讲一下模版模式和策略模式的区别？"></a>讲一下模版模式和策略模式的区别？</h3><p>模板方法模式的主要思想：定义一个算法流程，将一些特定步骤的具体实现、延迟到子类。使得可以在不改变算法流程的情况下，通过不同的子类、来实现“定制”流程中的特定的步骤。</p>
<p>策略模式的主要思想：使不同的算法可以被相互替换，而不影响客户端的使用。</p>
<h3 id="工厂模式与抽象工厂模式的区别？"><a href="#工厂模式与抽象工厂模式的区别？" class="headerlink" title="工厂模式与抽象工厂模式的区别？"></a>工厂模式与抽象工厂模式的区别？</h3><p>首先来看看这两者的定义区别：</p>
<p>工厂模式：定义一个用于创建对象的借口，让子类决定实例化哪一个类</p>
<p>抽象工厂模式：为创建一组相关或相互依赖的对象提供一个接口，而且无需指定他们的具体类</p>
<p>这个区别在于产品，如果产品单一，最合适用工厂模式，但是如果有多个业务品种、业务分类时，通过抽象工厂模式产生需要的对象是一种非常好的解决方式。再通俗深化理解下：工厂模式针对的是一个产品等级结构 ，抽象工厂模式针对的是面向多个产品等级结构的。</p>
<h3 id="什么时候使用享元模式？"><a href="#什么时候使用享元模式？" class="headerlink" title="什么时候使用享元模式？"></a>什么时候使用享元模式？</h3><p>享元模式通过共享对象来避免创建太多的对象。为了使用享元模式，你需要确保你的对象是不可变的，这样你才能安全的共享。JDK 中 String 池、Integer 池以及 Long 池都是很好的使用了享元模式的例子。</p>
<h3 id="你可以说出几个在JDK库中使用的设计模式吗？"><a href="#你可以说出几个在JDK库中使用的设计模式吗？" class="headerlink" title="你可以说出几个在JDK库中使用的设计模式吗？"></a>你可以说出几个在JDK库中使用的设计模式吗？</h3><p>装饰器设计模式（Decorator design pattern）被用于多个Java IO类中。单例模式（Singleton pattern）用于Runtime，Calendar和其他的一些类中。工厂模式（Factory pattern）被用于各种不可变的类如Boolean，像Boolean.valueOf，观察者模式（Observer pattern）被用于Swing和很多的事件监听中。</p>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h3 id="使用redis优缺点？"><a href="#使用redis优缺点？" class="headerlink" title="使用redis优缺点？"></a>使用redis优缺点？</h3><p>优点</p>
<ul>
<li>速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)</li>
<li>支持丰富数据类型，支持string，list，set，sorted set，hash</li>
<li>支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行</li>
<li>丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除</li>
<li>支持主从复制，主机会自动将数据同步到从机，可以进行读写分离。</li>
</ul>
<p>缺点</p>
<ul>
<li>数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。</li>
<li>Redis 不具备自动容错和恢复功能，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或者手动切换前端的IP才能恢复。</li>
<li>主机宕机，宕机前有部分数据未能及时同步到从机，切换IP后还会引入数据不一致的问题，降低了系统的可用性。</li>
<li>Redis 较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。为避免这一问题，运维人员在系统上线时必须确保有足够的空间，这对资源造成了很大的浪费。</li>
</ul>
<h3 id="Redis支持的数据类型？"><a href="#Redis支持的数据类型？" class="headerlink" title="Redis支持的数据类型？"></a>Redis支持的数据类型？</h3><ul>
<li><p>String字符串 </p>
</li>
<li><p>Hash（哈希）</p>
</li>
<li><p>List（列表）</p>
</li>
<li><p>Set（集合）</p>
</li>
<li><p>zset(sorted set：有序集合)</p>
</li>
</ul>
<h3 id="什么是Redis持久化？Redis有哪几种持久化方式？优缺点是什么？"><a href="#什么是Redis持久化？Redis有哪几种持久化方式？优缺点是什么？" class="headerlink" title="什么是Redis持久化？Redis有哪几种持久化方式？优缺点是什么？"></a>什么是Redis持久化？Redis有哪几种持久化方式？优缺点是什么？</h3><p>持久化就是把内存的数据写到磁盘中去，防止服务宕机了内存数据丢失。</p>
<p>Redis 提供了两种持久化方式:<code>RDB</code>(默认)和<code>AOF</code> </p>
<p><strong>RDB：</strong>  rdb是Redis DataBase缩写</p>
<p>功能核心函数rdbSave(生成RDB文件)和rdbLoad（从文件加载内存）两个函数</p>
<p><strong>AOF:</strong>   Aof是Append-only file缩写</p>
<p>每当执行服务器(定时)任务或者函数时flushAppendOnlyFile 函数都会被调用， 这个函数执行以下两个工作aof写入保存：</p>
<ul>
<li><p><strong>WRITE</strong>：根据条件，将 aof_buf 中的缓存写入到 AOF 文件</p>
</li>
<li><p><strong>SAVE</strong>：根据条件，调用 fsync 或 fdatasync 函数，将 AOF 文件保存到磁盘中。</p>
</li>
</ul>
<p><strong>存储结构:</strong></p>
<p> 内容是redis通讯协议(RESP )格式的命令文本存储。</p>
<p><strong>比较</strong>：</p>
<p>1、aof文件比rdb更新频率高，优先使用aof还原数据。</p>
<p>2、aof比rdb更安全也更大</p>
<p>3、rdb性能比aof好</p>
<p>4、如果两个都配了优先加载AOF</p>
<h3 id="Redis的内存淘汰策略有哪些？"><a href="#Redis的内存淘汰策略有哪些？" class="headerlink" title="Redis的内存淘汰策略有哪些？"></a>Redis的内存淘汰策略有哪些？</h3><p>Redis的内存淘汰策略是指在Redis的用于缓存的内存不足时，怎么处理需要新写入且需要申请额外空间的数据。</p>
<p><strong>全局的键空间选择性移除</strong></p>
<p>noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。<br>allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。（这个是最常用的）<br>allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。</p>
<p><strong>设置过期时间的键空间选择性移除</strong></p>
<p>volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。<br>volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。<br>volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。</p>
<p><strong>总结</strong></p>
<p>Redis的内存淘汰策略的选取并不会影响过期的key的处理。内存淘汰策略用于处理内存不足时的需要申请额外空间的数据；过期策略用于处理过期的缓存数据。</p>
<h3 id="Redis-有哪些架构模式？"><a href="#Redis-有哪些架构模式？" class="headerlink" title="Redis 有哪些架构模式？"></a>Redis 有哪些架构模式？</h3><p> <strong>单机版</strong></p>
<p>特点：简单</p>
<p>问题：</p>
<p>1、内存容量有限 2、处理能力有限 3、无法高可用。</p>
<p><strong>主从复制</strong></p>
<p>Redis 的复制（replication）功能允许用户根据一个 Redis 服务器来创建任意多个该服务器的复制品，其中被复制的服务器为主服务器（master），而通过复制创建出来的服务器复制品则为从服务器（slave）。 只要主从服务器之间的网络连接正常，主从服务器两者会具有相同的数据，主服务器就会一直将发生在自己身上的数据更新同步 给从服务器，从而一直保证主从服务器的数据相同。</p>
<p>特点：</p>
<p>1、master/slave 角色</p>
<p>2、master/slave 数据相同</p>
<p>3、降低 master 读压力在转交从库</p>
<p>问题：</p>
<p>无法保证高可用</p>
<p>没有解决 master 写的压力</p>
<p><strong>哨兵</strong></p>
<p>Redis sentinel 是一个分布式系统中监控 redis 主从服务器，并在主服务器下线时自动进行故障转移。其中三个特性：</p>
<ul>
<li><p><strong>监控（Monitoring</strong>）：  Sentinel 会不断地检查你的主服务器和从服务器是否运作正常。</p>
</li>
<li><p><strong>提醒（Notification）</strong>： 当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。</p>
</li>
<li><p><strong>自动故障迁移（Automatic failover）</strong>： 当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作。</p>
</li>
</ul>
<p>特点：</p>
<p>1、保证高可用</p>
<p>2、监控各个节点</p>
<p>3、自动故障迁移</p>
<p>缺点：主从模式，切换需要时间丢数据</p>
<p>没有解决 master 写的压力</p>
<p><strong>集群（proxy 型）</strong></p>
<p>Twemproxy 是一个 Twitter 开源的一个 redis 和 memcache 快速/轻量级代理服务器； Twemproxy 是一个快速的单线程代理程序，支持 Memcached ASCII 协议和 redis 协议。</p>
<p>特点：1、多种 hash 算法：MD5、CRC16、CRC32、CRC32a、hsieh、murmur、Jenkins </p>
<p>2、支持失败节点自动删除</p>
<p>3、后端 Sharding 分片逻辑对业务透明，业务方的读写方式和操作单个 Redis 一致</p>
<p>缺点：增加了新的 proxy，需要维护其高可用。</p>
<p><strong>集群（直连型）</strong></p>
<p>从redis 3.0之后版本支持redis-cluster集群，Redis-Cluster采用无中心结构，每个节点保存数据和整个集群状态,每个节点都和其他所有节点连接。</p>
<p>特点：</p>
<p>1、无中心架构（不存在哪个节点影响性能瓶颈），少了 proxy 层。</p>
<p>2、数据按照 slot 存储分布在多个节点，节点间数据共享，可动态调整数据分布。</p>
<p>3、可扩展性，可线性扩展到 1000 个节点，节点可动态添加或删除。</p>
<p>4、高可用性，部分节点不可用时，集群仍可用。通过增加 Slave 做备份数据副本</p>
<p>5、实现故障自动 failover，节点之间通过 gossip 协议交换状态信息，用投票机制完成 Slave到 Master 的角色提升。</p>
<p>缺点：</p>
<p>1、资源隔离性较差，容易出现相互影响的情况。</p>
<p>2、数据通过异步复制,不保证数据的强一致性</p>
<h3 id="什么是缓存穿透？如何避免？什么是缓存雪崩？何如避免？"><a href="#什么是缓存穿透？如何避免？什么是缓存雪崩？何如避免？" class="headerlink" title="什么是缓存穿透？如何避免？什么是缓存雪崩？何如避免？"></a>什么是缓存穿透？如何避免？什么是缓存雪崩？何如避免？</h3><p><strong>缓存穿透</strong></p>
<p>一般的缓存系统，都是按照key去缓存查询，如果不存在对应的value，就应该去后端系统查找（比如DB）。一些恶意的请求会故意查询不存在的key,请求量很大，就会对后端系统造成很大的压力。这就叫做缓存穿透。</p>
<p><strong>如何避免？</strong></p>
<p>1：对查询结果为空的情况也进行缓存，缓存时间设置短一点，或者该key对应的数据insert了之后清理缓存。</p>
<p>2：对一定不存在的key进行过滤。可以把所有的可能存在的key放到一个大的Bitmap中，查询时通过该bitmap过滤。</p>
<p><strong>缓存雪崩</strong></p>
<p>当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，会给后端系统带来很大压力。导致系统崩溃。</p>
<p><strong>如何避免？</strong></p>
<p>1：在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。</p>
<p>2：做二级缓存，A1为原始缓存，A2为拷贝缓存，A1失效时，可以访问A2，A1缓存失效时间设置为短期，A2设置为长期</p>
<p>3：不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。</p>
<h3 id="事务管理（ACID）概述"><a href="#事务管理（ACID）概述" class="headerlink" title="事务管理（ACID）概述"></a>事务管理（ACID）概述</h3><p><strong>原子性（Atomicity）</strong><br>原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。</p>
<p><strong>一致性（Consistency）</strong><br>事务前后数据的完整性必须保持一致。</p>
<p><strong>隔离性（Isolation）</strong><br>多个事务并发执行时，一个事务的执行不应影响其他事务的执行</p>
<p><strong>持久性（Durability）</strong><br>持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响</p>
<p><strong>Redis的事务总是具有ACID中的一致性和隔离性</strong>，其他特性是不支持的。当服务器运行在<em>AOF</em>持久化模式下，并且appendfsync选项的值为always时，事务也具有耐久性。</p>
<h3 id="Redis事务支持隔离性吗"><a href="#Redis事务支持隔离性吗" class="headerlink" title="Redis事务支持隔离性吗"></a>Redis事务支持隔离性吗</h3><p>Redis 是单进程程序，并且它保证在执行事务时，不会对事务进行中断，事务可以运行直到执行完所有事务队列中的命令为止。因此，<strong>Redis 的事务是总是带有隔离性的</strong>。</p>
<h3 id="Redis事务保证原子性吗，支持回滚吗"><a href="#Redis事务保证原子性吗，支持回滚吗" class="headerlink" title="Redis事务保证原子性吗，支持回滚吗"></a>Redis事务保证原子性吗，支持回滚吗</h3><p>Redis中，单条命令是原子性执行的，但<strong>事务不保证原子性，且没有回滚</strong>。事务中任意命令执行失败，其余的命令仍会被执行。</p>
<h3 id="Redis事务其他实现"><a href="#Redis事务其他实现" class="headerlink" title="Redis事务其他实现"></a>Redis事务其他实现</h3><p>基于Lua脚本，Redis可以保证脚本内的命令一次性、按顺序地执行，<br>其同时也不提供事务运行错误的回滚，执行过程中如果部分命令运行错误，剩下的命令还是会继续运行完</p>
<p>基于中间标记变量，通过另外的标记变量来标识事务是否执行完成，读取数据时先读取该标记变量判断是否事务执行完成。但这样会需要额外写代码实现，比较繁琐</p>
<h2 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h2><h3 id="Tomcat有几种部署方式？"><a href="#Tomcat有几种部署方式？" class="headerlink" title="Tomcat有几种部署方式？"></a>Tomcat有几种部署方式？</h3><p><strong>第一种方法</strong>：在tomcat中的<code>conf</code>目录中，在<code>server.xml</code>中的，<code>host</code>节点中添加： <code>Context</code> </p>
<p><strong>第二种方法</strong>：将web项目文件件拷贝到webapps 目录中。</p>
<p><strong>第三种方法</strong>：在conf目录中，新建 Catalina（注意大小写）＼localhost目录，在该目录中新建一个xml文件，名字可以随意取，只要和当前文件中的文件名不重复就行了</p>
<p><strong>第四种方法</strong>:  可以用tomcat在线后台管理器,一般tomcat都打开了,直接上传war就可以。</p>
<p>第三种方法有个优点，可以定义别名。服务器端运行的项目名称为path，外部访问的URL则使用XML的文件名。这个方法很方便的隐藏了项目的名称，对一些项目名称被固定不能更换，但外部访问时又想换个路径，非常有效。</p>
<p>第二、三种还有个优点，可以定义一些个性配置，如数据源的配置等。</p>
<h3 id="请解释servlet如何完成生命周期"><a href="#请解释servlet如何完成生命周期" class="headerlink" title="请解释servlet如何完成生命周期?"></a>请解释servlet如何完成生命周期?</h3><p>第一次访问Servlet，init()和service()都被调用了</p>
<p>第二次访问Servlet，service()被调用了</p>
<p>第三次访问Servlet，还是service()被调用了</p>
<p>我们关闭Tomcat服务器的时候，destroy()被调用了！</p>
<p>Servlet生命周期可分为5个步骤：</p>
<ul>
<li><strong>加载Servlet</strong>：当Tomcat第一次访问Servlet的时候，Tomcat会负责创建Servlet的实例；</li>
<li><strong>初始化</strong>：当Servlet被实例化后，Tomcat会调用init()方法初始化这个对象；</li>
<li><strong>处理服务</strong>：当浏览器访问Servlet的时候，Servlet 会调用service()方法处理请求；</li>
<li><strong>销毁</strong>：当Tomcat关闭时或者检测到Servlet要从Tomcat删除的时候会自动调用destroy()方法，让该实例释放掉所占的资源。一个Servlet如果长时间不被使用的话，也会被Tomcat自动销毁；</li>
<li><strong>卸载</strong>：当Servlet调用完destroy()方法后，等待垃圾回收。如果有需要再次使用这个Servlet，会重新调用init()方法进行初始化操作。</li>
</ul>
<p>简单总结：只要访问Servlet，service()就会被调用。init()只有第一次访问Servlet的时候才会被调用。destroy()只有在Tomcat关闭的时候才会被调用。</p>
<h3 id="tomcat有哪几种Connector运行模式？"><a href="#tomcat有哪几种Connector运行模式？" class="headerlink" title="tomcat有哪几种Connector运行模式？"></a>tomcat有哪几种Connector运行模式？</h3><p>Tomcat Connector有三种运行模式（<code>BIO</code>, <code>NIO</code>, <code>APR</code>）</p>
<p>三种模式的不同之处如下：</p>
<p>BIO：传统的Java I/O操作，同步且阻塞IO。一个线程处理一个请求。缺点：并发量高时，线程数较多，浪费资源。Tomcat7或以下，在Linux系统中默认使用这种方式。</p>
<p>NIO：JDK1.4开始支持，同步阻塞或同步非阻塞IO。利用Java的异步IO处理，可以通过少量的线程处理大量的请求。Tomcat8在Linux系统中默认使用这种方式。Tomcat7必须修改Connector配置来启动。</p>
<p>APR：JDK7开始支持，异步非阻塞IO。即Apache Portable Runtime，从操作系统层面解决io阻塞问题。Tomcat7或Tomcat8在Win7或以上的系统中启动默认使用这种方式。Linux如果安装了apr和native，Tomcat直接启动就支持apr。</p>
<h3 id="你平时怎么给tomcat调优"><a href="#你平时怎么给tomcat调优" class="headerlink" title="你平时怎么给tomcat调优?"></a>你平时怎么给tomcat调优?</h3><p>第一步 – 提高JVM栈内存</p>
<p>第二步 – 解决JRE内存泄露</p>
<p>第三步 – 线程池设置</p>
<p>第四步 - 压缩</p>
<p>第六步 – Tomcat原生库</p>
<p>第七步 – 其他选项</p>
<p><a href="https://blog.csdn.net/qq_35393693/article/details/86647661" target="_blank" rel="noopener">https://blog.csdn.net/qq_35393693/article/details/86647661</a></p>
<h2 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a>网络通信</h2><h3 id="http是无状态通信，http的请求方式有哪些，可以自己定义新的请求方式么"><a href="#http是无状态通信，http的请求方式有哪些，可以自己定义新的请求方式么" class="headerlink" title="http是无状态通信，http的请求方式有哪些，可以自己定义新的请求方式么"></a>http是无状态通信，http的请求方式有哪些，可以自己定义新的请求方式么</h3><p><strong>无状态的理解</strong></p>
<p>http的无状态是指请求与请求之间不保存状态，即服务器端不会主动记住上一次请<br>求是谁发的，和这次请求有没有连系。</p>
<p><strong>HTTP请求方式</strong></p>
<p>不能自定义新的请求方式，http 1.1已规定的请求方式有：</p>
<p><strong>OPTIONS</strong></p>
<p>返回服务器针对特定资源所支持的HTTP请求方法，也可以利用向web服务器发送‘*’的请求来测试服务器的功能性</p>
<p>OPTIONS方法用于获取当前URL所支持的方法。若请求成功，则它会在HTTP头中包含一个名为“Allow”的头，值是所支持的方法，如“GET, POST”。</p>
<p><strong>HEAD</strong></p>
<p>向服务器索与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以再不必传输整个响应内容的情况下，就可以获取包含在响应小消息头中的元信息。</p>
<p>HEAD方法与GET方法的行为很类似，但服务器在响应中只返回实体的主体部分。这就允许客户端在未获取实际资源的情况下，对资源的首部进行检查，</p>
<p>使用HEAD，我们可以更高效的完成以下工作： </p>
<ul>
<li>在不获取资源的情况下，了解资源的一些信息，比如资源类型； </li>
<li>通过查看响应中的状态码，可以确定资源是否存在； </li>
<li>通过查看首部，测试资源是否被修改。</li>
</ul>
<p><strong>GET</strong></p>
<p>向特定的资源发出请求。它本质就是发送一个请求来取得服务器上的某一资源。资源通过一组HTTP头和呈现数据（如HTML文本，或者图片或者视频等）返回给客户端。GET请求中，永远不会包含呈现数据。</p>
<p>Get是最常用的方法，通常用于请求服务器发送某个资源，而且应该是安全的和幂等的。</p>
<p><strong>POST</strong></p>
<p>向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。</p>
<p>Loadrunner中对应POST请求函数：web_submit_data,web_submit_form</p>
<p>POST方法向服务器提交数据，比如完成表单数据的提交，将数据提交给服务器处理。</p>
<p><strong>PUT</strong><br>向指定资源位置上传其最新内容</p>
<p>PUT方法是让服务器用请求的主体部分来创建一个由所请求的URL命名的新文档；如果那个文档存在的话，就用这个主体来代替它。</p>
<p><strong>DELETE</strong><br>请求服务器删除Request-URL所标识的资源</p>
<p>DELETE方法就是请求服务器删除指定URL所对应的资源。但是，客户端无法保证删除操作一定会被执行，因为HTTP规范允许服务器在不通知客户端的情况下撤销请求。</p>
<p><strong>TRACE</strong></p>
<p>回显服务器收到的请求，主要用于测试或诊断</p>
<p>TRACE方法会在目的服务器端发起一个“回环”诊断，我们都知道，客户端在发起一个请求时，这个请求可能要穿过防火墙、代理、网关、或者其它的一些应用程序。这中间的每个节点都可能会修改原始的HTTP请求，TRACE方法允许客户端在最终将请求发送服务器时，它变成了什么样子。由于有一个“回环”诊断，在请求最终到达服务器时，服务器会弹回一条TRACE响应，并在响应主体中携带它收到的原始请求报文的最终模样。这样客户端就可以查看HTTP请求报文在发送的途中，是否被修改过了。</p>
<p><strong>CONNECT</strong></p>
<p>HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。</p>
<h3 id="socket通信模型的使用，AIO和NIO"><a href="#socket通信模型的使用，AIO和NIO" class="headerlink" title="socket通信模型的使用，AIO和NIO"></a>socket通信模型的使用，AIO和NIO</h3><p><strong>BIO（同步阻塞IO）</strong></p>
<p>使用ServerSocket绑定IP地址和监听端口，客户端发起连接，通过三次握手建立连接，用socket来进行通信，通过输入输出流的方式来进行同步阻塞的通信每次客户端发起连接请求，都会启动一个线程。<br>线程数量：客户端并发访问数为1：1，由于线程是Java虚拟机中非常宝贵的资源，一旦线程数急剧增加，系统性能会急剧下降，导致线程栈溢出，创建新的线程失败，并最终导致宕机</p>
<p><strong>NIO（同步非阻塞IO）</strong></p>
<p>用NIO方式处理IO使用多路复用器Selector来轮询每个通道Channel，当通道中有事件时就通知处理，不过使用起来相当复杂。</p>
<p><strong>AIO（真正的异步非阻塞IO）</strong></p>
<p>NIO2.0引入了新的异步通道的概念，不需要使用多路复用器（Selector）对注册通道进行轮询即可实现异步读写，从而简化了NIO编程模型。</p>
<p>相关文章:</p>
<p><a href="https://blog.csdn.net/u014401141/article/details/54406195" target="_blank" rel="noopener">Socket,NIO,AIO基本概念(一)</a></p>
<p><a href="https://blog.csdn.net/anxpp/article/details/51512200" target="_blank" rel="noopener">Java 网络IO编程总结（BIO、NIO、AIO均含完整实例代码）</a></p>
<h3 id="NIO的实现原理，为什么是异步非阻塞"><a href="#NIO的实现原理，为什么是异步非阻塞" class="headerlink" title="NIO的实现原理，为什么是异步非阻塞"></a>NIO的实现原理，为什么是异步非阻塞</h3><p><strong>NIO</strong></p>
<p>答：看了一些文章，传统的IO流是阻塞式的，会一直监听一个ServerSocket，在调用read等方法时，他会一直等到数据到来或者缓冲区已满时才返回。调用accept也是一直阻塞到有客户端连接才会返回。每个客户端连接过来后，服务端都会启动一个线程去处理该客户端的请求。并且多线程处理多个连接。每个线程拥有自己的栈空间并且占用一些 CPU 时间。每个线程遇到外部未准备好的时候，都会阻塞掉。阻塞的结果就是会带来大量的进程上下文切换。<br>对于NIO，它是非阻塞式，核心类： </p>
<ul>
<li>Buffer为所有的原始类型提供 (Buffer)缓存支持。 </li>
<li>Charset字符集编码解码解决方案 </li>
<li>Channel一个新的原始 I/O抽象，用于读写Buffer类型，通道可以认为是一种连接，可以是到特定设备，程序或者是网络的连接。</li>
</ul>
<p>NIO就是非阻塞IO（直译）。</p>
<p>非阻塞的意思就是调用是实时返回的不会导致当前线程被挂起（阻塞），<br>比如对一个通道进行read操作nio下如果通道中没有可读数据会直接返回只不过返回值是0，<br>而BIO（阻塞IO）下则会等到通道中有数据才会返回；</p>
<p>但是IO中有个特例就是File IO，因为文件是确定的 而且文件句柄在操作系统中是不能同时被多个线程持有的（多个线程不能同时读写同一个文件，虽然java中有些API声称可以同时操作 只不过是底层实现每次操作都获取一次句柄释放一次句柄而已），<br>所以呢File IO你可以理解为都是非阻塞的，因为read时候文件里面有数据就读数据返回 没数据就是EOF。</p>
<h3 id="同步和异步，阻塞和非阻塞"><a href="#同步和异步，阻塞和非阻塞" class="headerlink" title="同步和异步，阻塞和非阻塞"></a>同步和异步，阻塞和非阻塞</h3><p><strong>同步</strong>：就是指一个进程在执行某个请求的时候，若该请求需要一段时间才能返回信息，那么这个进程将会一直等待下去，直到收到返回信息才继续执行下去；</p>
<p><strong>异步</strong>：是指进程不需要一直等下去，而是继续执行下面的操作，不管其他进程的状态。当有消息返回时系统会通知进程进行处理，这样可以提高执行的效率。 </p>
<p><strong>阻塞调用</strong>：是指调用结果返回之前，当前线程会被挂起。一直处于等待消息通知，不能够执行其他业务，调用线程只有在得到结果之后才会返回。</p>
<p><strong>非阻塞调用</strong>：指在不能立刻得到结果之前，该调用不会阻塞当前线程，而会立刻返回。</p>
<p><strong>示例讲解:你打电话问书店老板有没有《ECMAScript 6入门》这本书时</strong></p>
<p><strong>同步通信机制</strong>: 书店老板会说，你稍等，别挂电话，”我查一下”，然后开始查啊查，等查好了（可能是1分钟，也可能是一天）告诉你结果（返回结果）。在书店老板查找这个过程，你一直在等待他的回复，这期间你不能去干别的事情。<br><strong>异步通信机制</strong>: 书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。然后查好了，他会主动打电话给你。在这里老板通过“回电”这种方式来回调。在书店老板查找这个过程，这期间你可以先去干别的事情。</p>
<p><strong>同步阻塞</strong>：你打电话告诉老板你要买《ECMAScript 6入门》这本书，老板拿起电话听你说完就去查书，没有说话，你什么也不知道，在得到任何结果之前，你一直拿着电话干等，你此时什么也干不了。30分钟后老板直接把书送到你家，这时你才挂断电话。每次电话你都要得到结果（书到家）后你才挂断电话，这是同步。你一直拿着电话等结果，这是阻塞。</p>
<p><strong>同步非阻塞</strong>：你打电话告诉老板你要买《ECMAScript 6入门》这本书，老板拿起电话后说“我不知道有没有货，现在去查”便挂了电话，又过了10分种你第二次打电话说你要买《ECMAScript 6入门》这本书，老板拿起电话说完“还没有查到，你再等会儿”便挂断电话。挂断电话5分钟后老板查到有书，但并没有主动打电话告诉你。</p>
<p>你再次等待10分钟后第三次电话老板问结果，老板说“书有了，我给你送到家”，你断挂电话。每次电话你都要得得到结果（去查-&gt;还没有查到-&gt;有货）后你才挂断电话，这是同步。你每隔10分钟打电话询问结果，这是非阻塞。</p>
<p><strong>异步阻塞</strong>：你打电话过去问老板有没有《ECMAScript 6入门》这本书，老板说“我不知道有没有货，现在去查，先挂了电话，有结果告诉你，你等我电话”就挂掉电话。</p>
<p>等电话期间你什么也不干，老板主动给你发短信通知你结果书有了，5分钟后希望老板现在把书送来，你再次打电话让老板送书，老板马上送书上门。老板主动给你发短信，这是异步。等待老板的短信期间你什么也没干，这是阻塞。</p>
<p><strong>异步非阻塞</strong>：你打电话过去后问老板有没有《ECMAScript 6入门》这本书，老板说“好的，有货我直接给你送上门”就挂掉电话。然后你想干嘛干嘛，等老板门到后你看书。等待老板主动给你送书上门，这是异步。挂了电话后你就想干嘛干嘛，这是非阻塞。所以一般异步是配合非阻塞使用的，这样才能发挥异步的效用。</p>
<h3 id="http中，get-post的区别"><a href="#http中，get-post的区别" class="headerlink" title="http中，get post的区别"></a>http中，get post的区别</h3><p>GET一般用于获取/查询资源信息，Get是最常用的方法，通常用于请求服务器发送某个资源，而且应该是安全的和幂等的。</p>
<p>而POST一般用于更新资源信息。POST方法向服务器提交数据，比如完成表单数据的提交，将数据提交给服务器处理。</p>
<p>GET和POST的区别：</p>
<p>GET请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），以？分割URL和传输数据，参数之间以&amp;相连，如：login.action?name=hyddd&amp;password=idontknow&amp;verify=%E4%BD%A0%E5%A5%BD。</p>
<p>如果数据是英文字母或数字，则原样发送；如果是空格，转换为+；如果是中文或其他字符，则直接把字符串用BASE64加密，得出如：%E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII码值。而与之对应的，POST把提交的数据放置在HTTP包的包体中。</p>
<p>POST的安全性要比GET的安全性高。</p>
<p>注意：这里所说的安全性和上面GET提到的“安全”不是同个概念。</p>
<p>上面“安全”的含义仅仅是不作数据修改，而这里安全的含义是真正的Security的含义。</p>
<p>比如：通过GET提交数据，用户名和密码将明文出现在URL上，</p>
<p>因为：</p>
<p>(1)登录页面有可能被浏览器缓存，</p>
<p>(2)其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了，除此之外，使用GET提交数据还可能会造成Cross-site request forgery攻击（CSRF,跨站请求伪造，也被称为：one click attack/session riding）。</p>
<p>相关文章:<a href="https://www.cnblogs.com/williamjie/p/9099940.html" target="_blank" rel="noopener">浅谈HTTP中GET、POST用法以及它们的区别</a></p>
<h3 id="http-tcp-udp之间关系和区别"><a href="#http-tcp-udp之间关系和区别" class="headerlink" title="http,tcp,udp之间关系和区别"></a>http,tcp,udp之间关系和区别</h3><p>*<em>TCP协议 *</em></p>
<p>TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC 793定义。在简化的计算机网络OSI模型中，它完成第四层传输层所指定的功能，用户数据报协议（UDP）是同一层内另一个重要的传输协议。</p>
<p>*<em>TCP的优点 *</em></p>
<p>可靠，稳定<br>TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源。</p>
<p>*<em>TCP的缺点 *</em></p>
<p>慢，效率低，占用系统资源高，易被攻击<br>TCP在传递数据之前，要先建连接，这会消耗时间，而且在数据传递时，确认机制、重传机制、拥塞控制机制等都会消耗大量的时间，而且要在每台设备上维护所有的传输连接，事实上，每个连接都会占用系统的CPU、内存等硬件资源。 </p>
<p>由于TCP存在确认机制和三次握手机制，这些是导致TCP容易被人利用，实现DOS、DDOS、CC等攻击。</p>
<p>*<em>TCP应用场景 *</em></p>
<p>当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议。 </p>
<p>在日常生活中，常见使用TCP协议的应用比如：浏览器使用HTTP，Outlook使用POP、SMTP，QQ文件传输等。</p>
<p>*<em>UDP协议 *</em></p>
<p>UDP 是User Datagram Protocol的简称， 中文名是用户数据报协议，是OSI（Open System Interconnection，开放式系统互联） 参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务，IETF RFC 768是UDP的正式规范。UDP在IP报文的协议号是17。</p>
<p>*<em>UDP的优点 *</em></p>
<p>快，比TCP稍安全<br>UDP没有TCP的握手、确认、窗口、重传、拥塞控制等机制，UDP是一个无状态的传输协议，所以它在传递数据时非常快。没有TCP的这些机制，UDP较TCP被攻击者利用的漏洞就要少一些。但UDP也是无法避免攻击的，比如：UDP Flood攻击……</p>
<p>*<em>UDP的缺点 *</em></p>
<p>不可靠，不稳定<br>因为UDP没有TCP那些可靠的机制，在数据传递时，如果网络质量不好，就会很容易丢包。</p>
<p><strong>UDP应用场景</strong> </p>
<p>当对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用UDP。在日常生活中，常见使用UDP协议的应用比如：QQ语音、QQ视频、TFTP等。</p>
<p>相关文章:<a href="https://blog.csdn.net/hai_chao/article/details/79626161" target="_blank" rel="noopener">说说TCP,UDP和socket,Http之间联系和区别</a></p>

      
       <hr><span style="font-style: italic;color: gray;"> 转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。可以在下面评论区评论，也可以邮件至 kylin_lawliet@163.com </span>
    </div>
</article>



<div class="article_copyright">
    <p><span class="copy-title">文章标题:</span>问答</p>
    <p><span class="copy-title">文章字数:</span><span class="post-count">28.3k</span></p>
    <p><span class="copy-title">本文作者:</span><a  title="blackcat">blackcat</a></p>
    <p><span class="copy-title">发布时间:</span>2020-01-03, 08:00:18</p>
    <p><span class="copy-title">最后更新:</span>2020-04-07, 19:20:14</p>
    <span class="copy-title">原始链接:</span><a class="post-url" href="/2020/01/03/interview/" title="问答">https://kylin-blackcat.com/2020/01/03/interview/</a>
    <p>
        <span class="copy-title">版权声明:</span><i class="fa fa-creative-commons"></i> <a rel="license noopener" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" title="CC BY-NC-SA 4.0 International" target = "_blank">"署名-非商用-相同方式共享 4.0"</a> 转载请保留原文链接及作者。
    </p>
</div>



    <div id="comments"></div>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">

<script type="text/javascript">
    $.getScript('/js/gitalk.js', function () {
        var gitalk = new Gitalk({
            clientID: '312730c94e34ee10b19d',
            clientSecret: '5e87bc5a90b6723fd6495ebe7ffde8e0f69caceb',
            repo: 'gitalk-commnet',
            owner: 'kylin-lawliet',
            admin: ['kylin-lawliet'],
            id: decodeURI(location.pathname),
            distractionFreeMode: 'true',
            language: 'zh-CN',
            perPage: parseInt('10',10)
        })
        gitalk.render('comments')
    })
</script>




    




    </div>
    <div class="copyright">
        <p class="footer-entry">©2019 blackcat</p>
<!--
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>
-->

    </div>
    <div class="full-toc">
        <button class="full"><span class="min "></span></button>
<button class="post-toc-menu"><span class="post-toc-menu-icons"></span></button>
<div class="post-toc"><span class="post-toc-title">目录</span>
    <div class="post-toc-content">

    </div>
</div>
<a class="" id="rocket" ></a>

    </div>
</div>
<div class="acParent"></div>

</body>
<script src="/js/jquery.pjax.js?v=1.0.1" ></script>

<script src="/js/script.js?v=1.0.1" ></script>
<script>
    var img_resize = 'default';
    /*作者、标签的自动补全*/
    $(function () {
        $('.search').AutoComplete({
            'data': ['#javascript','#hexo','#Idea','#easyUI','#git，hexo','#docker','#MySQL','#web','#jquery','#spring boot','#spring','#mybatis','#postman','#SpringBoot','#Java','#VMware','#website','#MyBatis','#MySql','#Maven','#Mybatis','#lombok','#Bootstrap','#Solr','#JVM','#SQL','#生活','#redis','#Shiro','#设计模式',],
            'itemHeight': 20,
            'width': 418
        }).AutoComplete('show');
    })
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $(".post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        

        /*高亮代码块行号*/
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    

</script>

<!--加入行号的高亮代码块样式-->

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
        .nav .hide-list.fullscreen {
            left: 492px
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    
    .post .pjax article .article-entry>ol, .post .pjax article .article-entry>ul, .post .pjax article>ol, .post .pjax article>ul{
        border: #e2dede solid 1px;
        border-radius: 10px;
        padding: 10px 32px 10px 56px;
    }
    .post .pjax article .article-entry li>ol, .post .pjax article .article-entry li>ul,.post .pjax article li>ol, .post .pjax article li>ul{
        padding-top: 5px;
        padding-bottom: 5px;
    }
    .post .pjax article .article-entry>ol>li, .post .pjax article .article-entry>ul>li,.post .pjax article>ol>li, .post .pjax article>ul>li{
        margin-bottom: auto;
        margin-left: auto;
    }
    .post .pjax article .article-entry li>ol>li, .post .pjax article .article-entry li>ul>li,.post .pjax article li>ol>li, .post .pjax article li>ul>li{
        margin-bottom: auto;
        margin-left: auto;
    }
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    
    .nav-right:before {
        content: ' ';
        display: block;
        position: absolute;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        opacity: 0.3;
        background: url("https://i.loli.net/2019/07/22/5d3521411f3f169375.png");
        background-repeat: no-repeat;
        background-position: 50% 0;
        -ms-background-size: cover;
        -o-background-size: cover;
        -moz-background-size: cover;
        -webkit-background-size: cover;
        background-size: cover;
    }
    

    
    .post .pjax article :not(pre) > code {
        color: #24292e;
        font-family: SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;
        background-color: rgba(27,31,35,.05);
        border-radius: 3px;
        font-size: 85%;
        margin: 0;
        padding: .2em .4em;
    }
    
</style>







</html>

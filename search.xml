<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>docker安装redis 及相关</title>
      <link href="/2020/04/09/docker-redis/"/>
      <url>/2020/04/09/docker-redis/</url>
      
        <content type="html"><![CDATA[<p>Docker安装redis 具体步骤</p><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><strong>拉取镜像</strong></p><pre><code class="linux">docker pull redis</code></pre><p><strong>运行容器</strong></p><pre><code class="linux">docker run -d -p 6379:6379 -v $PWD/conf/redis.conf:/usr/local/etc/redis/redis.conf -v $PWD/data:/data --name docker-redis docker.io/redis redis-server /usr/local/etc/redis/redis.conf --appendonly yes --requirepass &quot;123456&quot;</code></pre><p>简化版命令</p><pre><code class="linux">docker run --restart=always -p 6379:6379 --name redis -d redis redis-server --appendonly yes --requirepass &quot;123456&quot;</code></pre><ul><li><code>-d</code>：表示后台运行，不加-d执行上面的命令你就会看到启动的日志信息了</li><li><code>-p</code>：表示端口映射，冒号左面的是我们的宿主机的端口，也就是我们虚拟机的端口，而右侧则表示的是容器内的端口</li><li><code>--name</code>：是我们给容器取的名字</li><li><code>--restart</code>：<strong>no</strong>为默认值，表示容器退出时，docker不自动重启容器;<strong>on-failure</strong>表示，若容器的退出状态非0，则docker自动重启容器,还可以指定重启次数，若超过指定次数未能启动容器则放弃;<strong>always</strong>表示，只要容器退出，则docker将自动重启容器</li><li><code>-v</code>：表示挂载路径，<code>$PWD</code>表示当前目录下，冒号左面的表示我们宿主机的挂载目录，也就是我们虚拟机所在的文件路径，冒号右边则表是的是redis容器在容器内部的路径，上面的命令我分别挂载了redis.conf(redis的配置文件)，如需使用配置文件的方式启动redis，这里则需要加上，还有redis存放数据所在的目录</li><li><code>--appendonly yes</code>：表示redis开启持久化策略</li><li><code>–requirepass</code>：加密码</li></ul><h2 id="一些命令"><a href="#一些命令" class="headerlink" title="一些命令"></a>一些命令</h2><h3 id="查看IP地址"><a href="#查看IP地址" class="headerlink" title="查看IP地址"></a>查看IP地址</h3><pre><code>docker inspect 容器名称 | grep IPAddress</code></pre><h3 id="远程服务连接"><a href="#远程服务连接" class="headerlink" title="远程服务连接"></a>远程服务连接</h3><pre><code>redis-cli -h 127.0.0.1 -p 6379</code></pre><p>windows下</p><pre><code>redis-cli.exe -h 127.0.0.1 -p 6379</code></pre><h3 id="远程服务停止"><a href="#远程服务停止" class="headerlink" title="远程服务停止"></a>远程服务停止</h3><pre><code>redis-cli -h 172.168.10.254 -p6379 shutdown</code></pre><h3 id="有权限控制时-加上-a-密码"><a href="#有权限控制时-加上-a-密码" class="headerlink" title="有权限控制时(加上-a 密码)"></a>有权限控制时(加上-a 密码)</h3><pre><code>redis-cli -h 127.0.0.1 -p 6379 -a 123456</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/2020/03/27/design_pattern/"/>
      <url>/2020/03/27/design_pattern/</url>
      
        <content type="html"><![CDATA[<p>设计模式相关整理</p><a id="more"></a><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><blockquote><p>设计模式分为三大类：</p></blockquote><p><strong>创建型模式</strong>（五种）：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式</p><p><strong>结构型模式</strong>（七种）：适配器模式、装饰器模式、代理模式、外观(门面)模式、桥接模式、组合模式、享元模式</p><p><strong>行为型模式</strong>（十一种）：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</p><h2 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p><strong>一杯可乐</strong>：是被盖子给封起来的，只留了一个孔可以插吸管才能喝。这其实就是封装，封装隐藏了内部的可乐，对外留有一个接口来访问，这样有啥好处？干净！防止外部随便访问，比如灰尘落入弄脏内部数据。</p><p>对外暴露的习惯是非常容易使用的，你根本无需关心内部实现细节，你喝个可乐还在乎气压怎么增大减小导致可乐杯吸出来？非常简单，一个字：“吸”！</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p><strong>DNA</strong>：生物一代代的延续下来是靠什么保持其父辈的特征？遗传基因，正所谓龙生龙凤生凤，老鼠儿子会打洞，没有这个机制那代码量会急剧上升，很多功能，资源都是重复的在定义，这样造成极大的冗余和浪费！</p><p>所以就有了继承机制，儿子从父亲那继承下来一些东西，不需要自己再去拼搏了，比如富二代继承家产，再比如天生好嗓子，妈妈是王菲。当然，只是单单继承是没有意义的，否则不如直接用父类了，所以得有自己的特色，比如增加属性啊，重写方法之类。</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>没有继承就没有多态，这个多态其实跟上面的继承是有关系的。中华美食博大精深，菜品众多，色香味俱全，形态各异，但是万变不离其宗，他们都是食品，也就是说，他们都继承自食品类，食材都是来自自然界生长出来的有机生物。</p><p>这不就是继承么？多态其实是很巧妙地利用了继承这个特性实现了另一种机制。</p><p>我们人类可以吃塑料么？显而易见不能，因为我们的接口只接收上面的天然有机食品类，对于铁啊什么的金属无机物是不能消化的。</p><p>所以说，我们人类只接受食品类的多态，比如肉，蛋，蔬菜，水果，而决不能是塑料。来看一个多态的具体例子。</p><p><strong>个人电脑</strong>:  越是古老的电脑越是高度集成，某天显示器坏掉了我们会发现麻烦来了，我们只能去送修，然后把整个壳子拆开进行更换，也许它是焊接在主板上的那就惨了，模块间的过度依赖造成了极大的耦合度，而更糟的是这种显示器已经停产了根本买不到新的来匹配，那只能扔掉了。</p><p>为了解决这个问题设计人员提出了模块化的概念，各种设备如雨后春笋般涌现。如：鼠标，键盘，摄像头，打印机，存储设备……但又有一个问题，每种设备都有一种接口，那电脑主机上得有多少种接口啊？这不坑爹么？于是出现了接口标准化。</p><p>在各种接口百花齐放的时候，有一种接口胜出了，它就是<code>USB</code>。它提供了一种接口标准，电压5V，双工数据传输， 供电…… 最重要的是物理上形状是不一样的，所以别乱插、别乱捅。</p><p>话说有一个<code>Computer</code>类，一个<code>USB</code>接口，还有各种<code>USB</code>设备，故事就这样开始了。</p><p><code>Computer</code>：“我上面装有一个<code>USB</code>接口，我只认识这个接口传递过来的数据，谁要跟我沟通你就去找它吧。”</p><p><code>USB</code>：“要接驳我的设备是什么我不关心，但我规定设备必须有<code>readData()</code>这个方法，但是怎么实现我不管，总之你得通过这个方法把数据给我。”</p><p><code>Keyboard</code>：“我有<code>readData()</code>这个方法，我已经实现好了，用户一敲键盘我就读过来传给你。”</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>早期的枪设计非常原始简陋，打一发子弹要很长时间去准备，装填时要先把火药倒入枪管内，然后装入铅弹，最后用棍子戳实后才能发射。 射击时士兵扣动扳机冲击火药爆炸，子弹被冲击出去射杀敌方，然后再循环往复进行装填这一过程，费时费力，所以我们能看到19世纪战场上的士兵方阵前后排轮换射击，后排的士兵实际上在装填弹药以节省时间。</p><p>为了解决这个问题，我们开始思考了，既然弹药装填困难，那么不如把弹丸和火药组合起来，然后封装在弹壳里，只要撞击底火弹头就会被爆炸的火药崩出去，这样直接装入枪膛一触即发，杀人方便多了，这个就是“封装”。</p><p>那么问题又来了，虽然封装弹药节省了很多时间，但一次打一发子弹还是很麻烦不是？那就在子弹之上再包装一层弹夹吧，这相当于压栈，最早压入（push）的子弹最后弹出（pop），先进后出（<strong>栈数据结构</strong>），这样子弹打完了只要换弹夹就好了。总之只要枪接收子弹就对了，我们都是子弹的继承。</p><p>然后设计师做了一件更丧心病狂的事情，他造了个外挂弹夹箱来实现弹夹接口的标准方法，背在身上不停地突突，多态发生了，冷兵器时代结束了，以上<code>UML</code>图正描述了这种嗜杀如狂的疯狂设计模式。</p><h2 id="单例（Singleton）"><a href="#单例（Singleton）" class="headerlink" title="单例（Singleton）"></a>单例（Singleton）</h2><h3 id="初步理解"><a href="#初步理解" class="headerlink" title="初步理解"></a>初步理解</h3><p>单例，顾名思义，整个系统其实就只有一个实例存在，不能再多，否则就不叫单例。那我们把整个宇宙看做是一个庞大的系统，这宇宙里有各种对象存在，人啊，动物啊，植物啊不胜枚举，这些都是实例。</p><p>就以宗教示例：</p><p>单印度一个国家就有几百个神，人们各信各的，风俗各异，各邦文化冲突不断，语言不通，办事效率极低。为了让幸福美好洒满人间，那我们就定义一位神吧，独一无二的神。</p><p>先写一个God类</p><pre><code class="java">public class God {}</code></pre><p>首先我们得保证任何人都不能去创建神的实例，否则如：<code>new God()</code>，这样世界又要陷入战争的灾难，各种造神运动。那就不写构造方法吧？不行，因为有默认的无参构造器！那就把构造方法改成<code>private</code>吧，也就是神可以自己创造自己，但别人不能。</p><pre><code class="java">public class God {    private God(){}//构造方法私有化}</code></pre><p>God类里面封装一个God自己，对，一切都是神创造的，包括我们人类。谁也不能造上帝，神自己造自己。</p><pre><code class="java">public class God {    private static final God god = new God();//自有永有的神单例    private God(){}//构造方法私有化}</code></pre><p>以上<code>private</code>关键字保证了上帝的私有性，不可见性，不可访问性，我想没有活人见过上帝吧？<code>static</code>关键字保证上帝的静态性，他与类同在，不依赖于类的实例化就自有永有，他将在内存中永生，<code>GC</code>垃圾回收器也回收不了他。<code>final</code>关键字则保证这位神是和常量，衡量，他是终极上帝，不能再改。</p><p>正如同静态方法<code>main()</code>，不需要实例化类就能运行的入口，同样我们需要一个静态方法<code>getInstance()</code>来请神，方法体内我们就返回这个在唯一的真神，当然方法它必须是<code>public</code>公开的，不然谁都访问不了。</p><pre><code class="java">public class God {    private static final God god = new God();//自有永有的神单例    private God(){}//构造方法私有化    public static God getInstance(){//请神方法公开化        return god;    }}</code></pre><p>以上的神类雏形已经写好了，当然你还可以加其他的功能方法，比如说创世纪神造了光，造了世界、动物、人、亚当夏娃等等功能，我们这里就不在赘述了。那对于外部来说只要调用<code>God.getInstance();</code>就可以拿到神了，而且不管谁拿，拿几次，都是同一个神，这样就保证了整个系统中神的唯一性，不可伪造性，至于其他先知那也只是神的代理人，只能帮请神而已。</p><p>好了，其实我们已经学会了单例模式的“<strong>痴汉模式（Eager load）</strong>”，代码第一行一开始就造出了神（new God那一句），已经准备好了随时给你请神，这样就有了一个问题，如果没人请神那不是白造了？提前备货如果价格跌了不是很惨？反应在系统中的问题就是占用了内存空间。于是又有了“<strong>懒汉模式（Lazy load）</strong>”</p><pre><code class="java">public class God {    private static God god;//这里不进行实例化    private God(){}    public static God getInstance() {        if (god == null) {//如果无神才造神            god = new God();        }        return god;    }}</code></pre><p>这我们看到一开始就没有造神，只有某人第一次求神时才实例化，之后再求的就直接返回了。这样的好处是省了一段时间的内存（无求神期间），坏处是第一次请神的时候速度相较之前的痴汉模式会慢，因为要消耗CPU去造神。</p><p>其实这么写是在多线程模式下是有陷阱的，试想多人同时并发请神的话，依然会造成多神，好吧我们再来改良一下，把请神方法加上<code>synchronized</code>，声明为同步方法，某线程调用前必须获取同步锁，调用完后会释放锁给其他线程用，也就是请神的必须排队，大家一个一个按顺序来。</p><pre><code class="java">public class God {    private static God god;//这里不进行实例化    private God(){}    public static synchronized God getInstance() {//此处加入同步        if (god == null) {//如果无神才造神            god = new God();        }        return god;    }}</code></pre><p>然而，这样做是要付出代价的，还没进庙呢不管三七二十一请神的直接给加锁排队，结果队伍从北边的庙排到了南天门，人们都要来一个一个拜佛求神，这造成了巨大时间浪费，没有充分利用CPU资源并发优势（特别是多核情况）。好吧，那还是让人们抢好了，但依然得保证单例神的情况下。</p><p>这里我们去掉方法上的同步关键字，换到方法体内部做同步，整个方法开放并发大家都可以同时入庙，当然起早贪黑的虔诚信徒们要抢头香是必须要入堂排队的。一旦头香诞生，那其他抢香的都白早起，白排队了。再之后的事情我们都可以预见了，头注香被抢后堂内排队再无必要来了，大家可以在堂外同时并发拜佛求神，这就极大的利用了CPU资源。简而言之：只有第一批抢头香的在排队，之后大家都不必排队了，代码如下:</p><pre><code class="java">public class God {    private volatile static God god;    private God(){}     public static God getInstance() {//庙是开放的不用排队进入        if (god == null) {//如果头柱香未产生，这批抢香人进入堂内排队。            synchronized(God.class){                if (god == null) {//只有头香造了神，其他抢香的白排队了                    god = new God();                }            }        }        //此处头柱香产生后不必再排队        return god;    }}</code></pre><p>其实在这之上还发展出了各种各样的单例模式变种，我们这里只讲了最基础的两种，其实他们都各有优缺，我们要做到灵活运用，各取所需。对于我个人来讲倾向于懒汉模式，现在内存成本根本不算问题，况且迟早要被实例化占用内存，加锁解锁更是一种浪费，还有同步效率低等问题，如果上帝不是很占空间那就没必要去懒汉延迟加载，越复杂问题越多，风险越大。</p><h3 id="定义说明"><a href="#定义说明" class="headerlink" title="定义说明"></a>定义说明</h3><p><strong>定义</strong>：</p><p> 单例模式，是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中一个类只有一个实例。即一个类只有一个对象实例。</p><p><strong>特点</strong>：</p><ul><li>单例类只能有一个实例。</li><li>单例类必须自己自己创建自己的唯一实例。</li><li>单例类必须给所有其他对象提供这一实例</li></ul><p><strong>单例模式的要点：</strong></p><ul><li>私有的构造方法</li><li>指向自己实例的私有静态引用</li><li>以自己实例为返回值的静态的公有的方法</li></ul><p><strong>单例模式根据实例化对象时机的不同分为两种：</strong></p><p>一种是饿汉式单例，一种是懒汉式单例。</p><p>饿汉式单例在单例类被加载时候，就实例化一个对象交给自己的引用；</p><p>而懒汉式在调用取得实例方法的时候才会实例化对象。</p><p><strong>单例模式的优点：</strong></p><ul><li>在内存中只有一个对象，节省内存空间。</li><li>避免频繁的创建销毁对象，可以提高性能。</li><li>避免对共享资源的多重占用。</li><li>可以全局访问。</li></ul><p><strong>单例模式的优点：</strong></p><ul><li>扩展困难，由于<code>getInstance</code>静态函数没有办法生成子类的实例。如果要拓展，只有重写那个类。</li><li>隐式使用引起类结构不清晰。</li><li>导致程序内存泄露的问题。</li></ul><p><strong>适用场景：</strong></p><p>​    由于单例模式的以上优点，所以是编程中用的比较多的一种设计模式。以下为使用单例模式的场景：</p><ul><li><p>需要频繁实例化然后销毁的对象。</p></li><li><p>创建对象时耗时过多或者耗资源过多，但又经常用到的对象。</p></li><li><p>资源共享的情况下，避免由于资源操作时导致的性能或损耗等</p></li><li><p>控制资源的情况下，方便资源之间的互相通信。</p></li></ul><p><strong>单例模式注意事项：</strong></p><p>只能使用单例类提供的方法得到单例对象，不要使用反射，否则将会实例化一个新对象。</p><p>不要做断开单例类对象与类中静态引用的危险操作。</p><p>多线程使用单例使用共享资源时，注意线程安全问题。</p><h3 id="深入学习"><a href="#深入学习" class="headerlink" title="深入学习"></a>深入学习</h3><blockquote><p>关于Java中单例模式的一些常见问题：</p></blockquote><h4 id="单例模式的对象长时间不用会被jvm垃圾收集器收集吗"><a href="#单例模式的对象长时间不用会被jvm垃圾收集器收集吗" class="headerlink" title="单例模式的对象长时间不用会被jvm垃圾收集器收集吗"></a>单例模式的对象长时间不用会被jvm垃圾收集器收集吗</h4><p>除非人为地断开单例中静态引用到单例对象的联接，否则<code>jvm</code>垃圾收集器是不会回收单例对象的。</p><p><code>jvm</code>卸载类的判定条件如下：</p><ul><li><p>该类所有的实例都已经被回收，也就是<code>java</code>堆中不存在该类的任何实例。</p></li><li><p>加载该类的<code>ClassLoader</code>已经被回收。</p></li><li><p>该类对应的<code>java.lang.Class</code>对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法。</p></li></ul><p>​    只有三个条件都满足，<code>jvm</code>才会在垃圾收集的时候卸载类。显然，单例的类不满足条件一，因此单例类也不会被回收。</p><h4 id="在一个jvm中会出现多个单例吗"><a href="#在一个jvm中会出现多个单例吗" class="headerlink" title="在一个jvm中会出现多个单例吗"></a>在一个jvm中会出现多个单例吗</h4><p>​    在分布式系统、多个类加载器、以及序列化的的情况下，会产生多个单例，这一点是无庸置疑的。那么在同一个<code>jvm</code>中，会不会产生单例呢？使用单例提供的<code>getInstance()</code>方法只能得到同一个单例，除非是使用反射方式，将会得到新的单例。代码如下：</p><pre><code class="java">Class c = Class.forName(Singleton.class.getName());  Constructor ct = c.getDeclaredConstructor();  ct.setAccessible(true);  Singleton singleton = (Singleton)ct.newInstance();</code></pre><p>这样，每次运行都会产生新的单例对象。所以运用单例模式时，一定注意不要使用反射产生新的单例对象。</p><h4 id="在getInstance-方法上同步有优势还是仅同步必要的块更优优势？"><a href="#在getInstance-方法上同步有优势还是仅同步必要的块更优优势？" class="headerlink" title="在getInstance()方法上同步有优势还是仅同步必要的块更优优势？"></a>在<code>getInstance()</code>方法上同步有优势还是仅同步必要的块更优优势？</h4><p>因为锁定仅仅在创建实例时才有意义，然后其他时候实例仅仅是只读访问的，因此只同步必要的块的性能更优，并且是更好的选择。</p><p>缺点：只有在第一次调用的时候，才会出现生成2个对象，才必须要求同步。而一旦singleton 不为null，系统依旧花费同步锁开销，有点得不偿失。</p><h4 id="单例类可以被继承吗"><a href="#单例类可以被继承吗" class="headerlink" title="单例类可以被继承吗"></a>单例类可以被继承吗</h4><p>根据单例实例构造的时机和方式不同，单例模式还可以分成几种。但对于这种通过私有化构造函数，静态方法提供实例的单例类而言，是不支持继承的。</p><p>这种模式的单例实现要求每个具体的单例类自身来维护单例实例和限制多个实例的生成。但可以采用另外一种实现单例的思路：登记式单例，来使得单例对继承开放。</p><h2 id="原型（Prototype）"><a href="#原型（Prototype）" class="headerlink" title="原型（Prototype）"></a>原型（Prototype）</h2><h3 id="初步理解-1"><a href="#初步理解-1" class="headerlink" title="初步理解"></a>初步理解</h3><p>原型是什么意思？工业生产中通常是指在量产之前研发出的概念实现，如果可行性满足即可参照原型进行量产。有人说了，那不就是印章？其实这并不怎么贴切，印章并不是最终实例，我更愿意称其为“<strong>类</strong>”！</p><p>大家一定见过这种印章吧，就是皮带轮可以转动，可随意调整成自己需要的文字，其实跟我们的四大发明活字印刷同出一辙，我们填完表格签好字，行政人员拿这个往上一盖，一个日期便出现在落款出。</p><p>其实当行政人员调整好了文字，照纸上盖下去那一刹那，其实就类似于实例化的过程了，<code>new Stamp();</code>每个盖出的印都可以不一样，例如我们更换了日期，那么每天都有不同日期的实例了，那有人意识到了，同一天的那些实例们，其实是完全一模一样的实例拷贝，那这就比较麻烦，每个文档都要用章子（类）去盖（实例化）一下。</p><p>好了，让我们忘掉盖章实例化模式吧。通常我们都是怎样做协议书的呢？搞一个Word文档吧，写好后复制给别人修改就好了。</p><p>注意了，行政人员要新建一个word文档了，这个过程其实是在实例化，我们暂且叫它“零号”文件，那当写好了文档后，把这个文件复制给其他公司员工去填写，那么这个零号文件我们就称之为“原型”。</p><p>想必我们已经搞明白了，原型模式，实际上是从原型实例复制克隆出新实例，而绝不是从类去实例化，这个过程的区别一定要搞清楚！OK，那开始我们的实战部分。</p><p>假设我们要做一个打飞机游戏，游戏设定位纵版移动，单打。</p><p>既然是单打，那我们的主角飞机当然只有一架，于是我们写一个<a href="#单例(singleton)">单例(singleton)</a>，此处我们省略主角代码。那么敌机呢？当然有很多架了，好，为了说明问题我们去繁就简，先写一个敌机类。</p><pre><code class="java">public class EnemyPlane {    private int x;//敌机横坐标    private int y = 0;//敌机纵坐标    public EnemyPlane(int x) {//构造器        this.x = x;    }    public int getX() {       return x;    }    public int getY() {        return y;    }    public void fly(){//让敌机飞        y++;//每调用一次，敌机飞行时纵坐标＋1    }}</code></pre><p>代码第5行，初始化只接收x坐标，因为敌机一开始是从顶部出来所以纵坐标y必然是0。此类只提供<code>getter</code>而没有<code>setter</code>，也就是说只能在初始化时确定敌机的横坐标x，后续是不需要更改坐标了，只要连续调用第17行的fly方法即可让飞机跟雨点一样往下砸。</p><p>好了，我们开始绘制敌机动画了，先实例化出50架吧。</p><pre><code class="java">public class Client {     public static void main(String[] args) {         List&lt;EnemyPlane&gt; enemyPlanes = new ArrayList&lt;EnemyPlane&gt;();         for (int i = 0; i &lt; 50; i++) {             //此处随机位置产生敌机             EnemyPlane ep = new EnemyPlane(new Random().nextInt(200));             enemyPlanes.add(ep);         }    }}</code></pre><p>注意代码第7行，觉不觉得每个迭代都实例化new出一个对象存在性能问题呢？答案是肯定的，这个实例化的过程是得不偿失的，构造方法会被调用50次，cpu被极大浪费了，内存被极大浪费了，尤其对于游戏来说性能瓶颈绝对是大忌，这会造成用户体验问题，谁也不希望玩游戏会卡帧吧。</p><p>那到底什么时候去new？游戏场景初始化就new敌机（如以上代码）？这关会出现500个敌机那我们一次都new出来吧？浪费内存！那我们实时的去new，每到一个地方才new出来一个！浪费CPU！如果敌机线程过多造成CPU资源耗尽，每出一个敌机游戏会卡一下，试想一下这种极端情况下，游戏对象实例很多的话就是在作死。</p><p>解决方案到底是什么呢？好，原型模式Prototype！上代码！我们把上面的敌机类改造一下，让它支持原型拷贝。</p><pre><code class="java">public class EnemyPlane implements Cloneable{//此处实现克隆接口    private int x;//敌机横坐标    private int y = 0;//敌机纵坐标    public EnemyPlane(int x) {//构造器        this.x = x;    }    public int getX() {        return x;    }    public int getY() {        return y;    }    public void fly(){//让敌机飞        y++;//每调用一次，敌机飞行时纵坐标＋1    }    //此处开放setX，为了让克隆后的实例重新修改x坐标    public void setX(int x) {        this.x = x;    }    //为了保证飞机飞行的连贯性    //这里我们关闭setY方法，不支持随意更改Y纵坐标//    public void setY(int y) {//        this.y = y;//    }    //重写克隆方法    @Override    public EnemyPlane clone() throws CloneNotSupportedException {        return (EnemyPlane)super.clone();    }}</code></pre><p>注意看从第21行开始的修改，<code>setX()</code>方法为了保证克隆飞机的个性化，因为它们出现的位置是不同的。第34行的克隆方法重写我们调用了父类<code>Object</code>的克隆方法，这里<code>JVM</code>会进行内存操作直接拷贝原始数据流，简单粗暴，不会有其他更多的复杂操作（类加载，实例化，初始化等等），速度远远快于实例化操作。OK，我们看怎么克隆这些敌机，做一个造飞机的工厂吧。</p><pre><code class="java">public class EnemyPlaneFactory {     //此处用懒汉模式造一个敌机原型     private static EnemyPlane protoType = new EnemyPlane(200);     //获取敌机克隆实例     public static EnemyPlane getInstance(int x){         EnemyPlane clone = protoType.clone();//复制原型机         clone.setX(x);//重新设置克隆机的x坐标         return clone;    }}</code></pre><p>此处我们省去抓异常，随后的事情就非常简单了，我们只需要很简单地调用<code>EnemyPlaneFactory.getInstance(int x)</code>并声明x坐标位置，一架敌机很快地就做好了，并且我们保证是在敌机出现的时候再去克隆，确保不要一开局就全部克隆出来，如此一来，既保证了实时性节省了内存空间，又保证了敌机实例化的速度，游戏绝不会卡帧！至于此处代码中的懒汉原型还可以怎样优化那就要根据具体场景了，交给大家自由发挥吧，这里只说明主要问题。</p><p>最后，还要强调一点就是浅拷贝和深拷贝的问题。假如我们的敌机类里有一颗子弹<code>bullet</code>可以射击我们的主角，如下:</p><pre><code class="java">public class EnemyPlane implements Cloneable{    private Bullet bullet = new Bullet();    private int x;//敌机横坐标    private int y = 0;//敌机纵坐标    //之后代码省略……}</code></pre><p>我们都知道Java中的变量分为原始类型和引用类型，所谓浅拷贝只是拷贝原始类型的指，比如坐标x, y的指会被拷贝到克隆对象中，对于对象<code>bullet</code>也会被拷贝，但是请注意拷贝的只是地址而已，那么多个地址其实真正指向的对象还是同一个<code>bullet</code>。</p><p>由于我们调用父类<code>Object</code>的<code>clone</code>方法进行的是浅拷贝，所以此处的<code>bullet</code>并没有被克隆成功，比如我们每架敌机必须携带的子弹是不同的实例，那么我们就必须进行深拷贝，于是我们的代码就得做这样的改动。</p><pre><code class="java">public class EnemyPlane implements Cloneable{    private Bullet bullet = new Bullet();    public void setBullet(Bullet bullet) {        this.bullet = bullet;    }    @Override    protected EnemyPlane clone() throws CloneNotSupportedException {        EnemyPlane clonePlane = (EnemyPlane) super.clone();//先克隆出敌机，其中子弹还未进行克隆。        clonePlane.setBullet(this.bullet.clone());//对子弹进行深拷贝        return clonePlane;    }    //之后代码省略……}</code></pre><p>对于<code>Bullet</code>类也同样实现了克隆接口，代码不用再写了吧？相信大家都学会了举一反三。至此，我们的每个敌机携带的弹药也同样被克隆完毕了，再也不必担心游戏的流畅性了。</p><h3 id="定义说明-1"><a href="#定义说明-1" class="headerlink" title="定义说明"></a>定义说明</h3><p><strong>定义：</strong></p><p>​    通过复制现有的对象实例来创建新的对象实例。</p><p><strong>实现：</strong></p><p>实现<code>Cloneable</code>接口：<code>Cloneable</code>接口的作用是在运行时通知虚拟机可以安全地在实现了此接口的类上使用<code>clone</code>方法。在Java虚拟机中，只有实现了这个接口的类才可以被拷贝，否则在运行时会抛出<code>CloneNotSupportedException</code>异常。</p><p>重写<code>Object</code>类中的<code>clone</code>方法：Java中，所有类的父类都是<code>Object</code>类，<code>Object</code>类中有一个<code>clone</code>方法，作用是返回对象的一个拷贝，但是其作用域<code>protected</code>类型的，一般的类无法调用，因此，原型类需要将<code>clone</code>方法的作用域修改为<code>public</code>类型。</p><p><strong>优点：</strong></p><ul><li><p>使用原型模型创建一个对象比直接new一个对象更有效率，因为它直接操作内存中的二进制流，特别是复制大对象时，性能的差别非常明显。</p></li><li><p>隐藏了制造新实例的复杂性，使得创建对象就像我们在编辑文档时的复制粘贴一样简单。</p></li></ul><p><strong>缺点：</strong></p><ul><li><p>由于使用原型模式复制对象时不会调用类的构造方法，所以原型模式无法和单例模式组合使用，因为原型类需要将<code>clone</code>方法的作用域修改为<code>public</code>类型，那么单例模式的条件就无法满足了。</p></li><li><p>使用原型模式时不能有final对象。</p></li><li><p><code>Object</code>类的<code>clone</code>方法只会拷贝对象中的基本数据类型，对于数组，引用对象等只能另行拷贝。这里涉及到深拷贝和浅拷贝的概念。</p></li></ul><p><strong>深拷贝与浅拷贝：</strong></p><p>浅拷贝：将一个对象复制后，基本数据类型的变量都会重新创建，而引用类型，指向的还是原对象所指向的（这样不安全）。</p><p>深拷贝：将一个对象复制后，不论是基本数据类型还有引用类型，都是重新创建的。</p><p><strong>适用场景：</strong></p><ul><li><p>复制对象的结构和数据。</p></li><li><p>希望对目标对象的修改不影响既有的原型对象。</p></li><li><p>创建一个对象的成本比较大。</p></li></ul><h2 id="策略（Strategy）"><a href="#策略（Strategy）" class="headerlink" title="策略（Strategy）"></a>策略（Strategy）</h2><h3 id="初步理解-2"><a href="#初步理解-2" class="headerlink" title="初步理解"></a>初步理解</h3><blockquote><p>策略，古时也称“计”，为了达成某个目标的方案，目标不同，方案也随之更改。</p></blockquote><p>例如特工执行任务时总要准备好几套方案以应对突如其来的变化，A计划实施过程中情况突变导致预案无法继续实施，则马上更换为B计划，正所谓计划不如变化快，提前策划固然非常重要，而随机应变更是不可或缺，只有保证这种可变的灵活性才能立于不败之地。世界永远都在变，唯一不变的就是变本身。</p><p>就拿游戏机来举个例子，早期的俄罗斯方块风靡全球，后来国内流行一种掌机，只能玩俄罗斯方块这一个游戏，可过不了多久大家就玩腻了，于是热度降低这种游戏机很快就退出市场了，显然这是一种失败的设计模式。</p><p>后来任天堂出品的<code>Game Boy</code>以及<code>Sony</code>的<code>PSP</code>则完全带来了不同的用户体验，系统提供了统一的卡槽接口，玩家只要更换卡带或MD就可以达到更换游戏的目的，做到了一机多用。各种游戏卡带，更换游戏方便多了。</p><p>好了，开始实战部分，为了说明问题，我们继续发扬极简主义的优良传统，我们就做一个最简单的计算器好了，假设我们的计算器只能进行加减法，代码如下：</p><pre><code class="java">public class Calculator {//违反设计模式原则的做法    public int add(int a, int b){//加法        return a + b;    }    public int sub(int a, int b){//减法        return a - b;    }}</code></pre><p>这样写可以吗？我们往后的扩展想想，如果随着我们的算法不断增加，如乘法、除法、次方、开方等等，那么这个计算器类就得不断的改啊改啊，每次升级算法我们都要把机器给拆开然后更改类代码，这岂不是作死？</p><p>我们来换个思路，先思考一下，既然不能把算法给写死在这里面，那一定要把这个算法给抽象一下，把实现细节从这个类里抽离出来，独立出来成为n个策略，就当下来讲我们一共有俩个策略，一个是加法策略，一个是减法策略，他们实现的都是同一个算法接口，接收参数为操作数a，以及被操作数b。</p><pre><code class="java">public interface Strategy {//算法标准    public int calculate(int a, int b);//操作数，被操作数}</code></pre><p>下来实现加法策略、减法策略。</p><pre><code class="java">public class Addition implements Strategy{//实现算法接口    @Override    public int calculate(int a, int b) {//加数与被加数        return a + b;//这里我们做加法运算    }}public class Subtraction implements Strategy{//实现算法接口    @Override    public int calculate(int a, int b) {//减数与被减数        return a - b;//这里我们做减法运算    }}</code></pre><p>算法写好了，开始写计算器。</p><pre><code class="java">public class Calculator {//计算器类    private Strategy strategy;//拥有某种算法策略    public void setStrategy(Strategy strategy) {//接入算法策略        this.strategy = strategy;    }    public int getResult(int a, int b){        return this.strategy.calculate(a, b);//返回具体策略的结果    }}</code></pre><p>可以看到，计算器类里已经把之前的具体加减算法实现代码给剥离出去了，要用哪个算法，只需要注入进来，然后获得计算结果<code>getResult</code>实际上调用的是具体算法的<code>calculate</code>，我们来看怎样使用这个计算器。</p><pre><code class="java">public class Client {    public static void main(String[] args) {        Calculator calculator = new Calculator();//实例化计算器        calculator.setStrategy(new Addition());//接入加法实现        int result = calculator.getResult(1, 1);//计算！        System.out.println(result);//得到的是加法结果2        calculator.setStrategy(new Subtraction());//再次接入减法实现        result = calculator.getResult(1, 1);//计算！        System.out.println(result);//得到的是减法结果0    }}</code></pre><p>注释已经写得非常明白了，相信大家都看懂了吧。那么我们这个计算器可以说是具有算法策略扩展性的，以后要有新的算法是不需要再更改任何现有代码的，只需要新写一个算法比如乘法<code>Multiplication</code>，并实现<code>calculate</code>方法，接下来要做的只是组装上去便可以使用了。</p><h3 id="定义说明-2"><a href="#定义说明-2" class="headerlink" title="定义说明"></a>定义说明</h3><p><strong>定义：</strong>定义一组算法，将每个算法都封装起来，并且使他们之间可以互换。</p><p>策略模式是对算法的封装，把一系列的算法分别封装到对应的类中，并且这些类实现相同的接口，相互之间可以替换。在前面说过的行为类模式中，有一种模式也是关注对算法的封装——模版方法模式。</p><p>它与模版方法模式的区别在于：在模版方法模式中，调用算法的主体在抽象的父类中，而在策略模式中，调用算法的主体则是封装到了封装类<code>Context</code>中，抽象策略一般是一个接口，目的只是为了定义规范，里面一般不包含逻辑。</p><p>其实，这只是通用实现，而在实际编程中，因为各个具体策略实现类之间难免存在一些相同的逻辑，为了避免重复的代码，我们常常使用抽象类来担任<code>Strategy</code>的角色，在里面封装公共的代码，因此，在很多应用的场景中，在策略模式中一般会看到模版方法模式的影子。</p><p><strong>策略模式的结构</strong></p><ul><li><strong>封装类：</strong>也叫上下文，对策略进行二次封装，目的是避免高层模块对策略的直接调用。</li><li><strong>抽象策略：</strong>通常情况下为一个接口，当各个实现类中存在着重复的逻辑时，则使用抽象类来封装这部分公共的代码，此时，策略模式看上去更像是模版方法模式。</li><li><strong>具体策略：</strong>具体策略角色通常由一组封装了算法的类来担任，这些类之间可以根据需要自由替换。</li></ul><p><strong>策略模式的优缺点</strong></p><p>​    策略模式的主要优点有：</p><ul><li>策略类之间可以自由切换，由于策略类实现自同一个抽象，所以他们之间可以自由切换。</li><li>易于扩展，增加一个新的策略对策略模式来说非常容易，基本上可以在不改变原有代码的基础上进行扩展。</li><li>避免使用多重条件，如果不使用策略模式，对于所有的算法，必须使用条件语句进行连接，通过条件判断来决定使用哪一种算法，在上一篇文章中我们已经提到，使用多重条件判断是非常不容易维护的。</li></ul><p>​    策略模式的缺点主要有两个：</p><ul><li>维护各个策略类会给开发带来额外开销，可能大家在这方面都有经验：一般来说，策略类的数量超过5个，就比较令人头疼了。</li><li>必须对客户端（调用者）暴露所有的策略类，因为使用哪种策略是由客户端来决定的，因此，客户端应该知道有什么策略，并且了解各种策略之间的区别，否则，后果很严重。例如，有一个排序算法的策略模式，提供了快速排序、冒泡排序、选择排序这三种算法，客户端在使用这些算法之前，是不是先要明白这三种算法的适用情况？再比如，客户端要使用一个容器，有链表实现的，也有数组实现的，客户端是不是也要明白链表和数组有什么区别？就这一点来说是有悖于迪米特法则的。 </li></ul><p><strong>适用场景</strong></p><p>做面向对象设计的，对策略模式一定很熟悉，因为它实质上就是面向对象中的继承和多态，在看完策略模式的通用代码后，我想，即使之前从来没有听说过策略模式，在开发过程中也一定使用过它吧？至少在在以下两种情况下，大家可以考虑使用策略模式：</p><ul><li>几个类的主要逻辑相同，只在部分逻辑的算法和行为上稍有区别的情况。</li><li>有几种相似的行为，或者说算法，客户端需要动态地决定使用哪一种，那么可以使用策略模式，将这些算法封装起来供客户端调用。</li></ul><p>策略模式是一种简单常用的模式，我们在进行开发的时候，会经常有意无意地使用它，一般来说，策略模式不会单独使用，跟模版方法模式、工厂模式等混合使用的情况比较多。</p><h2 id="状态（State）"><a href="#状态（State）" class="headerlink" title="状态（State）"></a>状态（State）</h2><h3 id="初步理解-3"><a href="#初步理解-3" class="headerlink" title="初步理解"></a>初步理解</h3><p>状态，指某事物所处的状况或形态，比如水的三态，零下会变成固态冰，常温会是液态水，100℃会蒸发成气态的水蒸气。</p><p>想必每个人家里都有开关吧，其暴露出两个<code>UI</code>可操作接口（对接你的手指）：开，关。很简单吧？</p><p>好我们来分析一下，首先得定义一个类吧，就叫它：<code>Switcher</code>好了，对外暴露两个方法：<code>switchOn()</code>以及<code>switchOff()</code>，以便用户调用，OK，开始我们的代码。</p><pre><code class="java"> public class Switcher {    //false代表关，true代表开    private boolean state = false;//初始状态是关    public void switchOn(){         state = !state;         System.out.println(&quot;OK...灯亮&quot;);    }    public void switchOff(){        state = !state;        System.out.println(&quot;OK...灯灭&quot;);    }}</code></pre><p>完成了？没问题了？这也太简单了吧？当然说这个没问题是在前端UI壳子设计精妙的前提下，但这并不能代表我们的程序设计没问题。试想如果<code>UI</code>可以重复调用开或者关会出现什么情况？状态乱套了！这个设计是非常不可靠的，我们不能因为表面设计上的完美就忽略了后端代码功能的逻辑正确性，表里不一。这就是为什么我们做应用时不但要做好前端校验（用户体验），更要保证后端校验（功能正确性）不可缺失。</p><p>现在改一下我们之前的设计，这里一定要加入针对当前状态的条件判断，也就是说，开的状态不能再开，关的状态不能再关！</p><pre><code class="java">public class Switcher {    //false代表关，true代表开    boolean state = false;//初始状态是关    public void switchOn(){        if(state == false){//当前是关状态            state = true;            System.out.println(&quot;OK...灯亮&quot;);        }else{//当前是开状态            System.out.println(&quot;WARN!!!通电状态无需再开&quot;);        }    }    public void switchOff(){        if(state == true){//当前是开状态            state = false;            System.out.println(&quot;OK...灯灭&quot;);        }else{//当前是关状态            System.out.println(&quot;WARN!!!断电状态无需再关&quot;);        }    }}</code></pre><p>我们可以看到这里加入了逻辑判断，如果重复开或者重复关的话是会告警的，当然这里也可以抛异常出去，我们就不搞那么复杂化了。那对于这样的设计没有问题吧？很显然，逻辑上是跑的通的，写个<code>Client</code>类测试一下。</p><pre><code class="java">public class Client {    public static void main(String[] args) {        Switcher s = new Switcher();        s.switchOff();//WARN!!!断电状态无需再关        s.switchOn();//OK...灯亮        s.switchOff();//OK...灯灭        s.switchOn();//OK...灯亮        s.switchOn();//WARN!!!通电状态无需再开    }}</code></pre><p>不管熊孩子怎么开开关关都不会有问题了。可惜我还是要很遗憾地告诉你，这样的设计仍然是糟糕的。试想，如果状态不止一种，并且状态切换有及其复杂的逻辑，例如，之前那个精神病患者，或者汽车的自动挡。</p><p>如果按照这种设计的结果会是？码农一定要有一种打破砂锅问到底的精神，不撞南墙不回头，Lu起袖子马上干！我们写一小段代码来看看先。</p><pre><code class="java">public class Car {    //0：Park驻车档，1：Reverse倒退挡，    //2：Neutral空挡，3：Drive前进档。    String state = &quot;P&quot;;//初始状态是P档    public void push(){//向上推档杆        switch (state) {        case &quot;P&quot;://驻车档状态            System.out.println(&quot;WARN!!!到头了推不动了！&quot;);            break;        case &quot;R&quot;://倒挡状态            state = &quot;P&quot;;            System.out.println(&quot;OK...切P档&quot;);            break;        case &quot;N&quot;://空档状态            System.out.println(&quot;OK...切R档&quot;);            break;        case &quot;D&quot;://前进档状态            System.out.println(&quot;OK...切N档&quot;);            break;        default:            break;        }    }    public void pull(){//向下拉档杆        //这里省略，逻辑同上类似    }}</code></pre><p>不用多说什么了吧，这个是在作死了，那一大堆逻辑判断写在宿主类里会越来越像蜘蛛网！我们必须想方设法把这个设计给模块化，把状态模块给独立出来！还记得我们曾经讲过的 <a href="#策略（Strategy）">策略</a> 吧，算法策略被抽离出来，这里举一反三，把状态也给抽离出来，好了办法有了，我们忘掉自动挡，继续用我们大道至简的开关例子。</p><pre><code class="java">public interface State {    public void switchOn(Switcher switcher);//开    public void switchOff(Switcher switcher);//关}</code></pre><p>以上我们首先了定义一个状态State接口，两个方法开与关，注意这里与策略模式不同的是，我们为了与宿主<code>Switcher</code>对接所以把它作为参数传入。然后是开状态与关状态的实现。</p><pre><code class="java">public class On implements State {    @Override    public void switchOn(Switcher switcher) {        System.out.println(&quot;WARN!!!通电状态无需再开&quot;);        return;    }    @Override    public void switchOff(Switcher switcher) {        switcher.setState(new Off());        System.out.println(&quot;OK...灯灭&quot;);    }}</code></pre><pre><code class="java">public class Off implements State {    @Override    public void switchOn(Switcher switcher) {        switcher.setState(new On());        System.out.println(&quot;OK...灯亮&quot;);    }    @Override    public void switchOff(Switcher switcher) {        System.out.println(&quot;WARN!!!断电状态无需再关&quot;);        return;    }}</code></pre><p>显而易见，注意看第10行代码，开状态不能做开行为，只告警并返回，关状态反之亦然。而第4行代码则是合法的行为，所以可以进行状态切换并实施相应行为，也就是说，开状态可关，关状态可开。注意这里是把宿主对象传入进来用于切换其当前状态，亦或是调用宿主的具体功能方法（这里省略用打印输出代替），比如宿主里的一盏灯提供的方法。</p><p>至此，一切看起来非常优雅，我们已经成功的将状态从宿主中抽离了，最后再来看宿主开关类是什么样子。</p><pre><code class="java">public class Switcher {    //开关的初始状态设置为“关”    private State state = new Off();    public State getState() {        return state;    }    public void setState(State state) {        this.state = state;    }    public void switchOn(){        state.switchOn(this);//这里调用的是当前状态的开方法    }    public void switchOff(){        state.switchOff(this);//这里调用的是当前状态的关方法    }}</code></pre><p>甚至我们还可以给里面加一盏灯，像之前我们提到的那样，在<code>State</code>状态接口实现里去调用。</p><pre><code class="java">public class Switcher {    //...之上代码略...    private Lamp lamp;    public void lampOn(){    lamp.on();    }    public void lampOff(){    lamp.off();    }}</code></pre><p>看明白了吧？是不是很像策略模式？其实它就是策略的一个变种，只不过状态模式会更好的根据当前的状态去实施不同的行为，并且自主切换到另一个正确的状态，开变关，关变开。</p><p>就好似电梯（虽然是嵌入式面向过程，这里只是举例），用户根本无法随意强制更改其状态以及行为，你让它上，它不一定马上就能上，否则会造成事故。电梯内部封装了多个状态以及对应的逻辑产生不同的行为，它会根据当前状态去自我调整并实施最优方案，以达到安全、高效的目的，这才是可靠的设计。</p><h3 id="定义说明-3"><a href="#定义说明-3" class="headerlink" title="定义说明"></a>定义说明</h3><p><strong>概述</strong></p><p>  当系统中某个对象存在多个状态，这些状态之间可以进行转换，而且对象在不同状态下行为不相同时可以使用状态模式。状态模式将一个对象的状态从该对象中分离出来，封装到专门的状态类中，使得对象状态可以灵活变化。状态模式是一种对象行为型模式。</p><p><strong>适用场景</strong></p><p>用于解决系统中复杂对象的多种状态转换以及不同状态下行为的封装问题。简单说就是处理对象的多种状态及其相互转换</p><p><strong>参与者</strong></p><p><strong>1&gt;、AbstractState(抽象状态类):</strong></p><p>​    在抽象状态类中定义申明了不同状态下的行为抽象方法，而由子类(不同的状态子类)中实现不同的行为操作。</p><p><strong>2&gt;、ConcreteState(实现具体状态下行为的状态子类):</strong></p><p>​    抽象状态类的子类，每一个子类实现一个与环境类(<code>Context</code>)的一个状态相关的行为，每一个具体的状态类对应环境的一种具体状态，不同的具体状态其行为有所不同。</p><p><strong>3&gt;、Context(拥有状态对象的环境类):</strong></p><p>​    拥有状态属性，因环境的多样性，它可拥有不同的状态，且在不同状态下行为也不一样。在环境类中维护一个抽象的状态实例，这个实例定义当前环境的状态(<code>setState()</code>方法)，而将具体的状态行为分离出来由不同的状态子类去完成。</p><h2 id="模板方法（Template）"><a href="#模板方法（Template）" class="headerlink" title="模板方法（Template）"></a>模板方法（Template）</h2><h3 id="初步理解-4"><a href="#初步理解-4" class="headerlink" title="初步理解"></a>初步理解</h3><p>面向对象，是对事物属性与行为的封装，方法，指的就是行为。模板方法，显而易见是说某个方法充当了模板的作用，其充分利用了抽象类虚实结合的特性，虚部抽象预留，实部固定延续，以达到将某种固有行为延续至子类的目的。反观接口，则达不到这种目的。要搞明白模板方法，首先我们从接口与抽象类的区别切入，这也是面试官经常会问到的问题。</p><p>汽车上的接口最常见的就是点烟器，USB，AUX等等，很明显这些都是接口，它们都预留了某种标准，暴露在系统外部，并与外设对接。就拿点烟器接口来说吧，它原本是专门用于给点烟器供电的，后来由于这个接口在汽车上的通用性，于是衍生出了各种外部设备，只要是符合这个标准大小的，带正负极簧片的，直流12V的，那就可以使用，比如导航、行车记录仪、吸尘器什么的，以及其他各种车载电子设备。</p><pre><code class="java">public interface CigarLighterInterface {//点烟器接口    //供电方法，16V直流电    public void electrifyDC16V();}</code></pre><pre><code class="java">public class GPS implements CigarLighterInterface {    //导航的实现    @Override    public void electrifyDC16V() {        System.out.println(&quot;连接卫星&quot;);        System.out.println(&quot;定位。。。&quot;);    }}public class CigarLighter implements CigarLighterInterface {    //点烟器的实现    @Override    public void electrifyDC16V() {        int time = 1000;        while(--time&gt;0){            System.out.println(&quot;加热电炉丝&quot;);        }        System.out.println(&quot;点烟器弹出&quot;);    }}</code></pre><p>对于点烟器接口来说，它根本不在乎也不知道对接的外设是什么鬼，它只是定义了一种规范，一种标准，只要符合的都可以对接。</p><p>以上我们可以体会到接口的抽象是淋漓尽致的，实现是空无的，也就是说其方法都是无实现的。然而这样在某些场景下会存在一些问题，例如有时候我们在父类中只需抽象出一些方法，并且同时也有一些实体方法，以供子类直接继承，这怎么办？答案就是抽象类。举个例子，哺乳动物类，我们人类就是哺乳动物。</p><p>什么？鲸鱼是哺乳类？是的，凡是喂奶的都是哺乳类，不要以为会游泳的都是鱼，会飞的都是鸟，蝙蝠同样是哺乳类，只不过是老鼠中的飞行员而已。</p><p>既然如此这哺乳动物肯定是都能喂奶了，但是到底是跑还是游，或是飞呢还真不好说，但至少可以确认它们都是可以移动的。言归正传，我们开始定义哺乳动物抽象类。</p><pre><code class="java">public abstract class Mammal {    //既然是哺乳动物当然会喂奶了，但这里约束为只能母的喂奶    protected final void feedMilk(){        if(female){//如果是母的……            System.out.println(&quot;喂奶&quot;);        }else{//如果是公的……或者可以抛个异常出去。            System.out.println(&quot;公的不会&quot;);        }    }    //哺乳动物当然可以移动，但具体怎么移动还不知道。    public abstract void move();}</code></pre><p>这里我们省略了female属性，其作用是为了控制喂奶行为，大家可以自行添加。可以看到的是，抽象类不同于接口，其自身是可以有具体实现的，也就是说抽象类是虚实结合的，虚部抽象行为，实部遗传给子类，虚虚实实，飘忽不定。OK，我们看下人、鲸、蝠的子类实现。</p><pre><code class="java">public class Human extends Mammal {    @Override    public void move() {        System.out.println(&quot;两条腿走路……&quot;);    }}public class Whale extends Mammal {    @Override    public void move() {        System.out.println(&quot;游泳……&quot;);    }}public class Bat extends Mammal {    @Override    public void move() {        System.out.println(&quot;用翅膀飞……&quot;);    }}</code></pre><p>可以看到子类的各路实现都是自己独有的行为方式，而喂奶那个行为是不需要自己实现的，它是属于抽象哺乳类的共有行为，哺乳子类不能进行任何干涉。这便是接口与抽象的最大区别了，接口是虚的，抽象类可以有虚有实，接口不在乎实现类是什么，抽象类会延续其基因给子类。</p><p>其实到这里我们已经说了一大半了，理解了以上部分，剩下的部分就非常简单了，利用抽象类的这个特性，便有了“模板方法”。举例说明，我们做软件项目管理，按瀑布式简单来讲分为：需求分析、设计、编码、测试、发布，先不管是用何种方式去实现各个细节，我们就抽象成这五个步骤。</p><pre><code class="java">public abstract class PM {    protected abstract void analyze();//需求分析    protected abstract void design();//设计    protected abstract void develop();//开发    protected abstract boolean test();//测试    protected abstract void release();//发布}</code></pre><p>那么问题来了，有个程序员在需求不明确或者设计不完善的情况下，一上来二话不说直接写代码，这样就会造成资源的浪费，后期改动太大还会影响项目进度。那么项目经理这时就应该规范一下这个任务流程，这里我们加入kickoff()方法实现。</p><pre><code class="java">public abstract class PM {    protected abstract void analyze();//需求分析    protected abstract void design();//设计    protected abstract void develop();//开发    protected abstract boolean test();//测试    protected abstract void release();//发布    protected final void kickoff(){        analyze();        design();        develop();        test();        release();    }}</code></pre><p>这样就限制了整个项目周期的任务流程，注意这里要用final声明此方法子类不可以重写，只能乖乖的继承下去用。至于其他的抽象方法，子类可以自由发挥，比如测试方法<code>test()</code>，子类可以用人工测试，自动化测试，我们不关心，我们是站在项目管理的抽象高度，只把控流程进度。这里甚至我们还可以加入一些逻辑如下。</p><pre><code class="java">public abstract class PM {    protected abstract void analyze();//需求分析    protected abstract void design();//设计    protected abstract void develop();//开发    protected abstract boolean test();//测试    protected abstract void release();//发布    protected final void kickoff(){        analyze();        design();        do {            develop();        } while (!test());//如果测试失败，则继续开发改Bug。        release();    }}</code></pre><p>以下子类只需实现抽象方法，而不用实现固有的模板方法kickoff()，因为它已经被父类PM实现了，并且子类也不能进行重写。</p><pre><code class="java">public class AutoTestPM extends PM{    @Override    protected void analyze() {        System.out.println(&quot;进行业务沟通，需求分析&quot;);         }    //design();develop();test();release();实现省略}</code></pre><p>至此，我们的模板方法就完成了，抽象类<code>PM</code>中的实方法<code>kickoff()</code>中，以某种逻辑编排调用了其他各个抽象方法，提供了一种固定模式的行为方式或是指导方针，以此达到虚实结合、柔中带刚、刚柔并济，灵活中不失规范的目的。</p><p>当然大部分情况我们使用接口会多于抽象类，因为接口灵活啊，抽象类不允许多继承啊等等，其实我们还是要看应用场景，在某种无规矩不成方圆，或者规范比较明确，的情况下抽象类的应用是有必要的，世间万物没有最好的，只有最合适的。</p><h3 id="定义说明-4"><a href="#定义说明-4" class="headerlink" title="定义说明"></a>定义说明</h3><p><strong>定义：</strong>定义一个操作中算法的框架，而将一些步骤延迟到子类中，使得子类可以不改变算法的结构即可重定义该算法中的某些特定步骤。</p><p><strong>模版方法模式的结构</strong></p><p>模版方法模式由一个抽象类和一个（或一组）实现类通过继承结构组成，抽象类中的方法分为三种：</p><ul><li><p><strong>抽象方法：</strong>父类中只声明但不加以实现，而是定义好规范，然后由它的子类去实现。</p></li><li><p><strong>模版方法：</strong>由抽象类声明并加以实现。一般来说，模版方法调用抽象方法来完成主要的逻辑功能，并且，模版方法大多会定义为final类型，指明主要的逻辑功能在子类中不能被重写。</p></li><li><p><strong>钩子方法：</strong>由抽象类声明并加以实现。但是子类可以去扩展，子类可以通过扩展钩子方法来影响模版方法的逻辑。</p></li></ul><p>抽象类的任务是搭建逻辑的框架，通常由经验丰富的人员编写，因为抽象类的好坏直接决定了程序是否稳定性。</p><p>实现类用来实现细节。抽象类中的模版方法正是通过实现类扩展的方法来完成业务逻辑。只要实现类中的扩展方法通过了单元测试，在模版方法正确的前提下，整体功能一般不会出现大的错误。</p><p><strong>模版方法的优点及适用场景</strong></p><p><strong>容易扩展。</strong>一般来说，抽象类中的模版方法是不易反生改变的部分，而抽象方法是容易反生变化的部分，因此通过增加实现类一般可以很容易实现功能的扩展，符合开闭原则。</p><p><strong>便于维护。</strong>对于模版方法模式来说，正是由于他们的主要逻辑相同，才使用了模版方法，假如不使用模版方法，任由这些相同的代码散乱的分布在不同的类中，维护起来是非常不方便的。</p><p><strong>比较灵活。</strong>因为有钩子方法，因此，子类的实现也可以影响父类中主逻辑的运行。但是，在灵活的同时，由于子类影响到了父类，违反了里氏替换原则，也会给程序带来风险。这就对抽象类的设计有了更高的要求。</p><p>在多个子类拥有相同的方法，并且这些方法逻辑相同时，可以考虑使用模版方法模式。在程序的主框架相同，细节不同的场合下，也比较适合使用这种模式。</p><h2 id="门面-外观（Facade）"><a href="#门面-外观（Facade）" class="headerlink" title="门面/外观（Facade）"></a>门面/外观（Facade）</h2><h3 id="初步理解-5"><a href="#初步理解-5" class="headerlink" title="初步理解"></a>初步理解</h3><p>开门见山，门，建筑物的入口，面，脸也。门面，通常指店铺的门头外表部分，当然一定要临街才是好的商铺，在人流量大的地方营造更好的视觉冲击，这样会有更多等等机会暴露给潜在顾客，否则只能是靠“酒香不怕巷子深”，靠味道来吸引人了。</p><p>当然除了光鲜亮丽的外表，更重要的是门店提供的服务了。就拿餐饮来举例吧，如果没有这些门店我们都怎样吃饭呢？我们自己做又不会，算了还是找女友下厨吧。很简单分三步走，首先找菜贩买菜，其次女友下厨，最后吃完洗碗，打完收工代码如下:</p><pre><code class="java">public class VegVendor {//菜贩子    public void sell(){    System.out.println(&quot;菜贩子卖菜。。。&quot;);    }}public class GirlFriend {//女友    public void cook(){    System.out.println(&quot;女友烹饪。。。&quot;);    }}public class Me {    public void eat(){    System.out.println(&quot;我只会吃。。。&quot;);    }    public static void main(String[] args) {        //找菜贩子买菜        VegVendor vv = new VegVendor();        vv.sell();        //找女友做饭        GirlFriend gf = new GirlFriend();        gf.cook();        //我只会吃        Me me = new Me();        me.eat();        //谁洗碗呢？一场战场一触即发……    }}</code></pre><p>其实我们不该找女友做饭的，而是应该雇一个专业厨师，可这下来得多大花费啊，太划不来了，也许还得我们自己洗碗……哎。其实我们也不想麻烦，还是找门店来解决吧，至于那些买菜啊，烹饪啊，洗碗收拾桌子啊我们统统都不用管了，门店可以进行资源整合与调度，这样我们吃饭就变得如此简单了，只需要付钱就行了，毕竟我们只会吃。</p><pre><code class="java">public class Facade {    private VegVendor vv;    private Chef chef;    private Waiter waiter;    private Cleaner cleaner;    public Facade() {        this.vv = new VegVendor();        //开门前就找菜贩子准备好蔬菜        vv.sell();        //当然还得雇佣好各类饭店服务人员        this.chef = new Chef();        this.waiter = new Waiter();        this.cleaner = new Cleaner();    }    public void provideService(){        //接待，入座，点菜        waiter.order();        //找厨师做饭        chef.cook();        //上菜        waiter.serve();        //收拾桌子，洗碗，以及其他工序……        cleaner.clean();        cleaner.wash();    }}</code></pre><p>这下可爽了，我们再也不用去花费时间去调动那么多资源，又是出门买菜，又是找女友做菜，洗碗擦桌什么的。所以我们急需一个门面来解决这些问题，如果没有门面的话，试想每家每户每顿都做饭的话，于是我们放弃我们的专业优势，整天花很长时间做饭才能不饿肚子。</p><p>其实这就是门面模式的用法了，门面就是一个大系统，里面封装了很多的子部件（或子系统），部件之间也许有复杂的逻辑关系，对于我们旁观者来说，直接使用这些子部件是非常麻烦的一件事情，所以门面就充当了一个包装类的角色，并且对外暴露一个接口，达到简化客户操作的目的，同时也是对客户端与子系统之间的解耦。</p><h3 id="定义说明-5"><a href="#定义说明-5" class="headerlink" title="定义说明"></a>定义说明</h3><p><strong>定义：</strong></p><p>为子系统中的一组接口提供一个一致的界面，<code>Facade</code>模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</p><p><strong>角色：</strong></p><ul><li><p>外观(<code>Facade</code>)角色 ：客户端可以调用这个角色的方法。此角色知晓相关子系统的功能和责任。在正常情况下，本角色会将所有从客户端发来的请求委派到相应的子系统去。</p></li><li><p>子系统(<code>SubSystem</code>)角色 ：可以同时有一个或者多个子系统。每个子系统都不是一个单独的类，而是一个类的集合。每个子系统都可以被客户端直接调用，或者被外观角色调用。子系统并不知道外观角色的存在，对于子系统而言，外观角色仅仅是另外一个客户端而已。</p><p><code>Facade</code>类其实相当于子系统中<code>SubClass</code>类的外观界面，有了这个<code>Facade</code>类，那么客户端就不需要亲自调用子系统中的那些具体实现的子类了，也不需要知道系统内部的实现细节，甚至都不需要知道这些子类的存在，客户端只需要跟<code>Facade</code>类交互就好了，从而更好地实现了客户端和子系统中具体类的解耦，让客户端更容易地使用系统。</p></li></ul><p>同时，这样定义一个<code>Facade</code>类可以有效地屏蔽内部的细节，免得客户端去调用<code>Module</code>类时，发现一些不需要它知道的方法。如上代码，我的所有子类中的方法二都是方法一调用的方法，是配合方法一的，他们不需要被客户端调用，而且具有一定的保密性，这样使用外观模式时就可以不被客户端知道。</p><p><strong>优点：</strong></p><p>实现了子系统与客户端之间的松耦合关系。</p><p>客户端屏蔽了子系统组件，减少了客户端所需处理的对象数目，并使得子系统使用起来更加容易。</p><p><strong>适用场景：</strong></p><p>设计初期阶段，应该有意识的将不同层分离，层与层之间建立外观模式。</p><p>开发阶段，子系统越来越复杂，增加外观模式提供一个简单的调用接口。</p><p>维护一个大型遗留系统的时候，可能这个系统已经非常难以维护和扩展，但又包含非常重要的功能，为其开发一个外观类，以便新系统与其交互。</p><p><strong>外观模式总结：</strong></p><ul><li><p>外观模式为复杂子系统提供了一个简单接口，并不为子系统添加新的功能和行为。</p></li><li><p>外观模式实现了子系统与客户端之间的松耦合关系。 </p></li><li><p>外观模式没有封装子系统的类，只是提供了简单的接口。 如果应用需要，它并不限制客户使用子系统类。因此可以灵活的在系统易用性与通用性之间选择。</p></li><li><p>外观模式注重的是简化接口，它更多的时候是从架构的层次去看整个系统，而并非单个类的层次。</p></li></ul><h2 id="组合（Combinations）"><a href="#组合（Combinations）" class="headerlink" title="组合（Combinations）"></a>组合（Combinations）</h2><h3 id="初步理解-6"><a href="#初步理解-6" class="headerlink" title="初步理解"></a>初步理解</h3><p>组合，由于事物与事物之间存在某种关系，进而组织起来并形成某种结构并且可以共同发挥作用。组合模式所应用的就是树形结构以表达“部分/整体”的层次结构。相信我们都知道“二叉树”结构吧，根部分出来两个枝杈（左节点，右节点），每个枝杈上又可以继续分叉，直到末端的叶子为止。</p><p>当然，二叉树算是最简单的树了，其实大自然中更多的是多叉树结构，一片简单的叶子。仔细观察我们会发现叶子上又有小的枝叶，一个小的枝叶上又有更小的枝叶。我们不管从宏观还是微观维度上看都是类似的结构，这正取决于植物的DNA，无论在哪个维度上都是相同的生长方式。冥冥之中，好似存在着某种大自然的规律，类似的结构总是在重复、迭代地显现出某种自似性。</p><p>从简单到复杂，或是复杂到简单，我们抽出任意一个“部分”，其与“整体”的结构是类似的。所以，上面提到的“树”结构，无论是根、枝、还是叶子，我们都统统把他们抽象地称为“节点”，模糊他们的行为差异，这样我们便可以达到模糊简单元素与复杂元素的目的。好了，开始代码部分，这里我们就拿类似树结构的文件系统目录结构来举例吧。</p><p>从根目录开始分支，下面可以包含文件夹或者文件，文件夹下面可以继续存放子文件夹或文件，而文件则属于“叶子”节点，下面不再有延续分支。不管三七二十一，我们笼统地把他们都抽象成”节点“。</p><pre><code class="java">public abstract class Node {    protected String name;//节点命名    public Node(String name) {//构造节点，传入节点名。        this.name = name;    }    //增加后续子节点方法    protected abstract void add(Node child);}</code></pre><p>每个文件夹或文件都应该有一个名字，并且新建时必须声明，所以在构造的时候必须传入名字。第9行添加子节点方法我们做成抽象的，模糊其添加行为并留给子类去实现。下面添加文件夹类并继承自抽象节点。</p><pre><code class="java">public class Folder extends Node{    //文件夹可以包含子节点（文件夹或者文件）。    private List&lt;Node&gt; childrenNodes = new ArrayList&lt;&gt;();    public Folder(String name) {        super(name);//调用父类“节点”的构造方法命名。    }    @Override    protected void add(Node child) {        childrenNodes.add(child);//可以添加子节点。    }}</code></pre><p>作为文件夹类，我们承载着树型结构的重任，所以这里第3行我们的文件夹类封装了一个子节点的List，重点在于这里模糊了其下文件夹或文件的概念，也就是说这个文件夹既可以包含子文件夹，又可以包含文件。第5行的构造方法我们则交给父类构造完成，至于第10行的添加子节点方法，作为文件夹类当然是需要实现的。反之作为叶子节点的文件类，是不具备添加子节点功能的，看代码。</p><pre><code class="java">public class File extends Node{    public File(String name) {        super(name);    }    @Override    protected void add(Node child) {        System.out.println(&quot;不能添加子节点。&quot;);    }}</code></pre><p>可以看到第9行我们在这里实现了添加子节点方法并打印输出一句错误信息告知用户“不能添加子节点”，其实更合适的做法是在此处抛出异常信息。一切就绪，我们可以构建目录并添加文件了。</p><pre><code class="java">public class Client {    public static void main(String[] args) {        Node driveD = new Folder(&quot;D盘&quot;);        Node doc = new Folder(&quot;文档&quot;);        doc.add(new File(&quot;简历.doc&quot;));        doc.add(new File(&quot;项目介绍.ppt&quot;));        driveD.add(doc);        Node music = new Folder(&quot;音乐&quot;);        Node jay = new Folder(&quot;周杰伦&quot;);        jay.add(new File(&quot;双截棍.mp3&quot;));        jay.add(new File(&quot;告白气球.mp3&quot;));        jay.add(new File(&quot;听妈妈的话.mp3&quot;));        Node jack = new Folder(&quot;张学友&quot;);        jack.add(new File(&quot;吻别.mp3&quot;));        jack.add(new File(&quot;一千个伤心的理由.mp3&quot;));        music.add(jay);        music.add(jack);        driveD.add(music);    }}</code></pre><p>至此，我们已经告一段落了，我们将目录结构规划的非常好，以便对各种文件进行分类管理以便日后查找。不止于此，我们这里再做一些扩展，比如用户需要列出当前目录下的所有子目录及文件。</p><pre><code class="java">public abstract class Node {    protected String name;//节点命名    public Node(String name) {//构造节点，传入节点名。        this.name = name;    }    //增加后续子节点方法    protected abstract void add(Node child);    protected void ls(int space){        for (int i = 0; i &lt; space; i++) {            System.out.print(&quot;　&quot;);//先循环输出n个空格；        }        System.out.println(name);//然后再打印自己的名字。    }}</code></pre><p>这里从第11行开始加入的ls方法不做抽象，而只实现出文件夹与文件相同的行为片段，至于“不同”的行为片段则在子类中实现。</p><pre><code class="java">public class File extends Node{    public File(String name) {        super(name);    }    @Override    protected void add(Node child) {        System.out.println(&quot;不能添加子节点。&quot;);    }    @Override    public void ls(int space){        super.ls(space);    }}</code></pre><p>文件类的实现与父类完全一致，第13行开始直接调用父类继承下来的ls方法即可。而文件夹类则比较特殊了，不但要列出自己的名字，还要列出子节点的名字。</p><pre><code class="java">public class Folder extends Node{    //文件夹可以包含子节点（文件夹或者文件）。    private List&lt;Node&gt; childrenNodes = new ArrayList&lt;&gt;();    public Folder(String name) {        super(name);//调用父类“节点”的构造方法命名。    }    @Override    protected void add(Node child) {        childrenNodes.add(child);//可以添加子节点。    }    @Override    public void ls(int space){        super.ls(space);//调用父类共通的ls方法列出自己的名字。        space++;//之后列出的子节点前，空格数要增加一个了。        for (Node node : childrenNodes) {           node.ls(space);//调用子节点的ls方法。        }    }}</code></pre><p>自第15行开始，文件夹的<code>ls</code>方法先调用父类共通的<code>ls</code>方法列出自己的名字，然后再把空格数加1并传给下一级的所有子节点，循环迭代，直至抵达叶子则返回调用之初，完美的抽象递归。</p><p>最后，我们的<code>client</code>在任何一级节点上只要调用<code>ls(int space)</code>，并传入当前目录的偏移量（空格数）即可出现之前的树形列表了，比如挨着左边框显示：<code>ls(0)</code>。或者我们干脆给用户再增加一个无参数重载方法，内部直接调用<code>ls(0)</code>即可。</p><pre><code class="java">public abstract class Node {    protected String name;//节点命名    public Node(String name) {//构造节点，传入节点名。        this.name = name;    }    //增加后续子节点方法    protected abstract void add(Node child);    protected void ls(int space){        for (int i = 0; i &lt; space; i++) {            System.out.print(&quot;　&quot;);//先循环输出n个空格；        }        System.out.println(name);//然后再打印自己的名字。    }    //无参重载方法，默认从第0列开始显示。    protected void ls(){        this.ls(0);    }}</code></pre><p>这样用户可以抛开烦扰，直接调用<code>ls()</code>便是。</p><h3 id="定义说明-6"><a href="#定义说明-6" class="headerlink" title="定义说明"></a>定义说明</h3><p><strong>介绍</strong></p><p>组合模式又叫做部分-整体模式,它使我们树型结构的问题中,模糊了简单元素和复杂元素的概念,客户程序可以向处理简单元素一样来处理复杂元素,从而使得客户程序与复杂元素的内部结构解藕。</p><p>组合模式可以优化处理递归或分级数据结构.有许多关于分级数据结构的例子,使得组合模式非常有用武之地。</p><p><strong>组成部分：</strong><br><code>Component</code>: 为参加组合的对象声明一个公共接口, 不管是组合还是叶结点。<br><code>Leaf</code>: 在组合中表示叶子结点对象,叶子结点没有子结点。<br><code>Composite</code>: 表示参加组合的有子对象的对象, 并给出树枝购件的行为。</p><p><strong>使用场景</strong></p><p>以下情况下适用<code>Composite</code>模式：</p><ul><li><p>你想表示对象的部分-整体层次结构</p></li><li><p>你希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。</p></li></ul><p><strong>总结</strong></p><p>组合模式解耦了客户程序与复杂元素内部结构，从而使客户程序可以向处理简单元素一样来处理复杂元素。</p><p>如果你想要创建层次结构，并可以在其中以相同的方式对待所有元素，那么组合模式就是最理想的选择。本章使用了一个文件</p><p>系统的例子来举例说明了组合模式的用途。在这个例子中，文件和目录都执行相同的接口，这是组合模式的关键。通过执行相同的接口，你就可以用相同的方式对待文件和目录，从而实现将文件或者目录储存为目录的子级元素。</p><h2 id="中介（Intermediary）"><a href="#中介（Intermediary）" class="headerlink" title="中介（Intermediary）"></a>中介（Intermediary）</h2><h3 id="初步理解-7"><a href="#初步理解-7" class="headerlink" title="初步理解"></a>初步理解</h3><p>中介，作用于多个事物之间充当交互沟通的媒介。我们的生活中有各种各样的媒介，比如一些传统媒体，书刊杂志，报纸，把信息传递给读者。再比如利用电子信息技术的互联网，作为一种新媒体，不单可以更高效地把信息传递给用户，而且可以反向地获得用户反馈评论，用户与用户之间亦可以进行沟通，这种全终端双向互通是传统媒体所不能及的。</p><p>除此之外，再如婚介所、房产中介、交换机组网、现代电子商务、C2C购物平台、手机、即时通软件等等，这些都与我们的生活息息相关，离开它们我们将举步维艰。其实不管是任何中介，其本质都是相同的，都是充当中间媒介的角色，并达成多方业务互通的目的。</p><p>首先我们以最简单的模型来解决问题，以两个人交谈为例，其实他们之间并不需要任何第三方媒介，而是一对一直接沟通，看代码。</p><pre><code class="java">public class People {  private String name;//用名字来区别人。  private People other;//持有对方的引用。  public String getName() {    return this.name;  }  public People(String name) {    this.name = name;//初始化必须起名。  }  public void connect(People other) {    this.other = other;//连接方法中注入对方引用。  }  public void talk(String msg) {    other.listen(msg);//我方说话时，对方聆听。  }  public void listen(String msg) {    //聆听来自对方的声音    System.out.println(        other.getName() + &quot; 对 &quot; + this.name + &quot; 说：&quot; + msg    );  }}</code></pre><p>一切就绪，两人开始沟通。</p><pre><code class="java">public class Main {  public static void main(String args[]) {    People p3 = new People(&quot;张三&quot;);    People p4 = new People(&quot;李四&quot;);    p3.connect(p4);    p4.connect(p3);    p3.talk(&quot;你好。&quot;);    p4.talk(&quot;早上好，三哥。&quot;);  }  /****************************  输出结果：    张三 对 李四 说：你好。    李四 对 张三 说：早上好，三哥。  *****************************/}</code></pre><p>从People类中我们可以看到，沟通只只能在两人之间进行，而且各自都持有对方对象的引用，以便把消息传递给对方的监听方法。这种模式虽然简单，但耦合性太强，你中有我，我中有你，谁也离不开谁。试想如果再有多个人加入交谈，那每个人都要持有其他所有人的引用了，这时会陷入一种多对多的关联陷阱，对象关系变得复杂不堪，如蛛网般难以维护。</p><p>我们就拿群聊天室举例，每当有人加入或离开，都要把每个人持有的其他人的引用关系更新一遍，发消息时更是繁琐不堪，重复工作显得非常多余。那么如何解决这个问题呢？我们开始进行思考，为何不把重复的部分抽离出来呢，也就是把对方的引用放在一个中介类里面去统一维护起来，于是设计更改如下。</p><pre><code class="java">public class User {    private String name;//名字    private ChatRoom chatRoom;//聊天室引用    public User(String name) {        this.name = name;//初始化必须起名字    }    public String getName() {        return this.name;    }    public void login(ChatRoom chatRoom) {//用户登陆        chatRoom.connect(this);//调用聊天室连接方法        this.chatRoom = chatRoom;//注入聊天室引用    }    public void talk(String msg) {//用户发言        chatRoom.sendMsg(this, msg);//给聊天室发消息    }    public void listen(User fromWhom, String msg) {//且听风吟        System.out.print(&quot;【&quot;+this.name+&quot;的对话框】&quot;);        System.out.println(fromWhom.getName() + &quot; 说： &quot; + msg);    }}</code></pre><p>可以看到第14行，用户登陆聊天室时不再是连接对方了，而是连接通知聊天室并告知：“有人进来了请进行注册”，然后记录下来用户当前所在聊天室的引用。第19行，用户发言时也不是直接找对方了，而是把消息扔给聊天室处理。第23行，聆听方法同样也是，将来会接受来自聊天室的声音。很显然，一切沟通都与是中介聊天室进行，这样用户之间就实现了解耦的目的。当然，用户当然还需要注销离开聊天室，请读者可自行练习添加，下面接着写我们的聊天室中介类。</p><pre><code class="java">public class ChatRoom {    private String name;//聊天室命名    public ChatRoom(String name) {        this.name = name;//初始化必须命名聊天室    }    List&lt;User&gt; users = new ArrayList&lt;&gt;();//聊天室里的用户们    public void connect(User user) {        this.users.add(user);//用户进入聊天室加入列表。        System.out.print(&quot;欢迎【&quot;);        System.out.print(user.getName());        System.out.println(&quot;】加入聊天室【&quot; + this.name + &quot;】&quot;);    }    public void sendMsg(User fromWhom, String msg) {        // 循环所有用户，只发消息给非发送方fromWhom。        users.stream()        .filter(user -&gt; !user.equals(fromWhom))//过滤掉发送方fromWhom        .forEach(toWhom -&gt; toWhom.listen(fromWhom, msg));//发送消息给剩下的所有人    }}</code></pre><p>这里我们新建一个聊天室作为中介类，所有参与者登陆时调用第10行的connect方法进入聊天室，并记录其引用到users列表中。第17行，当用户发消息到平台我们再转发给其他人，这里利用Java8的流和Lambda表达式进行过滤（User类的equals方法请自行加入），并循环调用所有接收方的listen方法即可。</p><p>为了说明问题，我们这里只是保持最简单的方式，如果某天情况变得复杂，有了不同的用户，或是聊天室也各不相同并加入了各自的特性，那我们就需要继续重构，抽象聊天室类，抽象用户类，读者可以灵活运用，这里就不做赘述了。</p><p>其实中介模式不止是在生活中广泛应用，在软件架构中也非常常见，当下流行的微服务分布式软件架构所用到的注册中心，例如最常用到的云组件Eureka Server，其作用就是为众多分布式服务提供注册发现服务，它正是充当像中介一样的角色。</p><p>还记得之前讲到的<a href="#组合（Combinations）">组合模式</a>中的树型结构吧，它主要描述的是子节点与父节点的关系。</p><p>而中介模式更像是网络拓扑中的星型结构，它描述了众节点与中心点的关系。</p><p>对像之间显式地互相引用越多，意味着依赖性越强，独立性越差，不利于代码维护与扩展，同时多方沟通的任务也应交由中间平台来完成，每个类应只具备各自该有的功能，这便是高内聚低耦合的设计标准。中介模式符合迪米特法则，它解决了对象间过度耦合、复杂频繁交互的问题，打破了你中有我，我中有你的相互依赖，第三方的介入有助于双方调停，打破如胶似漆、纠缠不休的关系，让他们之间变得松散、自由、独立。</p><h3 id="定义说明-7"><a href="#定义说明-7" class="headerlink" title="定义说明"></a>定义说明</h3><p><strong>定义：</strong>用一个中介者对象封装一系列的对象交互，中介者使各对象不需要显示地相互作用，从而使耦合松散，而且可以独立地改变它们之间的交互。</p><p><strong>中介者模式的结构</strong></p><p>中介者模式又称为调停者模式</p><ul><li><p><strong>抽象中介者：</strong>定义好同事类对象到中介者对象的接口，用于各个同事类之间的通信。一般包括一个或几个抽象的事件方法，并由子类去实现。</p></li><li><p><strong>中介者实现类：</strong>从抽象中介者继承而来，实现抽象中介者中定义的事件方法。从一个同事类接收消息，然后通过消息影响其他同时类。</p></li><li><p><strong>同事类：</strong>如果一个对象会影响其他的对象，同时也会被其他对象影响，那么这两个对象称为同事类。在类图中，同事类只有一个，这其实是现实的省略，在实际应用中，同事类一般由多个组成，他们之间相互影响，相互依赖。同事类越多，关系越复杂。并且，同事类也可以表现为继承了同一个抽象类的一组实现组成。在中介者模式中，同事类之间必须通过中介者才能进行消息传递。</p></li></ul><p><strong>中介者模式的优点</strong></p><ul><li><p>适当地使用中介者模式可以避免同事类之间的过度耦合，使得各同事类之间可以相对独立地使用。</p></li><li><p>使用中介者模式可以将对象间一对多的关联转变为一对一的关联，使对象间的关系易于理解和维护。</p></li><li><p>使用中介者模式可以将对象的行为和协作进行抽象，能够比较灵活的处理对象间的相互作用。</p></li></ul><p><strong>适用场景</strong></p><p>在面向对象编程中，一个类必然会与其他的类发生依赖关系，完全独立的类是没有意义的。一个类同时依赖多个类的情况也相当普遍，既然存在这样的情况，说明，一对多的依赖关系有它的合理性，适当的使用中介者模式可以使原本凌乱的对象关系清晰，但是如果滥用，则可能会带来反的效果。一般来说，只有对于那种同事类之间是网状结构的关系，才会考虑使用中介者模式。可以将网状结构变为星状结构，使同事类之间的关系变的清晰一些。</p><p>中介者模式是一种比较常用的模式，也是一种比较容易被滥用的模式。对于大多数的情况，同事类之间的关系不会复杂到混乱不堪的网状结构，因此，大多数情况下，将对象间的依赖关系封装的同事类内部就可以的，没有必要非引入中介者模式。滥用中介者模式，只会让事情变的更复杂。</p><h2 id="备忘录（Memorandum）"><a href="#备忘录（Memorandum）" class="headerlink" title="备忘录（Memorandum）"></a>备忘录（Memorandum）</h2><h3 id="初步理解-8"><a href="#初步理解-8" class="headerlink" title="初步理解"></a>初步理解</h3><p>备忘录，备份曾经发生过的历史记录，以防忘记，之后便可以轻松回溯过往。</p><p>在计算机世界里，人类便是神一般的存在，各种回滚，倒退，载入历史显得稀松平常，例如数据库恢复、游戏存盘载入、操作系统快照恢复、打开备份文档、手机恢复出厂设置……为了保证极简风格，我们这里以文档操作来举例说明这个设计模式。</p><p>假设某位作者要写一部科幻小说，当他打开编辑器软件以及创建文档开始创作的时候，我们来思考下这个场景需要哪些类。很简单，首先我们得有一个文档类Doc。</p><pre><code class="java">public class Doc {    private String title;//文章标题    private String body;//文章内容    public Doc(String title){//新建文档先命名        this.title = title;        this.body = &quot;&quot;;    }    public void setTitle(String title) {        this.title = title;    }    public String getTitle() {        return title;    }    public String getBody() {        return body;    }    public void setBody(String body) {        this.body = body;    }}</code></pre><p>没什么好说的，一个简单的Java Bean，包括标题与内容。有了文档那一定要有编辑器去修改它了，看代码。</p><pre><code class="java">public class Editor {//编辑器    private Doc doc;//文档引用    public Editor(Doc doc) {        System.out.println(&quot;&lt;&lt;&lt;打开文档&quot; + doc.getTitle());        this.doc = doc;        show();    }    public void append(String txt) {        System.out.println(&quot;&lt;&lt;&lt;插入操作&quot;);        doc.setBody(doc.getBody() + txt);        show();    }    public void save(){        System.out.println(&quot;&lt;&lt;&lt;存盘操作&quot;);    }    public void delete(){        System.out.println(&quot;&lt;&lt;&lt;删除操作&quot;);        doc.setBody(&quot;&quot;);        show();    }    private void show(){//显示当前文本内容        System.out.println(doc.getBody());        System.out.println(&quot;文章结束&gt;&gt;&gt;n&quot;);    }}</code></pre><p>当编辑器打开一个文档后会持有其引用，这里我们写在编辑器构造方法里。编辑器主要的功能当然是对文档进行更改了，依然保持简单的操作模拟，我们只加入append插入功能、delete清空功能，以及save存盘方法和最后的show方法用于显示文档内容。</p><pre><code class="java">public class Author {    public static void main(String[] args) {        Editor editor = new Editor(new Doc(&quot;《AI的觉醒》&quot;));        /*        &lt;&lt;&lt;打开文档《AI的觉醒》        文章结束&gt;&gt;&gt;        */        editor.append(&quot;第一章 混沌初开&quot;);        /*        &lt;&lt;&lt;插入操作        第一章 混沌初开        文章结束&gt;&gt;&gt;        */        editor.append(&quot;n  正文2000字……&quot;);        /*        &lt;&lt;&lt;插入操作        第一章 混沌初开          正文2000字……        文章结束&gt;&gt;&gt;        */        editor.append(&quot;n第二章 荒漠之花n  正文3000字……&quot;);        /*        &lt;&lt;&lt;插入操作        第一章 混沌初开          正文2000字……        第二章 荒漠之花          正文3000字……        文章结束&gt;&gt;&gt;        */        editor.delete();        /*        &lt;&lt;&lt;删除操作        文章结束&gt;&gt;&gt;         */    }}</code></pre><p>鬼才作者开始了创作，一切进行地非常顺利，一气呵成写完了二章内容（第22行操作），于是他离开电脑去倒了杯咖啡，噩耗在此间发生了，他的熊孩子不知怎么就按下了Ctr+A，Delete触发了第31行的操作，导致全文丢失，从内存里被清空，而且离开前作者疏忽大意也没有进行存盘操作，这下彻底完了，5000字的心血付诸东流。</p><p>此场景该如何是好？大家都想到了Ctr+z的操作吧？它可以瞬间撤销上一步操作并回退到前一个版本，不但让我们有吃后悔药的机会，而且还不需要频繁的去存盘备份。那么这个机制是怎样实现的呢？既然可以回溯历史，那一定得有一个历史备忘类来记录每步操作后的文本状态记录了，它同样是一个简单的Java Bean。</p><pre><code class="java">public class History {    private String body;//用于备忘文章内容    public History(String body){        this.body = body;    }    public String getBody() {        return body;    }}</code></pre><p>有了这个类，我们便可以记录文档的内容快照了，在初始化时把文档内容传进来。那谁来生成这些历史记录呢？我们可以放在文档类里，让文档类具备创建与恢复历史记录的功能，我们对Doc文档类做如下修改。</p><pre><code class="java">public class Doc {    private String title;//文章名字    private String body;//文章内容    public Doc(String title){//新建文档先命名        this.title = title;        this.body = &quot;&quot;;    }    public void setTitle(String title) {        this.title = title;    }    public String getTitle() {        return title;    }    public String getBody() {        return body;    }    public void setBody(String body) {        this.body = body;    }    public History createHistory() {        return new History(body);//创建历史记录    }    public void restoreHistory(History history){        this.body = history.getBody();//恢复历史记录    }}</code></pre><p>可以看到自第26行开始我们加入了这两个功能，只要简单的调用，便可以生成当下的历史记录，以及来去自如的恢复内容到任一历史时刻。接下来得有对历史记录的逻辑控制，也就是我们期待已久的撤销功能了，继续对编辑器类做如下修改。</p><pre><code class="java">public class Editor {    private Doc doc;    private List&lt;History&gt; historyRecords;// 历史记录列表    private int historyPosition = -1;// 历史记录当前位置    public Editor(Doc doc) {        System.out.println(&quot;&lt;&lt;&lt;打开文档&quot; + doc.getTitle());        this.doc = doc; // 注入文档        historyRecords = new ArrayList&lt;&gt;();// 初始化历史记录        backup();// 保存一份历史记录        show();//显示内容    }    public void append(String txt) {        System.out.println(&quot;&lt;&lt;&lt;插入操作&quot;);        doc.setBody(doc.getBody() + txt);        backup();//操作完成后保存历史记录        show();    }    public void save(){        System.out.println(&quot;&lt;&lt;&lt;存盘操作&quot;);    }    public void delete(){        System.out.println(&quot;&lt;&lt;&lt;删除操作&quot;);        doc.setBody(&quot;&quot;);        backup();//操作完成后保存历史记录        show();    }    private void backup() {        historyRecords.add(doc.createHistory());        historyPosition++;    }    private void show() {// 显示当前文本内容        System.out.println(doc.getBody());        System.out.println(&quot;文章结束&gt;&gt;&gt;n&quot;);    }    public void undo() {// 撤销操作：如按下Ctr+Z，回到过去。        System.out.println(&quot;&gt;&gt;&gt;撤销操作&quot;);        if (historyPosition == 0) {            return;//到头了，不能再撤销了。        }        historyPosition--;//历史记录位置回滚一笔        History history = historyRecords.get(historyPosition);        doc.restoreHistory(history);//取出历史记录并恢复至文档        show();    }    // public void redo(); 省略实现代码}</code></pre><p>在第3行我们加入了一个历史记录列表，它就像是时间轴一样按顺序地按index记录每个时间点的历史事件，从某种意义上看它更像是一本历史书。接下来加入的第32行backup方法会从文档中拿出快照并插入历史书，并于每个暴露给客户端作者的操作方法内被调用，做好历史的传承。最后我们加入第42行的撤销操作，让时间点回溯一个单位并恢复此处的快照至文档。</p><pre><code class="java">public class Author {    public static void main(String[] args) {        Editor editor = new Editor(new Doc(&quot;《AI的觉醒》&quot;));        /*        &lt;&lt;&lt;打开文档《AI的觉醒》        文章结束&gt;&gt;&gt;        */        editor.append(&quot;第一章 混沌初开&quot;);        /*        &lt;&lt;&lt;插入操作        第一章 混沌初开        文章结束&gt;&gt;&gt;        */        editor.append(&quot;n  正文2000字……&quot;);        /*        &lt;&lt;&lt;插入操作        第一章 混沌初开          正文2000字……        文章结束&gt;&gt;&gt;        */        editor.append(&quot;n第二章 荒漠之花n  正文3000字……&quot;);        /*        &lt;&lt;&lt;插入操作        第一章 混沌初开          正文2000字……        第二章 荒漠之花          正文3000字……        文章结束&gt;&gt;&gt;        */        editor.delete();        /*        &lt;&lt;&lt;删除操作        文章结束&gt;&gt;&gt;         */        //吃下后悔药，我的世界又完整了。        editor.undo();        /*        &gt;&gt;&gt;撤销操作        第一章 混沌初开          正文2000字……        第二章 荒漠之花          正文3000字……        文章结束&gt;&gt;&gt;        */    }}</code></pre><p>可以看到，熊孩子做了delete操作后，作者轻松淡定地按下了Ctr+z，一切恢复如初，世界依旧美好，挽回那逝去的青葱岁月。当然，代码中我们略去了一些功能，比如读者还可以加入重做redo操作，弹指之间，让历史在时间轴上来去自如，我的电脑我做主，时空穿梭，逆天之做。</p><p>诚然，任何模式都有其优缺点，备忘录虽然看起来完美，但如果历史状态内容过大，会导致内存消耗严重，别忘了那边历史书的list是在内存中的哦，所以我们一定要依场景灵活运用，切不可生搬硬套。</p><h3 id="定义说明-8"><a href="#定义说明-8" class="headerlink" title="定义说明"></a>定义说明</h3><p><strong>定义：</strong>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样就可以将该对象恢复到原先保存的状态。</p><p>我们在编程的时候，经常需要保存对象的中间状态，当需要的时候，可以恢复到这个状态。</p><p>比如，我们使用Idea进行编程时，假如编写失误（例如不小心误删除了几行代码），我们希望返回删除前的状态，便可以使用<code>Ctrl+Z</code>来进行返回。这时我们便可以使用备忘录模式来实现。</p><p><strong>备忘录模式的结构</strong></p><p><strong>发起人：</strong>记录当前时刻的内部状态，负责定义哪些属于备份范围的状态，负责创建和恢复备忘录数据。</p><p><strong>备忘录：</strong>负责存储发起人对象的内部状态，在需要的时候提供发起人需要的内部状态。</p><p><strong>管理角色：</strong>对备忘录进行管理，保存和提供备忘录。</p><p><strong>备忘录模式的优缺点和适用场景</strong></p><p>备忘录模式的<strong>优点</strong>有：当发起人角色中的状态改变时，有可能这是个错误的改变，我们使用备忘录模式就可以把这个错误的改变还原。备份的状态是保存在发起人角色之外的，这样，发起人角色就不需要对各个备份的状态进行管理。</p><p>备忘录模式的<strong>缺点</strong>有：在实际应用中，备忘录模式都是多状态和多备份的，发起人角色的状态需要存储到备忘录对象中，对资源的消耗是比较严重的。</p><p> 如果有需要提供回滚操作的需求，使用备忘录模式非常适合，比如<code>jdbc</code>的事务操作，文本编辑器的<code>Ctrl+Z</code>恢复等。</p><h2 id="迭代器（Iterator）"><a href="#迭代器（Iterator）" class="headerlink" title="迭代器（Iterator）"></a>迭代器（Iterator）</h2><h3 id="初步理解-9"><a href="#初步理解-9" class="headerlink" title="初步理解"></a>初步理解</h3><p>方法迭代，代的更迭，从初代到末代的遍历，指对某类集合中的每个元素按顺序取出的行为。举个例子，通常我们读小说是从前往后翻，一页接着一页地读，这样我们才可以了解一个连续完整的故事，那这就需要我们顺序地迭代整本书的每一页内容。</p><p>相信大家都用过集合类吧，最常用的比如List，Set，Map以及各种各样不同数据表示实现，总之是把某一批类似的元素按某种数据结构集合起来作为一个整体来引用，不至于元素丢的到处都是难以维护，当要用到每个元素的时候，我们需要将它们一个个的取出来，但是对不同的数据类型访问方式各有不同，于是我们就需要定义统一的迭代器来标准化这种遍历行为。</p><p>为何会有各种各样的遍历方式呢？比如说弹夹，装填子弹的时候要一颗一颗的进行压栈，等到射击的时候就需要迭代操作，先出栈拿出最后装填的子弹再进行射击，然后反向往前遍历直到最初装填的子弹直到射完为止，此刻也代表着迭代的结束，整个过程像是内存栈的操作，先进后出，后进先出，当然这并不代表其迭代器非要先进后出，这里只是举例说明针对不同数据类型进行不同的迭代方式。</p><p>以上数据结构及迭代器其实都有现成的类去实现，我们就以行车记录仪举例，大家先想想怎么来记录一段一段的视频呢？如果我们简单的利用ArrayList去记录，那它得有多大空间去支持一直拍摄视频？</p><p>我们知道其实它是循环覆写的，待空间不够用时，最新的视频总会去覆盖掉最老的视频，以首尾相接的环形结构解决空间有限的问题。好，开始代码实战，首先我们定义一个行车记录仪类。</p><pre><code class="java">public class DrivingRecorder {    private int index = -1;// 当前记录位置    private String[] records = new String[10];// 假设只能记录10条视频    public void append(String record) {        if (index == 9) {// 循环覆盖            index = 0;        } else {            index++;        }        records[index] = record;    }    public void display() {// 循环数组并显示所有10条记录        for (int i = 0; i &lt; 10; i++) {            System.out.println(i + &quot;: &quot; + records[i]);        }    }    public void displayInOrder() {//按顺序从新到旧显示10条记录        for (int i = index, loopCount = 0; loopCount &lt; 10; i = i == 0 ? i = 9 : i - 1,loopCount++) {            System.out.println(records[i]);        }    }}</code></pre><p>假设我们的记录仪存储空间只够录10段视频，我们定义一个原始的字符串数组（第3行）来模拟记录，并且用一个游标（第2行）来记录当前记录所在位置。当插入视频的时候（第5行）我们得先看有没有录满到头了，如果是的话就要把游标调整到头以后再记录视频。视频目前可以循环记录了，但总得给用户显示出来看吧，于是我们又提供了两个显示方法，一个是按默认数组顺序显示，一个是按用户习惯从新到旧地显示内容（逻辑稍微复杂了点但这里不是重点，读者可以略过），开始写用户类来使用这个记录仪。</p><pre><code class="java">public class Client {    public static void main(String[] args) {        DrivingRecorder dr = new DrivingRecorder();        //假设记录了12条视频        for (int i = 0; i &lt; 12; i++) {            dr.append(&quot;视频_&quot; + i);        }        dr.display();        /*按原始顺序显示,视频0与1分别被10与11覆盖了。            0: 视频_10            1: 视频_11            2: 视频_2            3: 视频_3            4: 视频_4            5: 视频_5            6: 视频_6            7: 视频_7            8: 视频_8            9: 视频_9        */        dr.displayInOrder();        /*按顺序从新到旧显示            视频_11            视频_10            视频_9            视频_8            视频_7            视频_6            视频_5            视频_4            视频_3            视频_2        */    }}</code></pre><p>我们以视频_0开始，假设空间已经记录到视频_11，一共12条视频会不会撑爆空间呢？我们来运行以下看会发生什么。奇迹出现了，视频_10和视频_11分别覆盖了最早记录的视频_0和视频_1，完美！产品可以量产了！</p><p>正当我们要举杯欢庆的时候客户开始吐槽了，你只是简单在屏幕上显示一下就完事了么？功能也太差了点！我要的是把原始视频拿出来给我，我好上报交警作为证据，总之你甭管我怎么加工处理，你总得把原始数据拿出来给我。</p><p>这可把我们难住了，这些数据都是在记录仪内部封装好的私有数据，如果直接改成public暴露出去，试想用户随意增加删除，完全不管游标位置，这会破坏掉内部逻辑机制，数据封装的意义何在？我们鬼斧神工设计将瞬间崩塌，用户数据安全无法保证，bug肆虐。</p><p>所以，我们绝不能更改数据的私有化封装，而之前暴露给用户的显示方法显得非常死板，扩展性极差，我们决定以迭代器取而代之，如此提供给用户遍历数据的功能，拿出去的数据用户便可以随意使用，这样就避免了用户染指内部机件的危险。首先我们需要定义一个迭代器接口标准来规范抽象，看代码:</p><pre><code class="java">public interface Iterator&lt;E&gt; {    E next();//返回下一个元素    boolean hasNext();//是否还有下一个元素}</code></pre><p>很简单吧？此接口标准定义了两个方法，next方法用于返回下一个数据元素，而hasNext用于询问迭代器是否还有下一个元素，当然我们也可以不定义这个接口，而是直接用JDK中util包自带的。接下来更改我们的行车记录仪，加入iterator方法用于获取迭代器，开始我们的迭代器实现。</p><pre><code class="java">public class DrivingRecorder {    private int index = -1;// 当前记录位置    private String[] records = new String[10];// 假设只能记录10条视频    public void append(String record) {        if (index == 9) {// 循环覆盖            index = 0;        } else {            index++;        }        records[index] = record;    }    public Iterator&lt;String&gt; iterator() {        return new Itr();    }    private class Itr implements Iterator&lt;String&gt; {        int cursor = index;// 迭代器游标，不染指原始游标。        int loopCount = 0;        @Override        public boolean hasNext() {            return loopCount &lt; 10;        }        @Override        public String next() {            int i = cursor;// 记录即将返回的游标位置            if (cursor == 0) {                cursor = 9;            } else {                cursor--;            }            loopCount++;            return records[i];        }    }}</code></pre><p>这里我们加入内部类（第18行）来定义迭代器实现，为的是能轻松访问到记录仪私有数据集。内部类实现了两个标配方法<code>hasNext</code>与<code>next</code>，内部逻辑看起来简单多了，大家可以自行理解，这里就不做讲解了。最后重点来了，用户可以进行如下操作了。</p><pre><code class="java">public class Client {    public static void main(String[] args) {        DrivingRecorder dr = new DrivingRecorder();        // 假设记录了12条视频        for (int i = 0; i &lt; 12; i++) {            dr.append(&quot;视频_&quot; + i);        }        //用户要获取交通事故视频，定义事故列表。        List&lt;String&gt; accidents = new ArrayList&lt;&gt;();        //用户拿到迭代器        Iterator&lt;String&gt; it = dr.iterator();        while (it.hasNext()) {//如果还有下一条则继续迭代            String video = it.next();            System.out.println(video);            //用户翻看视频发现10和8可作为证据。            if(&quot;视频_10&quot;.equals(video) || &quot;视频_8&quot;.equals(video)){                accidents.add(video);            }        }        //拿到两个视频集accidents交给交警查看。        System.out.println(&quot;事故证据：&quot; + accidents);        /*        视频_11        视频_10        视频_9        视频_8        视频_7        视频_6        视频_5        视频_4        视频_3        视频_2         事故证据：[视频_10, 视频_8]        */    }}</code></pre><p>用户拿到迭代器进行遍历查看，注意第18行，用户将这12条视频中的10和8拿出来拷贝U盘并交给交警作为呈堂证供判对方碰瓷，以证明自己的清白。</p><p>当然，我们这里只是保持极简说明问题，读者可以自行重构代码，尤其是实现迭代器的remove方法非常重要（注意游标的调整），这样用户便可以删除数据了。</p><p>总之，对于任何的集合类，既要保证内部数据表示不暴露给外部以防搞乱内部机制，还要提供给用户遍历并访问到每个数据的权限，迭代器模式则成就了鱼与熊掌兼得的可能，它提供了所有集合对外开放的统一标准接口，内政容不得干涉，但是经济依旧要开放。</p><h3 id="定义说明-9"><a href="#定义说明-9" class="headerlink" title="定义说明"></a>定义说明</h3><p><strong>定义：</strong>提供一种方法访问一个容器对象中各个元素，而又不暴露该对象的内部细节。</p><p><strong>迭代器模式的结构</strong></p><ul><li><p><strong>抽象容器：</strong>一般是一个接口，提供一个<code>iterator()</code>方法，例如Java中的<code>Collection</code>接口，<code>List</code>接口，<code>Set</code>接口等。</p></li><li><p><strong>具体容器：</strong>就是抽象容器的具体实现类，比如<code>List</code>接口的有序列表实现<code>ArrayList</code>，<code>List</code>接口的链表实现<code>LinkList</code>，<code>Set</code>接口的哈希列表的实现<code>HashSet</code>等。</p></li><li><p><strong>抽象迭代器：</strong>定义遍历元素所需要的方法，一般来说会有这么三个方法：取得第一个元素的方法<code>first()</code>，取得下一个元素的方法<code>next()</code>，判断是否遍历结束的方法<code>isDone()</code>（或者叫<code>hasNext()</code>），移出当前对象的方法<code>remove()</code></p></li><li><p><strong>迭代器实现：</strong>实现迭代器接口中定义的方法，完成集合的迭代。</p></li></ul><p><strong>迭代器模式的优点：</strong></p><p>简化了遍历方式，对于对象集合的遍历，还是比较麻烦的，对于数组或者有序列表，我们尚可以通过游标来取得，但用户需要在对集合了解很清楚的前提下，自行遍历对象，但是对于<code>hash</code>表来说，用户遍历起来就比较麻烦了。而引入了迭代器方法后，用户用起来就简单的多了。</p><p>可以提供多种遍历方式，比如说对有序列表，我们可以根据需要提供正序遍历，倒序遍历两种迭代器，用户用起来只需要得到我们实现好的迭代器，就可以方便的对集合进行遍历了。</p><p>封装性良好，用户只需要得到迭代器就可以遍历，而对于遍历算法则不用去关心。</p><p><strong>迭代器模式的缺点：</strong></p><p>对于比较简单的遍历（像数组或者有序列表），使用迭代器方式遍历较为繁琐，大家可能都有感觉，像<code>ArrayList</code>，我们宁可愿意使用<code>for</code>循环和<code>get</code>方法来遍历集合。</p><p><strong>迭代器模式的适用场景</strong></p><p>迭代器模式是与集合共生共死的，一般来说，我们只要实现一个集合，就需要同时提供这个集合的迭代器，就像Java中的<code>Collection</code>，<code>List</code>、<code>Set</code>、<code>Map</code>等，这些集合都有自己的迭代器。假如我们要实现一个这样的新的容器，当然也需要引入迭代器模式，给我们的容器实现一个迭代器。</p><p>但是，由于容器与迭代器的关系太密切了，所以大多数语言在实现容器的时候都给提供了迭代器，并且这些语言提供的容器和迭代器在绝大多数情况下就可以满足我们的需要，所以现在需要我们自己去实践迭代器模式的场景还是比较少见的，我们只需要使用语言中已有的容器和迭代器就可以了。</p><h2 id="责任链"><a href="#责任链" class="headerlink" title="责任链"></a>责任链</h2><h3 id="初步理解-10"><a href="#初步理解-10" class="headerlink" title="初步理解"></a>初步理解</h3><p>曾经有这么一些零散的功能节点，他们各自承担各自的义务，分工明确，各司其职。为了更高效，更完整地解决客户的问题，他们发扬团队精神，互相串联起来形成一个有序的责任传递链表，于是责任链模式诞生了。当然，它的结构也不一定非得是链表，甚至可以是树型分叉结构，这要根据业务场景看怎样去灵活运用，但其核心意义是为了处理某种连续的流程，并确保业务一定能走到相应的责任节点上并得到相应的处理。</p><p>说到这里想必大家已经想到了工作流吧？对，企事业单位中通常为了完成某项日常任务，通常要制定一些工作流程，按步骤拆分，并组织好各个环节中的逻辑关系及走向，这样才能更高效、更规范地完成任务。</p><p>假设某公司针对出差报销业务制定审批流程，有三个审批角色分别是员工（1000元权限）、经理（5000元权限）、以及CEO（10000元权限），各审批人代码如下。</p><pre><code class="java">public class Staff {    private String name;    public Staff(String name) {        this.name = name;    }    public boolean approve(int amount) {        if (amount &lt;= 1000) {            System.out.println(&quot;审批通过。【员工：&quot; + name + &quot;】&quot;);            return true;        } else {            System.out.println(&quot;无权审批，请找上级。【员工：&quot; + name + &quot;】&quot;);            return false;        }    }}public class Manager {    private String name;    public Manager(String name) {        this.name = name;    }    public boolean approve(int amount) {        if (amount &lt;= 5000) {            System.out.println(&quot;审批通过。【经理：&quot; + name + &quot;】&quot;);            return true;        } else {            System.out.println(&quot;无权审批，请找上级。【经理：&quot; + name + &quot;】&quot;);            return false;        }    }}public class CEO {    private String name;    public CEO(String name) {        this.name = name;    }    public boolean approve(int amount) {        if (amount &lt;= 10000) {            System.out.println(&quot;审批通过。【CEO：&quot; + name + &quot;】&quot;);            return true;        } else {            System.out.println(&quot;驳回申请。【CEO：&quot; + name + &quot;】&quot;);            return false;        }    }}</code></pre><p>好了，审批人们定义完毕，逻辑非常简单缜密，如果超过审批金额最大权限则打回去，开始写申请人客户端类。</p><pre><code class="java">public class Client {    public static void main(String[] args) {        int amount = 10000;//出差花费10000元        // 先找员工张飞审批        Staff staff = new Staff(&quot;张飞&quot;);        if (!staff.approve(amount)) {            //被拒，找关二爷问问。            Manager manager = new Manager(&quot;关羽&quot;);            if (!manager.approve(amount)) {                //还是被拒，只能找老大了。                CEO ceo = new CEO(&quot;刘备&quot;);                ceo.approve(amount);            }        }        /***********************        无权审批，请找上级。【员工：张飞】        无权审批，请找上级。【经理：关羽】        审批通过。【CEO：刘备】        ***********************/    }}</code></pre><p>功夫不负有心人，跑了三个地方找了三个人，一万元的大额报销单终于被大老板审批了。然而，大家有没有发现问题？我们走的审批流程好像有点过于复杂了，找这个不行那个不同意，跑来跑去的好像自己有点像是被踢皮球的感觉。此外，如果我们后期要优化完善此工作流程，或是添加新的审批角色进来，那就得不停地修改此处的逻辑，最终的修改结果会是？</p><p>乱了，全乱套了，我们终将被淹没在一堆复杂的审批流程中，跑断腿也找不到门路。这显然是违反设计模式原则的，我们必须进行重构。我们观察此类中的审批逻辑，这显然就是一个链式结构，审批人之间环环相扣，对于自己无法处理的申请，会像被踢皮球似的传给上级，直到某人解决此申请，对员工张飞来说，他只知道自己传球给关羽了，仅此而已。</p><p>进一步分析，审批人肯定是不同的角色，并且每个角色的审批逻辑会有区别，所以我们得把这些角色的审批逻辑分开来写，对每个角色的责任范围我们进行定义，我只懂自己怎么审批（责任），我处理不了的我递交给上层（链条），开始重构，先抽象出一个审批人类。</p><pre><code class="java">public abstract class Approver {// 审批人抽象类    protected String name;// 抽象出审批人的姓名。    protected Approver nextApprover;// 下一个审批人，更高级别领导。    public Approver(String name) {        this.name = name;    }    protected Approver setNextApprover(Approver nextApprover) {        this.nextApprover = nextApprover;        return this.nextApprover;// 返回下个审批人，链式编程。    }    public abstract void approve(int amount);// 抽象审批方法由具体审批人子类实现}</code></pre><p>注意第4行，审批人只认识自己的领导，所以会持有下一级领导的引用，同时第10行的代码用于把领导注入进来。第15行是我们的审批方法了，但每个角色审批逻辑会有区别，所以这里进行抽象，并由具体的审批角色子类去实现，先从员工看起。</p><pre><code class="java">public class Staff extends Approver {    public Staff(String name) {        super(name);    }    @Override    public void approve(int amount) {        if (amount &lt;= 1000) {            System.out.println(&quot;审批通过。【员工：&quot; + name + &quot;】&quot;);        } else {            System.out.println(&quot;无权审批，升级处理。【员工：&quot; + name + &quot;】&quot;);            this.nextApprover.approve(amount);        }    }}</code></pre><p>很简单，员工类继承了审批角色类，第9行申明审批权限为1000元，重点在于第13行这里调用了自己上级领导的审批方法，显然这里是自己处理不了的申请单了。大同小异，再重构经理及CEO审批角色类。</p><pre><code class="java">public class Manager extends Approver {    public Manager(String name) {        super(name);    }    @Override    public void approve(int amount) {        if (amount &lt;= 5000) {            System.out.println(&quot;审批通过。【经理：&quot; + name + &quot;】&quot;);        } else {            System.out.println(&quot;无权审批，升级处理。【经理：&quot; + name + &quot;】&quot;);            this.nextApprover.approve(amount);        }    }}public class CEO extends Approver {    public CEO(String name) {        super(name);    }    @Override    public void approve(int amount) {        if (amount &lt;= 10000) {            System.out.println(&quot;审批通过。【CEO：&quot; + name + &quot;】&quot;);        } else {            System.out.println(&quot;驳回申请。【CEO：&quot; + name + &quot;】&quot;);        }    }}</code></pre><p>CEO类作为链条的尾巴，也就是最高级别，第12行的越权逻辑会最终拒绝申请单。很简单吧？我们生成一下这个链条，并从员工开始传递申请单。</p><pre><code class="java">public class Client {    public static void main(String[] args) {        Approver flightJohn = new Staff(&quot;张飞&quot;);        flightJohn.setNextApprover(new Manager(&quot;关羽&quot;)).setNextApprover(new CEO(&quot;刘备&quot;));        //高层接触不到也没必要接触，直接找员工张飞审批。        flightJohn.approve(1000);        /***********************        审批通过。【员工：张飞】        ***********************/        flightJohn.approve(4000);        /***********************        无权审批，升级处理。【员工：张飞】        审批通过。【经理：关羽】        ***********************/        flightJohn.approve(9000);        /***********************        无权审批，升级处理。【员工：张飞】        无权审批，升级处理。【经理：关羽】        审批通过。【CEO：刘备】        ***********************/        flightJohn.approve(88000);        /***********************        无权审批，升级处理。【员工：张飞】        无权审批，升级处理。【经理：关羽】        驳回申请。【CEO：刘备】        ***********************/    }}</code></pre><p>这里注意第4行的代码对责任链进行构造（其实这里我们还可以交由工作流工厂去构造完成，读者可以自己实践练习），从员工开始一直到CEO结束。之后的业务就非常简单了，直接递单给员工张飞，审批流程便魔法般地启动了，审批单在这个责任链条上层层递交，最终给出结果。</p><p>至此，申请人与审批人实现了解耦，我们只需递单送给责任链即可，申请人不必再关心每个处理细节，只需交给接口人张飞处理就妥了。使用了责任链模式后的代码看起来非常简洁，各个角色的责任划分非常明确并且被分开定义到了每个角色类中，再把他们串起来去调用，一气呵成。后期如果再继续添加新的角色只需要添加新角色类并加入链条即可，链条的随意伸缩，灵活的可伸缩性，完美的可扩展性。</p><p>在实际应用中，我们切勿生搬硬套，还需根据实际需求场景进行灵活运用，就拿工业现代化生产线举例，这个其实也类似责任链模式，但不同之处在于其组装工作是必须经过每个组装节点处理的，从头到尾的全链处理而不能中途退出，读者朋友可以自己写代码练习，实践与思考要相结合并循环往复，二者都非常重要。</p><h3 id="定义说明-10"><a href="#定义说明-10" class="headerlink" title="定义说明"></a>定义说明</h3><p><strong>定义：</strong>使多个对象都有机会处理请求，从而避免了请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止。</p><p><strong>责任链模式的结构</strong></p><p>责任链模式的类图非常简单，它由一个抽象地处理类和它的一组实现类组成：</p><ul><li><p><strong>抽象处理类：</strong>抽象处理类中主要包含一个指向下一处理类的成员变量<code>nextHandler</code>和一个处理请求的方法<code>handRequest</code>，<code>handRequest</code>方法的主要主要思想是，如果满足处理的条件，则有本处理类来进行处理，否则由<code>nextHandler</code>来处理。</p></li><li><p><strong>具体处理类：</strong>具体处理类主要是对具体的处理逻辑和处理的适用条件进行实现。</p></li></ul><p><strong>责任链模式的优缺点</strong></p><p>责任链模式与<code>if…else…</code>相比，他的耦合性要低一些，因为它把条件判定都分散到了各个处理类中，并且这些处理类的优先处理顺序可以随意设定。责任链模式也有缺点，这与<code>if…else…</code>语句的缺点是一样的，那就是在找到正确的处理类之前，所有的判定条件都要被执行一遍，当责任链比较长时，性能问题比较严重。</p><p><strong>责任链模式的适用场景</strong></p><p>就像开始的例子那样，假如使用<code>if…else…</code>语句来组织一个责任链时感到力不从心，代码看上去很糟糕时，就可以使用责任链模式来进行重构。</p><p><strong>总结</strong></p><p>责任链模式其实就是一个灵活版的<code>if…else…</code>语句，它就是将这些判定条件的语句放到了各个处理类中，这样做的优点是比较灵活了，但同样也带来了风险，比如设置处理类前后关系时，一定要特别仔细，搞对处理类前后逻辑的条件判断关系，并且注意不要在链中出现循环引用的问题。</p><h2 id="观察者"><a href="#观察者" class="headerlink" title="观察者"></a>观察者</h2><h3 id="初步理解-11"><a href="#初步理解-11" class="headerlink" title="初步理解"></a>初步理解</h3><p>眼观六路，耳听八方，观察者很忙，随时监控着关注对象的一举一动。记者、摄影师、重症监护的护士，被套的股民，无不为了完成任务疲于奔命，而观察者模式正是为了解决这个问题而诞生。</p><p>观察者的痛点到底在哪里呢？让我们用购物来做例程，假设某件商品（水果手机）卖得非常火爆，长期处于脱销的状态。由于供不应求，师徒四人也加入了抢购的队伍，不时的去商店询问是否有货，先看商店类代码。</p><pre><code class="java">public class Shop {    private String product;//商品    //初始商店无货    public Shop() {        this.product = &quot;无商品&quot;;    }    //商店出货    public String getProduct() {        return product;    }    //商店进货    public void setProduct(String product) {        this.product = product;    }}</code></pre><p>简单易懂，然后是买家类，充当观察者角色。</p><pre><code class="java">public class Buyer {// 买家    private String name;// 买家姓名    private Shop shop;// 商店引用    public Buyer(String name, Shop shop) {        this.name = name;        this.shop = shop;    }    public void buy() {// 买家购买商品        System.out.print(name + &quot;购买：&quot;);        System.out.println(shop.getProduct());    }}</code></pre><p>注意第3行买家持有商店的引用，用来在第10行的购买行为中获取商品，最后是客户端类来模拟买家与商家的互动。</p><pre><code class="java">public class Client {    public static void main(String[] args) {        Shop shop = new Shop();        Buyer wukong = new Buyer(&quot;悟空&quot;, shop);        Buyer shaseng = new Buyer(&quot;沙僧&quot;, shop);        Buyer bajie = new Buyer(&quot;八戒&quot;, shop);        wukong.buy();// 悟空购买：无商品        bajie.buy();// 八戒购买：无商品        shaseng.buy();// 沙僧购买：无商品        bajie.buy();// 八戒购买：无商品        // 师傅忍不住了，也加入了购买行列。        Buyer tangseng = new Buyer(&quot;唐僧&quot;, shop);        tangseng.buy();// 唐僧购买：无商品        // 除了八戒其他人都放弃了        bajie.buy();// 八戒购买：无商品        bajie.buy();// 八戒购买：无商品        // 商店终于进货了        shop.setProduct(&quot;最新旗舰手机&quot;);        bajie.buy();// 八戒购买：最新旗舰手机    }}</code></pre><p>看到这些买家的疯狂行为没有？一开始师傅命三位徒弟去抢购，商店一直处于无货状态，师傅坐立难安，也加入了抢购大军，最终徒儿刚鬣脱颖而出，终于抢到了梦寐以求的手机，整个过程堪比九九八十一难。</p><p>大家有没有发现问题？除了最后一步目的达成之外，之前的部分都是在做无用功，并且此处代码只是模拟了师徒四人而已，真实情况并非如此简单，可能会有成千上万的疯狂粉丝不断询问有没有到货，商家的店员可能会被逼疯。</p><p>到这里大家肯定已经想到了，与其让观察者不断的询问不如当到货的时候让商家主动通知观察者们来买吧，换个角度分析问题马上迎刃而解，醍醐灌顶般清爽，开始设计优雅观察者的模式，首先从商家类开始重构。</p><pre><code class="java">public class Shop {    private String product;    private List&lt;Buyer&gt; buyers;// 持有买家的引用    public Shop() {        this.product = &quot;无商品&quot;;        this.buyers = new ArrayList&lt;&gt;();    }    // 为了主动通知买家，买家得来店里注册。    public void register(Buyer buyer) {        this.buyers.add(buyer);    }    public String getProduct() {        return product;    }    public void setProduct(String product) {        this.product = product;// 到货了        notifyBuyers();// 到货后通知买家    }    // 通知所有注册买家    public void notifyBuyers() {        buyers.stream().forEach(b -&gt; b.inform());    }}</code></pre><p>注意第12行的注册方法，所有关注商品的买家都应先注册（订阅），比如告知商家手机号以便第20行到货后可以接到通知，以及第26行的通知方法对所有买家进行迭代，并调用买家的<code>inform</code>进行告知。所以这里我们规定，对于Buyer买家必须要有<code>inform</code>方法，这是对各类形形色色买家的定制行为，故我们对买家类进行抽象如下。</p><pre><code class="java">public abstract class Buyer {    protected String name;    protected Shop shop;    public Buyer(String name, Shop shop) {        this.name = name;        this.shop = shop;//        shop.register(this);    }    public abstract void inform();}</code></pre><p>很简单，我们对买家进行了抽象，其中第11行inform方法必须得到实现，通知到你了怎样处理自己看着办咯。注意第8行注掉的代码，构造时强制将自己注册入商家名单，但为了灵活起见我们暂让买家自行决定是否注册。接下来我们来看众买家都是些什么样的人，首先是果粉买家。</p><pre><code class="java">public class PhoneFans extends Buyer {    public PhoneFans(String name, Shop shop) {        super(name, shop);//调用父类进行构造    }    @Override    public void inform() {        String product = shop.getProduct();        if(product.contains(&quot;水果手机&quot;)){//此买家只买水果牌手机            System.out.print(name);            System.out.println(&quot;购买：&quot; + product);        }    }}</code></pre><p>买家的行为各式各样，在第8行实现了父类抽象行为，接到通知后他做了逻辑判断，很明显这类买家只稀罕水果牌手机，别的商品不是他的菜。再来看另一类剁手党买家。</p><pre><code class="java">public class HandChopper extends Buyer {    public HandChopper(String name, Shop shop) {        super(name, shop);    }    @Override    public void inform() {        System.out.print(name);        String product = shop.getProduct();        System.out.println(&quot;购买：&quot; + product);    }}</code></pre><p>与果粉不同，他是来者不拒，只要有货就买买买！最后来看客户端的神操作。</p><pre><code class="java">public class Client {    public static void main(String[] args) {        Shop shop = new Shop();        Buyer tanSir = new PhoneFans(&quot;果粉唐僧&quot;, shop);        Buyer barJeet = new HandChopper(&quot;剁手族八戒&quot;, shop);        shop.register(tanSir);        shop.register(barJeet);        //商店到货        shop.setProduct(&quot;猪肉炖粉条&quot;);        shop.setProduct(&quot;水果手机【爱疯叉】&quot;);        /*输出结果            剁手族八戒购买：猪肉炖粉条            果粉唐僧购买：水果手机【爱疯叉】            剁手族八戒购买：水果手机【爱疯叉】         */    }}</code></pre><p>无与伦比地优雅，第6行开始对疯狂买家师徒二人进行注册，于是他们再也不见他们终日徘徊于店门之外苦苦等待的身影了。接下来某日商店到货（第10行），至此购买过程就这样神奇地结束了，不信？看输出结果，嗯，不单买家很奇葩，连店都很奇葩。总之，商家只要到货就会马上打电话给这些订阅买家告知可以购买了。</p><p>其实，最初商家与买家之间的互动行为非常类似于<code>Web</code>应用中的Poll行为，由于<code>Http</code>无状态连接协议的安全特性，服务端（商家）无法主动推送（Push）消息给客户端（买家），所以有时会用到Poll技术，也就是不断的轮询服务端，有没有更新？有没有更新？有没有更新？严重时，成千上万的客户端会造成服务器瘫痪，所以之后诞生的<code>WebSocket</code>正是为了解决这个问题，这便类似于我们的观察者模式。</p><p>观察者模式解决了基于一对多对象结构关系间的互动问题，使观察者（多方买家）专主动为被动，被观察者（单方商家）转被动为主动，此情此景，需动静结合，先后有序，以【一方动多方静】取代【多方动一方静】的模式，大大的提高了沟通效率，别再偷窥了，我show给你好看。</p><h3 id="定义说明-11"><a href="#定义说明-11" class="headerlink" title="定义说明"></a>定义说明</h3><p><strong>定义：</strong>定义对象间一种一对多的依赖关系，使得当每一个对象改变状态，则所有依赖于它的对象都会得到通知并自动更新。</p><p><strong>观察者模式的结构</strong></p><p>在最基础的观察者模式中，包括以下四个角色：</p><ul><li><p><strong>被观察者：</strong>从类图中可以看到，类中有一个用来存放观察者对象的<code>Vector</code>容器（之所以使用<code>Vector</code>而不使用<code>List</code>，是因为多线程操作时，<code>Vector</code>在是安全的，而<code>List</code>则是不安全的），这个<code>Vector</code>容器是被观察者类的核心，另外还有三个方法：<code>attach</code>方法是向这个容器中添加观察者对象；<code>detach</code>方法是从容器中移除观察者对象；<code>notify</code>方法是依次调用观察者对象的对应方法。这个角色可以是接口，也可以是抽象类或者具体的类，因为很多情况下会与其他的模式混用，所以使用抽象类的情况比较多。</p></li><li><p><strong>观察者：</strong>观察者角色一般是一个接口，它只有一个<code>update</code>方法，在被观察者状态发生变化时，这个方法就会被触发调用。</p></li><li><p><strong>具体的被观察者：</strong>使用这个角色是为了便于扩展，可以在此角色中定义具体的业务逻辑。</p></li><li><p><strong>具体的观察者：</strong>观察者接口的具体实现，在这个角色中，将定义被观察者对象状态发生变化时所要处理的逻辑。</p></li></ul><p><strong>观察者模式的优点</strong></p><p>观察者与被观察者之间是属于轻度的关联关系，并且是抽象耦合的，这样，对于两者来说都比较容易进行扩展。</p><p>观察者模式是一种常用的触发机制，它形成一条触发链，依次对各个观察者的方法进行处理。但同时，这也算是观察者模式一个缺点，由于是链式触发，当观察者比较多的时候，性能问题是比较令人担忧的。并且，在链式结构中，比较容易出现循环引用的错误，造成系统假死。</p><p><strong>总结</strong></p><p>Java语言中，有一个接口<code>Observer</code>，以及它的实现类<code>Observable</code>，对观察者角色常进行了实现。我们可以在<code>JDK</code>的<code>API</code>文档具体查看这两个类的使用方法。</p><p>做过<code>VC++</code>、<code>javascript DOM</code>或者<code>AWT</code>开发的朋友都对它们的事件处理感到神奇，了解了观察者模式，就对事件处理机制的原理有了一定的了解了。如果要设计一个事件触发处理机制的功能，使用观察者模式是一个不错的选择，<code>AWT</code>中的事件处理<code>DEM</code>（委派事件模型Delegation Event Model）就是使用观察者模式实现的。</p><h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><h3 id="初步理解-12"><a href="#初步理解-12" class="headerlink" title="初步理解"></a>初步理解</h3><p>代理，代表打理，以他人的名义代表委托人打理其本职工作之外或不所能及的事务，达成合作关系并更高效地促成事务完成的目的。比如机票销售代理商既不造飞机也不提供乘机服务，他们只负责卖票，代理律师并不会因胜诉获得赔偿金或者败诉受到法律制裁，他们只负责代理打官司，等等等等。</p><p>以网络代理举例：</p><p>首先，我们上网前得去网络服务提供商<code>（ISP）</code>申请互联网宽带业务，于是顺理成章光纤入户，并拿到一个调制解调器，也就是我们俗称的“猫”。好，“猫”实现了互联网访问接口，看代码：</p><pre><code class="java">public interface Internet {//互联网访问接口    public void access(String url);}</code></pre><pre><code class="java">public class Modem implements Internet {//调制解调器    @Override    public void access(String url){//实现互联网访问接口        System.out.println(&quot;正在访问：&quot; + url);    }}</code></pre><p>作为调制解调器，一定有上网功能了，用户的电脑只需要用网线连接这只“猫”便接入互联网了。就这么简单么？然而某天我们发现孩子学习时总是偷偷上网看电影玩游戏，于是我们决定对某些网站进行过滤，拒绝黄赌毒侵害未成年。那么，我们需要在客户终端电脑与猫之间加一层代理，用于过滤某些不良网站，最终我们决定购买一款有过滤功能的路由器。</p><pre><code class="java">public class RouterProxy implements Internet {//路由器代理类    private Internet modem;//持有被代理类引用    private List&lt;String&gt; blackList = Arrays.asList(&quot;电影&quot;, &quot;游戏&quot;, &quot;音乐&quot;, &quot;小说&quot;);    public RouterProxy() {        this.modem = new Modem();//实例化被代理类        System.out.println(&quot;拨号上网...连接成功！&quot;);    }    @Override    public void access(String url) {//同样实现互联网访问接口方法        for (String keyword : blackList) {//循环黑名单            if (url.contains(keyword)) {//是否包含黑名单字眼                System.out.println(&quot;禁止访问：&quot; + url);                return;            }        }        modem.access(url);//正常访问互联网    }}</code></pre><p>注意看，在这里路由器代理主要充当代理的角色，和之前的“猫”一样，它同样实现了互联网接口，看似也是有上网功能的，其实不然。第12行代码对于互联网访问功能的实现一开始就做了个过滤，如果地址中带有黑名单中的敏感字眼则禁止访问并直接退出，反之则于第19行调用“猫”的互联网访问方法，看到了吧，最终还是调用“猫”的上网功能。注意此处为了对“猫”进行控制，代理专为此而生，我们直接于第7行实例化它而不是需要别人把它注入进来。好了，孩子现在来上网了，迫不及待运行之。</p><pre><code class="java">public class Client {    public static void main(String[] args) {        Internet proxy = new RouterProxy();//实例化的是代理        proxy.access(&quot;http://www.电影.com&quot;);        proxy.access(&quot;http://www.游戏.com&quot;);        proxy.access(&quot;ftp://www.学习.com/java&quot;);        proxy.access(&quot;http://www.工作.com&quot;);        /* 运行结果            拨号上网...连接成功！            禁止访问：http://www.电影.com            禁止访问：http://www.游戏.com            正在访问：ftp://www.学习.com/java            正在访问：http://www.工作.com        */    }}</code></pre><p>在第3行处，孩子实例化的不再是“猫”，而是被偷梁换柱的替换为路由器代理了，也就是说大家上网都连接路由器了，而不是直接去连“猫”，这样不但省去了我们拨号的麻烦（路由器帮助拨号）而且孩子再也访问不到乱七八糟的网站了。而这个代理自身其实并不具备访问互联网的能力，它只是简单的调用“猫”上网功能，其存在目的只是为了控制对”猫“的互联访问，对其进行代理而已。</p><p>说到这里大家有没有发现这个代理模式是不是与<strong>装饰器模式</strong>很类似？如果观察<code>UML</code>类图关系你会发现几乎一模一样，那这个模式存在的意义何在？其实，代理模式更强调的是对被代理对象的控制，而不是仅限于去装饰目标对象并增强其原有的功能。就像明星的例子一样，如果钱没给够，合同未达成，则不让明星随意作秀。</p><p>相信大家已经理解地很通透了吧，这也是我们最常用的代理模式了。其实还有一种叫动态代理，不同之处在于其实例化过程是在运行时完成的，也就是说我们不需要专门针对某个接口去写这么一个代理类，而是根据接口动态生成。</p><p>举个例子，让我们先忘掉之前的路由器代理，当我们内网中的上网设备越来越多，路由器的<code>Lan</code>口已被占满不够用了，于是我们决定换成交换机，看代码:</p><pre><code class="java">public interface Intranet {//局域网访问接口    public void fileAccess(String path);}</code></pre><p>为了保持简单，我们假设这个交换机Switch实现了局域网访问接口<code>Intranet</code>，请注意这里不是互联网接口<code>Internet</code>。</p><pre><code class="java">public class Switch implements Intranet {    @Override    public void fileAccess(String path){        System.out.println(&quot;访问内网：&quot; + path);    }}</code></pre><p>这里进行的是局域网文件访问，比如说是拷贝另一台内网机器上的共享文件，并且我们想保证与之前一样的关键字过滤控制功能，也就是说不管是什么地址都要先通过过滤，怎么复用呢？</p><p>到这里让我们思考一下，猫实现的是互联网访问接口，交换机实现的是局域网访问接口，那我们的过滤器代理类到底该怎么写？是实现<code>Internet</code>接口呢还是实现<code>Intranet</code>接口呢？要么两个都实现？再加进来新的类接口又要不停地改实现类吗？这显然行不通，过滤器无非就是一段过滤逻辑不必来回改动，这违反了设计模式开闭原则。动态代理应时而生，我们来看代码:</p><pre><code class="java">public class KeywordFilter implements InvocationHandler {    private List&lt;String&gt; blackList = Arrays.asList(&quot;电影&quot;, &quot;游戏&quot;, &quot;音乐&quot;, &quot;小说&quot;);    // 被代理的真实对象,猫、交换机、或是别的什么都是。    private Object origin;    public KeywordFilter(Object origin) {        this.origin = origin;//注入被代理对象        System.out.println(&quot;开启关键字过滤模式...&quot;);    }    @Override    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {        //要被切入方法面之前的业务逻辑        String arg = args[0].toString();        for (String keyword : blackList) {            if (arg.toString().contains(keyword)) {                System.out.println(&quot;禁止访问：&quot; + arg);                return null;            }        }        //调用真实的被代理对象方法        return method.invoke(origin, arg);    }}</code></pre><p>对于这个关键字过滤功能我们不再写到代理类里面了，而是另外写个类并实现<code>JDK</code>反射包中提供的<code>InvocationHandler</code>接口，于第9行注入即将被代理的对象，不管是猫还是交换机什么的它总归是个<code>Object</code>，然后在第14行实现这个<code>invoke</code>调用方法，之后生成的动态代理将来会调进来跑这块的逻辑，很显然我们这里依然保持不变的逻辑，在真实对象方法被执行之前运行了过滤逻辑加以控制。由于传入的参数是被代理对象的方法<code>method</code>，以及一堆参数<code>args</code>，所以注意这里第24行我们要用反射去调用被代理对象<code>origin</code>了，最后来看我们如何运行。</p><pre><code class="java">public class Client {    public static void main(String[] args) {        //访问外网（互联网）,生成猫代理。        Internet internet = (Internet) Proxy.newProxyInstance(                Modem.class.getClassLoader(),                Modem.class.getInterfaces(),                 new KeywordFilter(new Modem()));        internet.access(&quot;http://www.电影.com&quot;);        internet.access(&quot;http://www.游戏.com&quot;);        internet.access(&quot;http://www.学习.com&quot;);        internet.access(&quot;http://www.工作.com&quot;);        //访问内网（局域网），生成交换机代理。        Intranet intranet = (Intranet) Proxy.newProxyInstance(                Switch.class.getClassLoader(),                Switch.class.getInterfaces(),                 new KeywordFilter(new Switch()));        intranet.fileAccess(&quot;\\\\192.68.1.2\\共享\\电影\\IronHuman.mp4&quot;);        intranet.fileAccess(&quot;\\\\192.68.1.2\\共享\\游戏\\Hero.exe&quot;);        intranet.fileAccess(&quot;\\\\192.68.1.4\\shared\\Java学习资料.zip&quot;);        intranet.fileAccess(&quot;\\\\192.68.1.6\\Java知音\\设计模式是什么鬼.doc&quot;);        /*            开启关键字过滤模式...            禁止访问：http://www.电影.com            禁止访问：http://www.游戏.com            正在访问：http://www.学习.com            正在访问：http://www.工作.com            开启关键字过滤模式...            禁止访问：\\192.68.1.2\共享\电影\IronHuman.mp4            禁止访问：\\192.68.1.2\共享\游戏\Hero.exe            访问内网：\\192.68.1.4\shared\Java学习资料.zip            访问内网：\\192.68.1.6\Java知音\设计模式是什么鬼.doc        */    }}</code></pre><p>可以看到，我们不管是访问互联网还是局域网，只需要分别生成相应的代理并调用即可，相同的过滤器逻辑被执行了。如此一来，我们并不需要再写任何的代理类了，只需要实现一次<code>InvocationHandler</code>就一劳永逸了，在运行时去动态地生成代理，达到兼容任何接口的目的。</p><p>其实在很多框架中大量应用到了动态代理模式，比如<code>Spring</code>的面向切面<code>AOP</code>，我们只需要定义好一个切面类<code>@Aspect</code>，声明其切入点<code>@Pointcut</code>（被代理的哪些对象的哪些方法，也就是这里的猫和交换机的<code>access</code>以及<code>accessFile</code>），以及被切入的代码块（要增加上去的逻辑，比如这里的过滤功能代码，可分为前置执行<code>@Before</code>，后置执行<code>@After</code>，以及异常处理<code>@AfterThrowing</code>等），于是框架自动帮我们生成代理并切入目标执行。正如给每给方法前后加入日志的例子，或者更经典的事务控制的例子，在所有业务代码之前先切入“事务开始”，执行过后再切入“事务提交”，如果抛异常被捕获则执行“事务回滚”，如此就不必要在每个业务类中去写这些重复代码了，一劳永逸，冗余代码大量减少，开发效率惊人提升。</p><h3 id="定义说明-12"><a href="#定义说明-12" class="headerlink" title="定义说明"></a>定义说明</h3><p><strong>定义：</strong></p><p>为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用</p><p><strong>角色：</strong></p><ul><li><p><strong>抽象角色：</strong>声明真实对象和代理对象的共同接口。</p></li><li><p><strong>代理角色：</strong>代理对象角色内部含有对真实对象的引用，从而可以操作真实对象，同时代理对象提供与真实对象相同的接口以便在任何时刻都能代替真实对象。同时，代理对象可以在执行真实对象操作时，附加其他的操作，相当于对真实对象进行封装。</p></li><li><p><strong>真实角色：</strong>代理角色所代表的真实对象，是我们最终要引用的对象。</p></li></ul><p><strong>分类：</strong></p><p><strong>静态代理</strong></p><p>静态代理也就是在程序运行前就已经存在代理类的字节码文件，代理类和委托类的关系在运行前就确定了。</p><p><strong>动态代理</strong></p><p>动态代理类的源码是程序在运行期间由<code>JVM</code>根据反射等机制动态生成的，所以不存在代理类的字节码文件。代理角色和真实角色的联系在程序运行时确定。</p><p><strong>优点：</strong></p><p>业务类只需要关注业务逻辑本身，保证了业务类的重用性。这是代理的共有优点。</p><p>能够协调调用者和被调用者，在一定程度上降低了系统的耦合度。</p><p><strong>缺点：</strong></p><p>由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢，例如保护代理。</p><p>实现代理模式需要额外的工作，而且有些代理模式的实现过程较为复杂，例如远程代理。</p><h2 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h2><h3 id="初步理解-13"><a href="#初步理解-13" class="headerlink" title="初步理解"></a>初步理解</h3><p>工厂是对对象构造、实例化、初始化过程的一种封装，以提供给其他需要对象的地方去使用，以降低耦合，提高系统的扩展性，重用性。众所周知，当我们需要把类实例化成对象的时候，需要用到关键字<code>new</code>，比如<code>Plane = new Plane()</code>，这也是我们最常用的方式了。</p><p>然而，这样做的结果就是会把这个对象的诞生过程死死捆绑在我们的代码里，宿主类与实例化过程强耦合。对于一些庞大复杂的系统来说，过多的实例化逻辑于宿主类中会给其后期的维护与扩展带来很多麻烦。</p><p>而事实是我们根本不关心到底使用哪个对象；怎样生产出它的实例；制造过程是怎样，我们只在乎谁能给我产品来完成我的任务。为了满足用户需求，解决用户的痛点，工厂粉墨登场。</p><p>相信大家都玩过打飞机游戏吧，虽然这个主题的游戏版本繁杂但大同小异，都逃不出主角强大的武器系统，以及敌众我寡的战斗形式，所以敌人的种类就得花样百出以带来丰富多样的游戏体验。那么就从这款游戏入手，开始代码。</p><p>首先来定义所有敌人的总抽象，我们想想，敌人们统统都得有一对坐标用来表达位置状态，以便可以把敌人绘制到地图上。为了让子类继承坐标，这里我们使用抽象类来定义敌人。</p><pre><code class="java">public abstract class Enemy {    //敌人的坐标，会被子类继承。    protected int x;    protected int y;    //初始化坐标    public Enemy(int x, int y){        this.x = x;        this.y = y;    }    //抽象方法，在地图上绘制。    public abstract void show();}</code></pre><p>这里我们只定义一个抽象方法<code>show</code>，可以把敌人绘制在地图上（下一帧会擦除重绘到下一个坐标以实现动画），当然真正的游戏或许还会有<code>move</code>（移动）、<code>attack</code>（攻击）、<code>die</code>（死亡）等等方法我们这里保持简单就忽略掉了。接下来是具体子类，我们这里假设只有两种，敌机类和坦克类。</p><pre><code class="java">public class Airplane extends Enemy {    public Airplane(int x, int y){        super(x, y);//调用父类构造子初始化坐标    }    @Override    public void show() {        System.out.println(&quot;飞机出现坐标：&quot; + x + &quot;,&quot; + y);        System.out.println(&quot;飞机向玩家发起攻击……&quot;);    }}</code></pre><pre><code class="java">public class Tank extends Enemy {    public Tank(int x, int y){        super(x, y);    }    @Override    public void show() {        System.out.println(&quot;坦克出现坐标：&quot; + x + &quot;,&quot; + y);        System.out.println(&quot;坦克向玩家发起攻击……&quot;);    }}</code></pre><p>一如既往地简单，飞机和坦克分别实现不同的show()方法。接下来开始运行游戏并实例化敌人了，重点在于怎样去实例化这些敌人，毋庸置疑要使它们出现在屏幕最上方，也就是纵坐标y等于0，但对于横坐标x我们怎样去初始化呢？写个死值么？这对于游戏可玩性来说是非常糟糕的，玩家会对每次在同一位置出现的敌人烂熟于心，长期下来会觉得无聊，游戏性大打折扣。我们来看是怎样解决这个问题，看客户端代码。</p><pre><code class="java">public class Client {    public static void main(String[] args) {        int screenWidth = 100;//屏幕宽度        System.out.println(&quot;游戏开始&quot;);        Random random = new Random();//准备随机数        int x = random.nextInt(screenWidth);//生成敌机横坐标随机数        Enemy airplan = new Airplane(x, 0);//实例化飞机        airplan.show();//显示飞机        x = random.nextInt(screenWidth);//坦克同上        Enemy tank = new Tank(x, 0);        tank.show();        /*输出结果：            游戏开始            飞机出现坐标：94,0            飞机向玩家发起攻击……            坦克出现坐标：89,0            坦克向玩家发起攻击……        */}</code></pre><p>对，我们在第8行获取了一个从0到屏幕宽度（为了不让敌人出现在屏幕之外）的随机数，作为敌人的横坐标并初始化了敌人，这样每次出现的位置就会不一样了，游戏随机性增强，问题解决了（我们保持简单不考虑敌人自身的宽度）。我们发现从第8行和第12行是在做同样的事情，如果其他地方也需要实例化会出现重复的逻辑，尤其我们还进行了代码省略，实际的逻辑会更复杂，重复代码会更多。如此耗时费力，何不把这些实例化逻辑抽离出来作为一个工厂类？好，开始简单工厂的开发。</p><pre><code class="java">public class SimpleFactory {    private int screenWidth;    private Random random;//随机数    public SimpleFactory(int screenWidth) {        this.screenWidth = screenWidth;        this.random = new Random();    }    public Enemy create(String type){        int x = random.nextInt(screenWidth);//生成敌人横坐标随机数        Enemy enemy = null;        switch (type) {        case &quot;Airplane&quot;:            enemy = new Airplane(x, 0);//实例化飞机            break;        case &quot;Tank&quot;:            enemy = new Tank(x, 0);//实例化坦克            break;        }        return enemy;    }}</code></pre><p>其实这就是简单工厂了，为客户端省去了很多烦扰，于是我们的代码变得异常简单。</p><pre><code class="java">public class Client {    public static void main(String[] args) {        System.out.println(&quot;游戏开始&quot;);        SimpleFactory factory = new SimpleFactory(100);        factory.create(&quot;Airplane&quot;).show();        factory.create(&quot;Tank&quot;).show();    }}</code></pre><p>然而，这个简单工厂并不是一种设计模式，它只是对实例化逻辑进行了一层简单包裹而已，客户端依然是要告诉工厂我要的是哪个产品，虽然没有出现对产品实例化的关键字new，但这依然无疑是另一种形式的耦合。虽然我们在简单工厂中巧妙利用了坐标随机化来丰富游戏性，但又一个问题出现了，虽然坐标随机变化，但敌人的种类总是不变，游戏又开始变得无聊起来，于是随机生产敌人的工厂迫在眉睫。</p><p>我们开始思考，需要再在简单工厂里加个方法<code>createRandomEnemy()</code>？然后也许还需要其他生产方式再继续添加方法？随着之后版本升级，敌人种类的增多，我们再回来继续修改这个工厂类？于是这个工厂会越来越大，变得难以维护，简单工厂不简单，这显然违反了设计模式原则。</p><p>从另一方面来讲，用户的需求是多变的，我们要满足各种复杂情况，其实有些时候客户端目的很明确单纯，就是简单的需要工厂生产一个坦克而已，那么我们还有必要加载实例化这么臃肿一个简单工厂类么？问题显而易见了，简单工厂应对简单情况，而针对我们的场景，简单工厂需要多态化，我们应该对生产方式（工厂方法）进行抽象化。首先，定义一个工厂接口。</p><pre><code class="java">public interface Factory {    public Enemy create(int screenWidth);}</code></pre><p>这个工厂接口就是工厂方法的核心了，它具备这么一个功能（第3行），可以在屏宽之内来产出一个敌人，这就是我们抽象出来的工厂方法。然后我们来定义这个工厂方法的子类实现，随机工厂。</p><pre><code class="java">public class RandomFactory implements Factory {    private Random random = new Random();    @Override    public Enemy create(int screenWidth){        Enemy enemy = null;        if(random.nextBoolean()){            enemy = new Airplane(random.nextInt(screenWidth), 0);//实例化飞机        }else{            enemy = new Tank(random.nextInt(screenWidth), 0);//实例化坦克        }        return enemy;    }}</code></pre><p>代码非常简洁明了，这个随机工厂无疑具备生产实力，也就是在第6行实现的工厂方法，但其产出方式是随机产出，拒不退换，我只管努力制造，但出来的是飞机还是坦克，这个由天定。</p><p>这也许有点霸权主义，我们也许需要加一些其他工厂，比如某局出现了太多的坦克，一个飞机都没有，这是工厂的随机机制造成的，于是我们可以增加一个平衡工厂让飞机和坦克交替生成，这就好比大型网站上的负载均衡的平衡策略一样，让服务器轮流接受请求。</p><p>除了以上工厂，我们或许可以为每关做一个脚本工厂，根据主角关卡进度生产该出现的敌人，又或许更具体点为每个产品做一个工厂，总之，我们可以灵活地根据自己的具体需求去实现不同的工厂，每个工厂的生产策略和方式是不同的，最终是由客户端去决定用哪个工厂生产产品。比如，玩家抵达关底，boss要出现了。</p><pre><code class="java">public class Boss extends Enemy {    public Boss(int x, int y){        super(x, y);    }    @Override    public void show() {        System.out.println(&quot;Boss出现坐标：&quot; + x + &quot;,&quot; + y);        System.out.println(&quot;Boss向玩家发起攻击……&quot;);    }}</code></pre><p>接着来实现Boss的工厂方法，此处要注意Boss出现坐标是在屏幕中央，在第6行处设置横坐标为屏幕的一半。</p><pre><code class="java">public class BossFactory implements Factory {    @Override    public Enemy create(int screenWidth) {        // boss应该出现在屏幕中央        return new Boss(screenWidth / 2, 0);    }}</code></pre><p>完美，万事俱备，只欠东风，开始运行游戏。</p><pre><code class="java">public class Client {    public static void main(String[] args) {        int screenWidth = 100;        System.out.println(&quot;游戏开始&quot;);        Factory factory = new RandomFactory();        for (int i = 0; i &lt; 10; i++) {            factory.create(screenWidth).show();        }        System.out.println(&quot;抵达关底&quot;);        factory = new BossFactory();        factory.create(screenWidth).show();        /*            游戏开始            飞机出现坐标：27,0            飞机向玩家发起攻击……            坦克出现坐标：40,0            坦克向玩家发起攻击……            飞机出现坐标：30,0            飞机向玩家发起攻击……            坦克出现坐标：53,0            坦克向玩家发起攻击……            坦克出现坐标：19,0            坦克向玩家发起攻击……            飞机出现坐标：18,0            飞机向玩家发起攻击……            坦克出现坐标：27,0            坦克向玩家发起攻击……            飞机出现坐标：89,0            飞机向玩家发起攻击……            飞机出现坐标：24,0            飞机向玩家发起攻击……            飞机出现坐标：31,0            飞机向玩家发起攻击……            抵达关底            Boss出现坐标：50,0            Boss向玩家发起攻击……        */    }}</code></pre><p>此处我们于第7行循环10次调用随机工厂生成随机敌人，有时出飞机，有时出坦克，玩家永远猜不透。抵达关底后于第11行换成Boss工厂，并生成Boss，如此一来，我们有产品需要就直接问工厂索要便是，至此客户端与敌人的实例化解耦脱钩。</p><p>相比简单工厂，工厂方法可以被看做是一个升级为设计模式的变种，其工厂方法的抽象化带来了极大好处，与其把所有生产方式堆积在一个简单工厂类中，不如把生产方式被推迟到具体的子类工厂中实现，工厂本身也是需要分类的，这样后期的代码维护以及对新产品的扩展都会更加方便直观，而不是对单一工厂类翻来覆去地不停改动。</p><p>工厂不是万能的，方便面工厂不能生产汽车，手机工厂更不能生产辣条，这本身就看起来很荒诞，妄想吞噬兼备所有产品的工厂不是好的专业工厂。</p><h3 id="定义说明-13"><a href="#定义说明-13" class="headerlink" title="定义说明"></a>定义说明</h3><p><strong>定义</strong>：</p><p>工厂模式是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p><p>工厂模式主要是为创建对象提供过渡接口，以便将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的。</p><p><strong>工厂模式根据抽象程度的不同分为三种：</strong></p><ul><li><p>简单工厂模式（也叫静态工厂模式）</p></li><li><p>工厂方法模式（也叫多形性工厂）</p></li><li><p>抽象工厂模式（也叫工具箱）</p></li></ul><p><strong>简单工厂模式</strong></p><p>实质是由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类（这些产品类继承自一个父类或接口）的实例。简单工厂模式的创建目标，所有创建的对象都是充当这个角色的某个具体类的实例。 </p><p><strong>工厂方法模式</strong></p><p>工厂方法是粒度很小的设计模式，因为模式的表现只是一个抽象的方法。 提前定义用于创建对象的接口，让子类决定实例化具体的某一个类，即在工厂和产品中间增加接口，工厂不再负责产品的创建，由接口针对不同条件返回具体的类实例，由具体类实例去实现。</p><p><strong>抽象工厂模式</strong></p><p>当有多个抽象角色时使用的一种工厂模式。抽象工厂模式可以向客户端提供一个接口，使客户端在不必指定产品的具体的情况下，创建多个产品对象。它有多个抽象产品类，每个抽象产品类可以派生出多个具体产品类，一个抽象工厂类，可以派生出多个具体工厂类，每个具体工厂类可以创建多个具体产品类的实例。</p><p><strong>工厂模式的优点：</strong></p><ul><li><p>一个调用者想创建一个对象，只要知道其名称就可以了，降低了耦合度。</p></li><li><p>扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。使得代码结构更加清晰。</p></li><li><p>屏蔽产品的具体实现，调用者只关心产品的接口。</p></li></ul><p><strong>工厂模式的缺点：</strong></p><p>每次增加一个产品时，都需要增加一个具体类和对象实现工厂（这里可以使用反射机制来避免），使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。所以对于简单对象来说，使用工厂模式反而增加了复杂度。</p><p><strong>工厂模式的适用场景：</strong></p><ul><li><p>一个对象拥有很多子类。</p></li><li><p>创建某个对象时需要进行许多额外的操作。</p></li><li><p>系统后期需要经常扩展，它把对象实例化的任务交由实现类完成，扩展性好。</p></li></ul><p><strong>总结：</strong></p><p>无论是简单工厂模式、工厂模式还是抽象工厂模式，它们本质上都是将不变的部分提取出来，将可变的部分留作接口，以达到最大程度上的复用。究竟用哪种设计模式更适合，这要根据具体的业务需求来决定。</p><h2 id="桥接（Bridge）"><a href="#桥接（Bridge）" class="headerlink" title="桥接（Bridge）"></a>桥接（Bridge）</h2><h3 id="初步理解-14"><a href="#初步理解-14" class="headerlink" title="初步理解"></a>初步理解</h3><p>桥接，用桥梁连接，英文叫Bridge，其实就是桥梁之意。</p><p>现在假设我们要作一幅抽象画，用各种形状的色块来表达世界文化的多样性，起名《形形色色》。</p><p>需要什么工具来作画呢？一堆彩笔和一堆尺子。嗯，据我所知，这两种工具分别产于两个孤岛，北岛有很多颜料，擅长制造画笔，南岛则擅长生产尺子，各种形状的尺子，这是劳动分工的最佳典范，下来我们就要去促进南北文具经济合作了，先来看看南岛生产的尺子产品。</p><p>这些尺子不管是什么形状，其实都是对绘画线条提供一种规范，那我们就先定义一个尺子的接口，用于规则化笔触的走向。</p><pre><code class="java">public interface Ruler {// 尺子    // 规则化笔触走向    public void regularize();}</code></pre><p>对于具体的尺子类，我们暂且忽略其大小，一种形状就对应一个类，分别是方形、三角形、还有圆形，它们统统实现尺子的规则接口。</p><pre><code class="java">public class SquareRuler implements Ruler {  @Override  public void regularize() {//尺子模板画出正方形    System.out.println(&quot;□&quot;);  }}</code></pre><pre><code class="java">public class TriangleRuler implements Ruler {  @Override  public void regularize() {//尺子模板画出三角形    System.out.println(&quot;△&quot;);  }}</code></pre><pre><code class="java">public class CircleRuler implements Ruler {  @Override  public void regularize() {//尺子模板画出圆形    System.out.println(&quot;○&quot;);  }}</code></pre><p>南岛经济很简单，下来看北岛产品，他们生产的是五颜六色的彩色画笔。</p><p>我们对画笔进行抽象，此处我们用抽象类。</p><pre><code class="java">public abstract class Pen {//画笔  protected Ruler ruler;//尺子的引用  public Pen(Ruler ruler) {    this.ruler = ruler;  }  public abstract void draw();//抽象方法}</code></pre><p>注意这里的抽象画笔（第3行）引用了尺子接口，并且声明为protected，得以让彩笔子类进行继承，并由第5行构造子注入尺子，此处便是桥梁对接的重点。最后就是第9行的draw方法了，这个需要具体的彩笔子类进行实现。</p><p>接下来看彩笔类，我们依旧保持简约，只实现黑色和白色两种画笔。</p><pre><code class="java">public class BlackPen extends Pen {  public BlackPen(Ruler ruler) {    super(ruler);  }  @Override  public void draw() {      System.out.print(&quot;黑&quot;);      ruler.regularize();  }}</code></pre><pre><code class="java">public class WhitePen extends Pen {  public WhitePen(Ruler ruler) {    super(ruler);  }  @Override  public void draw() {      System.out.print(&quot;白&quot;);      ruler.regularize();  }}</code></pre><p>我们在第4行的构造子中调用了抽象画笔的构造子注入传入的尺子，建立桥梁的连接，在第9行选用自己的颜色进行绘画并于第10行调用尺子进行笔触规范。一切就绪，我们开始绘制史诗巨著。</p><pre><code class="java">public class Client {    public static void main(String args[]) {        //白色画笔对应的所有形状        new WhitePen(new CircleRuler()).draw();        new WhitePen(new SquareRuler()).draw();        new WhitePen(new TriangleRuler()).draw();        //黑色画笔对应的所有形状        new BlackPen(new CircleRuler()).draw();        new BlackPen(new SquareRuler()).draw();        new BlackPen(new TriangleRuler()).draw();        /*运行结果：            白○            白□            白△            黑○            黑□            黑△        */    }}</code></pre><p>注意看我们是怎样进行实例化的，初始化彩笔确定其颜色并注入并确定其形状，紧接着画出来的就是相应的形色组合了。简单吧？接下来就交给南北岛的工人们去做各种形状的尺子和颜色的画笔了，画家会利用这些工具随意组合创作出自己想要的画作。</p><p>试想如果有更多的颜色和形状，且没有这种松散分离的结构要多少个类来实现？那将会是一场噩梦。有没有发现这就是笛卡儿积的组合，来看我们的代码中的两个集合：</p><p><strong>颜色集合</strong>=<em>{黑，白}</em></p><p>  <strong>形状集合</strong>=<em>{圆形，方形，三角}</em></p><p>  那么这两个集合的笛卡尔积为</p><p>  {</p><p>​    <em>(黑，圆形)， (黑，方形)， (黑，三角)，</em></p><p>​    <em>(白，圆形)， (白，方形)， (白，三角)</em></p><p>  }</p><p>我们发现这个结构是不是有点像<strong>策略模式</strong>？其实策略更强调的是行为的替换，就像是之前例子中我们可以随意替换<code>USB</code>接口上接入的各种设备而改变输入输出行为，那对于宿主（电脑主机）本身是耦合了<code>USB</code>接口的，我们无法进行替换，只能重新写个全新的宿主并重新焊接<code>USB</code>接口了。但对于桥接模式而言，它巧妙运用了抽象类（抽象画笔类）植入接口（尺子接口），这样我们不但能替换各种形状的尺子实现类，还能替换各种颜色的画笔子类，这就是对抽象、实现的双边解耦、分离、脱钩。</p><h3 id="定义说明-14"><a href="#定义说明-14" class="headerlink" title="定义说明"></a>定义说明</h3><p><strong>介绍</strong></p><p>桥接模式 (Bridge)将抽象部分与实现部分分离，使它们都可以独立的变化。桥接模式是一种结构式模式。</p><p><strong>应用场景</strong></p><ul><li>如果你不希望在抽象和实现部分采用固定的绑定关系，可以采用桥接模式，来把抽象和实现部分分开，</li></ul><p>然后在程序运行期间来动态的设置抽象部分需要用到的具体的实现，还可以动态切换具体的实现。</p><ul><li>如果出现抽象部分和实现部分都应该可以扩展的情况，可以采用桥接模式，让抽象部分和实现部分可以</li></ul><p>独立的变化，从而可以灵活的进行单独扩展，而不是搅在一起，扩展一边会影响到另一边。</p><ul><li>如果希望实现部分的修改，不会对客户产生影响，可以采用桥接模式，客户是面向抽象的接口在运行，</li></ul><p>实现部分的修改，可以独立于抽象部分，也就不会对客户产生影响了，也可以说对客户是透明的。</p><ul><li>如果采用继承的实现方案，会导致产生很多子类，对于这种情况，可以考虑采用桥接模式，分析功能变化的原因，看看是否能分离成不同的纬度，然后通过桥接模式来分离它们，从而减少子类的数目。</li></ul><p><strong>要点</strong></p><p>如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的联系。<br>抽象化角色和具体化角色都应该可以被子类扩展。在这种情况下，桥接模式可以灵活地组合不同的抽象化角色和具体化角色，并独立化地扩展。<br>设计要求实现化角色的任何改变不应当影响客户端，或者说实现化角色的改变对客户端是完全透明的。</p><h2 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h2><h3 id="初步理解-15"><a href="#初步理解-15" class="headerlink" title="初步理解"></a>初步理解</h3><p>抽象工厂，意味着工厂的泛化，也就是说对多个工厂共通行为的抽取及概括。这和我们之前讲过的工厂方法模式十分类似，不同之处在于抽象工厂定义了更多的抽象行为，也就是多个工厂方法于抽象工厂中，其实它就是工厂方法的变种而已，所以建议读者先理解好<strong>工厂方法模式</strong>再回来看本章。</p><p>我们都知道，在工厂方法模式中的每个实际的工厂只定义了一个工厂方法，如果产品种类繁多，并且能进行归类分族的话，那么我们便可以顺理成章的定义多个工厂方法，如此可以避免过多的产品造成工厂泛滥的问题。比如宝驹汽车有轿车、SUV、跑车三个等级的产品，而奔痴汽车也同样包括以上三类等级产品，如此便形成了两个产品族，分别由宝驹工厂和奔痴工厂生产，每个工厂都有三个等级的生产线，以及后加入的四环汽车产品族同样可以符合这个规范模式。</p><p>我们以一款即时战略游戏来举例，假设游戏中有两个种族，地球人类与外星异形族，其中人类族拥有各种高科技军工制造技术，而怪兽异形族则是以血肉之躯的不断进化与人类抗衡。</p><p>在开始代码之前我们先对两族兵种进行分析归纳，我们看到人类兵工厂和怪兽兵工厂（母巢）产出兵种都可以被简单归纳为初、中、高三个等级，如下表所示。</p><p>好了，产品族已经定义清楚了，开始建立数据模型。首先定义产品的父类抽象兵种Unit，这里我们使用抽象类以达到属性延申遗传给子类的目的。</p><pre><code class="java">public abstract class Unit {// 兵种    protected int attack;// 攻击力    protected int defence;// 防御力    protected int health;// 血量    protected int x;// 横坐标    protected int y;// 纵坐标    public Unit(int attack, int defence, int health, int x, int y) {        this.attack = attack;        this.defence = defence;        this.health = health;        this.x = x;        this.y = y;    }    public abstract void show();    public abstract void attack();}</code></pre><p>不管是什么兵种必然会具有攻击力、防御力、血量体力值、坐标方位等等属性，我们都定义为<code>protected</code>以供子类继承，除此之外还有两个抽象方法显示和攻击。接下来是人类的产品族海军陆战队士兵、变形坦克和巨型战舰，它们分别对应初、中、高级兵种。</p><pre><code class="java">public class Marine extends Unit {// 海军陆战队士兵    public Marine(int x, int y) {        super(6, 5, 40, x, y);    }    @Override    public void show() {        System.out.println(&quot;士兵出现在坐标：[&quot; + x + &quot;,&quot; + y + &quot;]&quot;);    }    @Override    public void attack() {        System.out.println(&quot;士兵用机关枪射击，攻击力：&quot; + attack);    }17}</code></pre><pre><code class="java">public class Tank extends Unit {// 坦克    public Tank(int x, int y) {        super(25, 100, 150, x, y);    }    @Override    public void show() {        System.out.println(&quot;坦克出现在坐标：[&quot; + x + &quot;,&quot; + y + &quot;]&quot;);    }    @Override    public void attack() {        System.out.println(&quot;坦克用炮轰击，攻击力：&quot; + attack);    }}</code></pre><pre><code class="java">public class Battleship extends Unit {// 巨型战舰    public Battleship(int x, int y) {        super(25, 200, 500, x, y);    }    @Override    public void show() {        System.out.println(&quot;战舰出现在坐标：[&quot; + x + &quot;,&quot; + y + &quot;]&quot;);    }    @Override    public void attack() {        System.out.println(&quot;战舰用激光炮打击，攻击力：&quot; + attack);    }}</code></pre><p>可以看到每个兵种的属性值都不同，我们在第4行的构造方法中调用了父类构造，直接赋值给遗传下来的属性，兵种越高攻击防御越高（当然制造成本也更高，这里我们忽略价格），而且都重写了自己的展示和攻击方法，行为差异化，当然也许坦克会具备其他特有的行为比如变形什么的（异形也许会打洞钻地），我们此处依然忽略，保持简约。然后定义外星生物家族的三级兵种，分别是：蟑螂、毒液、猛犸。</p><pre><code class="java">public class Roach extends Unit {// 外星蟑螂兵    public Roach(int x, int y) {        super(5, 2, 35, x, y);    }    @Override    public void show() {        System.out.println(&quot;蟑螂兵出现在坐标：[&quot; + x + &quot;,&quot; + y + &quot;]&quot;);    }    @Override    public void attack() {        System.out.println(&quot;蟑螂兵用爪子挠，攻击力：&quot; + attack);    }}</code></pre><pre><code class="java">public class Spitter extends Unit {// 外星毒液口水兵    public Spitter(int x, int y) {         super(10, 8, 80, x, y);    }    @Override    public void show() {        System.out.println(&quot;口水兵出现在坐标：[&quot; + x + &quot;,&quot; + y + &quot;]&quot;);    }    @Override    public void attack() {        System.out.println(&quot;口水兵用毒液喷射，攻击力：&quot; + attack);    }}</code></pre><pre><code class="java">public class Mammoth extends Unit {// 外星猛犸巨兽    public Mammoth(int x, int y) {        super(20, 100, 400, x, y);    }    @Override    public void show() {        System.out.println(&quot;猛犸巨兽兵出现在坐标：[&quot; + x + &quot;,&quot; + y + &quot;]&quot;);    }    @Override    public void attack() {        System.out.println(&quot;猛犸巨兽用獠牙顶，攻击力：&quot; + attack);    }}</code></pre><p>没什么好说的，大同小异。重点来了，接下来是我们的抽象工厂，概括出三个等级兵种的标准制造方法，我们这里以接口来定义它。</p><pre><code class="java">public interface AbstractFactory {    public Unit createLowClass();// 工厂方法：制造低级兵种    public Unit createMidClass();// 工厂方法：制造中级兵种    public Unit createHighClass();// 工厂方法：制造高级兵种}</code></pre><p>可以看到，三个等级的接口意味着子类具体工厂必须具备初、中、高级三条生产线，它们同属一个家族，或者说是一个品牌的不同型号系列。理解了这一点后我们可以开始定义人类兵工厂的实现。</p><pre><code class="java">public class HumanFactory implements AbstractFactory{    //人族工厂坐标    private int x;    private int y;    public HumanFactory(int x, int y) {        this.x = x;        this.y = y;    }    @Override    public Unit createLowClass() {        Unit unit = new Marine(x, y);        System.out.println(&quot;制造海军陆战队员成功。&quot;);        return unit;    }    @Override    public Unit createMidClass() {        Unit unit = new Tank(x, y);        System.out.println(&quot;制造变形坦克成功。&quot;);        return unit;    }    @Override    public Unit createHighClass() {        Unit unit = new Battleship(x, y);        System.out.println(&quot;制造巨型战舰成功。&quot;);        return unit;    }}</code></pre><p>可以看到，这个兵工厂实现了人类兵种产品族的制造方法，分别对应三个等级兵种的制造方法，注意第14行的坐标初始化意思是在工厂的坐标位置上出兵。接下来是异形母巢的工厂实现。</p><pre><code class="java">public class AlienFactory implements AbstractFactory{    //外星虫族工厂坐标    private int x;    private int y;    public AlienFactory(int x, int y) {        this.x = x;        this.y = y;    }    @Override    public Unit createLowClass() {        Unit unit = new Roach(x, y);        System.out.println(&quot;制造蟑螂兵成功。&quot;);        return unit;    }    @Override    public Unit createMidClass() {        Unit unit = new Spitter(x, y);        System.out.println(&quot;制造毒液兵成功。&quot;);        return unit;    }    @Override    public Unit createHighClass() {        Unit unit = new Mammoth(x, y);        System.out.println(&quot;制造猛犸巨兽成功。&quot;);        return unit;    }}</code></pre><p>显而易见，同样地分三级制造异形家族的产品系列，工厂准备完毕可以造兵打架了，运行游戏客户端。</p><pre><code class="java">public class Client {    public static void main(String[] args) {        System.out.println(&quot;游戏开始。。。&quot;);        System.out.println(&quot;双方挖矿攒钱。。。&quot;);        //第一位玩家选择了地球人族        System.out.println(&quot;工人建造人族工厂。。。&quot;);        AbstractFactory factory = new HumanFactory(10, 10);        Unit marine = factory.createLowClass();        marine.show();        Unit tank = factory.createMidClass();        tank.show();        Unit ship = factory.createHighClass();        ship.show();        //另一位玩家选择了外星族        System.out.println(&quot;工蜂建造外星虫族工厂。。。&quot;);        factory = new AlienFactory(200, 200);        Unit roach = factory.createLowClass();        roach.show();        Unit spitter = factory.createMidClass();        spitter.show();        Unit mammoth = factory.createHighClass();        mammoth.show();        System.out.println(&quot;两族开始大混战。。。&quot;);        marine.attack();        roach.attack();        spitter.attack();        tank.attack();        mammoth.attack();        ship.attack();        /*            游戏开始。。。            双方挖矿攒钱。。。            工人建造人族工厂。。。            制造海军陆战队员成功。            士兵出现在坐标：[10,10]            制造变形坦克成功。            坦克出现在坐标：[10,10]            制造巨型战舰成功。            战舰出现在坐标：[10,10]            工蜂建造外星虫族工厂。。。            制造蟑螂兵成功。            蟑螂兵出现在坐标：[200,200]            制造毒液兵成功。            口水兵出现在坐标：[200,200]            制造猛犸巨兽成功。            猛犸巨兽兵出现在坐标：[200,200]            两族开始大混战。。。            士兵用机关枪射击，攻击力：6            蟑螂兵用爪子挠，攻击力：5            口水兵用毒液喷射，攻击力：10            坦克用炮轰击，攻击力：25            猛犸巨兽用獠牙顶，攻击力：20            战舰用激光炮打击，攻击力：25          */    }}</code></pre><p>这里我们可以看到，不管玩家选择哪个种族，只要替换工厂实现就可以完成不同兵种的制造，假设玩家又需要一个新的种族，依然按照这种模式去实现一个新族工厂就可以了。</p><p>至此，我们用各族工厂对种类繁多的产品进行了划分、归类，产品虽然繁多，但总得有品牌、型号之分，以各族工厂和产品线划界，分而治之，横向拆分产品家族，纵向则拆分产品等级。</p><h2 id="建造者-生成器"><a href="#建造者-生成器" class="headerlink" title="建造者/生成器"></a>建造者/生成器</h2><h3 id="初步理解-16"><a href="#初步理解-16" class="headerlink" title="初步理解"></a>初步理解</h3><p>建造者，用于对复杂对象的构造、初始化，与工厂模式不同的是，建造者的目的在于把复杂构造过程从不同对象展现中抽离出来，使得同样的构造工序可以展现出不同的产品对象。</p><p>打个比方，我们知道角色扮演类游戏中玩家可以选择不同的职业，各职业攻击力、防御力等等属性设定是不同的，比如战士的力量和体力强，法师的灵力强而体力弱，以及穿戴各种装备引起的属性附加。</p><p>假设我们用同一个类来描述这些角色，那么应该怎样新建人物并配备初始武器？交给客户端去完成，把法师配成战士的力量并给脑袋上装备一把屠龙刀吗？诚然，客户端根本不知道怎样去配置（更没有必要知道），游戏人设应该交给专业的团队（建造者模式）去完成，否则会造成不可预知的混乱角色，如同怪物一般的bug存在。</p><p>好了，让我们来规划一下专业的建造团队。既然是建造者，那就应该造点建造物了，我们就以盖房子举例。</p><p>房子本身有很多个组成部分，各组件息息相关缺一不可，否则房倒屋塌。而其构造过程也是相当复杂的，但大家不必担心，为响应我们简约直观的一贯宗旨，这里只将其简化拆分成地基、墙体、屋顶三部分，首先来看建筑物类。</p><pre><code class="java">public class Building {// 建筑物    // 用来模拟房子组件的堆叠    private List&lt;String&gt; buildingComponents = new ArrayList&lt;&gt;();    public void setBasement(String basement) {// 地基        this.buildingComponents.add(basement);    }    public void setWall(String wall) {// 墙体        this.buildingComponents.add(wall);    }    public void setRoof(String roof) {// 房顶        this.buildingComponents.add(roof);    }    @Override    public String toString() {        String buildingStr = &quot;&quot;;        for (int i = buildingComponents.size() - 1; i &gt;= 0; i--) {            buildingStr += buildingComponents.get(i);        }        return buildingStr;    }}</code></pre><p>为了模拟建筑物通用类中各组件的建造顺序，我们在第4行以List来模拟三个组件的堆叠，之后是它们对应的三个建造方法，最后于第19行的toString方法自下而上的打印出最终完成的房子。看起来是不难，但怎样从这个类直接构造出一个房子呢？怎样去设置这些字符串的组件属性呢？此时客户端一头雾水，还是找个专业施工方吧，先定义个施工方接口。</p><pre><code class="java">public interface Builder {//施工方接口    public void buildBasement();    public void buildWall();    public void buildRoof();    public Building getBuilding();}</code></pre><p>既然是施工方的接口，那一定有实现类了，先来写一个高端别墅施工队。</p><pre><code class="java">public class HouseBuilder implements Builder {//别墅施工方    private Building house;    public HouseBuilder() {        house = new Building();    }    @Override    public void buildBasement() {        System.out.println(&quot;挖地基，部署管道、线缆，水泥加固，搭建围墙、花园。&quot;);        house.setBasement(&quot;╬╬╬╬╬╬╬╬\n&quot;);    }    @Override    public void buildWall() {        System.out.println(&quot;搭建木质框架，石膏板封墙并粉饰内外墙。&quot;);        house.setWall(&quot;｜田｜田 田|\n&quot;);    }    @Override    public void buildRoof() {        System.out.println(&quot;建造木质屋顶、阁楼，安装烟囱，做好防水。&quot;);        house.setRoof(&quot;╱◥███◣\n&quot;);    }    @Override    public Building getBuilding() {        return house;    }}</code></pre><p>嗯，这个施工方看起来是有施工资质的，不管是地基、墙体还是屋顶都讲得（第11行等）头头是道，虽然我们不懂，但建造工艺（第12行等）看起来也都是非常有考究，总之是极其专业的施工方并统统实现了每个组件的建造方法，下来我们同样地再请一个公寓楼的施工队。</p><pre><code class="java">public class ApartmentBuilder implements Builder {// 高层公寓楼施工方    private Building apartment;    public ApartmentBuilder() {        apartment = new Building();    }    @Override    public void buildBasement() {        System.out.println(&quot;深挖地基，修建地下车库，部署管道、线缆、风道。&quot;);        apartment.setBasement(&quot;╚═════════╝\n&quot;);    }    @Override    public void buildWall() {        System.out.println(&quot;搭建多层建筑框架，建造电梯井，钢筋混凝土浇灌。&quot;);        for (int i = 0; i &lt; 8; i++) {// 此处假设固定8层            apartment.setWall(&quot;║ □ □ □ □ ║\n&quot;);        }    }    @Override    public void buildRoof() {        System.out.println(&quot;封顶，部署通风井，做防水层，保温层。&quot;);        apartment.setRoof(&quot;╔═════════╗\n&quot;);    }    @Override    public Building getBuilding() {        return apartment;    }}</code></pre><p>大同小异，公寓楼施工方也是一样的专业，只不过建造工艺好像有些不同，尤其是第16行的建造墙体方法，好像是循环8次造了8层楼的样子，这一定是八层公寓小高层了。到这里，我们好像还是不能交给客户端去亲自调用这三个组件的建造方法，造房子可不是开玩笑的，我们还是得找一个有资质的工程总监去控制整个建造工序流程。</p><pre><code class="java">public class Director {//工程总监    private Builder builder;    public Director(Builder builder) {        this.builder = builder;    }    public void setBuilder(Builder builder) {        this.builder = builder;    }    public Building direct() {        System.out.println(&quot;=====工程项目启动=====&quot;);        // 第一步，打好地基；        builder.buildBasement();        // 第二步，建造框架、墙体；        builder.buildWall();        // 第三步，封顶；        builder.buildRoof();        System.out.println(&quot;=====工程项目竣工=====&quot;);        return builder.getBuilding();    }}</code></pre><p>我们可以看到，工程总监在宏观上操控着整个施工队的建造流程，在第13行的指导方法中以自下而上的顺序建造房屋，他并不在乎是哪个施工队来造房子，但施工步骤是由他来控制的。是时候满足客户的住房刚需了，组建团队，运行程序。</p><pre><code class="java">public class Client {    public static void main(String[] args) {        //招工，建别墅。        Builder builder = new HouseBuilder();        //交给工程总监        Director director = new Director(builder);        System.out.println(director.direct());        //替换施工方，建公寓。        director.setBuilder(new ApartmentBuilder());        System.out.println(director.direct());    }}</code></pre><p>可以看到客户端先找了个别墅施工队（第5行），并且安排给总监（第7行），于是造出了别墅，接着又替换了另一个公寓楼施工队（第10行），最终顺利地建了一栋八层公寓。</p><p>项目终于竣工了，对于复杂对象的构建，专业的建造团队显然是不可或缺的，尤其是产品内部组件间有某种关联性，构建的顺序性，所以我们把制造工序抽离出来交给了工程总监（Director），而产品各种制造工艺则被多态化交给不同的施工方（Builder）去各显神通，最终达成以相同的构造过程生产不同产品的展现的目的，工序不可乱，工艺不可缺。</p><h3 id="定义说明-15"><a href="#定义说明-15" class="headerlink" title="定义说明"></a>定义说明</h3><p><strong>定义：</strong></p><p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。生成器模式利用一个导演者对象和具体建造者对象一个一个地建造出所有的零件，从而建造出完整的对象。</p><p><strong>四个要素：</strong></p><ul><li><p><strong><code>Builder：</code></strong>生成器接口，定义创建一个Product对象所需要的各个部件的操作。</p></li><li><p><strong><code>ConcreteBuilder</code>：</strong>具体的生成器实现，实现各个部件的创建，并负责组装Product对象的各个部件，同时还提供一个让用户获取组装完成后的产品对象的方法。</p></li><li><p><strong><code>Director</code>：</strong>指导者，也被称导向者，主要用来使用Builder接口，以一个统一的过程来构建所需要的Product对象。</p></li><li><p><strong><code>Product</code>：</strong>产品，表示被生成器构建的复杂对象，包含多个部件。</p></li></ul><p><strong>优点：</strong></p><ul><li><p>使用生成器模式可以使客户端不必知道产品内部组成的细节。</p></li><li><p>具体的建造者类之间是相互独立的，对系统的扩展非常有利。</p></li><li><p>由于具体的建造者是独立的，因此可以对建造过程逐步细化，而不对其他的模块产生任何影响。</p></li></ul><p><strong>缺点：</strong></p><p>建造者模式的“加工工艺”是暴露的，这样使得建造者模式更加灵活，也使得工艺变得对客户不透明。（待考证，笔者这里不是很理解，欢迎说自己的见解）</p><p><strong>应用场景：</strong></p><ul><li><p>需要生成一个产品对象有复杂的内部结构。每一个内部成分本身可以是对象，也可以使一个对象的一个组成部分。</p></li><li><p>需要生成的产品对象的属性相互依赖。建造模式可以强制实行一种分步骤进行的建造过程。</p></li><li><p>在对象创建过程中会使用到系统中的其他一些对象，这些对象在产品对象的创建过程中不易得到</p></li></ul><h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><h3 id="初步理解-17"><a href="#初步理解-17" class="headerlink" title="初步理解"></a>初步理解</h3><p>命令模式，通常指的是一个对象向另一个对象发送信息指令的行为模型，比如父母命令孩子写作业、将军命令士兵进攻等。我们经过分析拆解方法会得到三个模块，首先得有命令发送方，接着是被传递的命令本身，最后就是命令的接收执行方了。那么，这样拆解到底有什么好处？让我们先来看一个最简单的例子，电灯泡。</p><p>既然是电灯那一定对应通电和断电的行为接口了，两个接口方法互斥，我们就叫它Switchable吧。</p><pre><code class="java">public interface Switchable {//电器接口    //通电    public void on();    //断电    public void off();}</code></pre><p>对于具体的灯泡实现类，必然是通电亮，断电灭。</p><pre><code class="java">public class Bulb implements Switchable {    @Override    public void on(){        System.out.println(&quot;通电，灯亮。&quot;);    }       @Override    public void off(){        System.out.println(&quot;断电，灯灭。&quot;);    }}</code></pre><p>同样地，我们再增加一个设备，如果是风扇的话则是通电转，断电停。</p><pre><code class="java">public class Fan implements Switchable{    @Override    public void on() {        System.out.println(&quot;通电，风扇转动。&quot;);    }    @Override    public void off() {        System.out.println(&quot;断电，风扇停止。&quot;);    }}</code></pre><p>我们该如何操作呢？来吧，直接用电线接通电源。</p><pre><code class="java">public class Client {    public static void main(String[] args) {        System.out.println(&quot;===客户端用【电线】直接操作灯泡===&quot;);        Bulb bulb = new Bulb();        bulb.on();        bulb.off();        /*打印输出：            ===客户端用【电线】直接操作灯泡===            通电，灯亮。            断电，灯灭。         */    }}</code></pre><p>也许用户是个糙人，直接用导线给通电了，简单粗暴，虽然没有错，但这看上去与设计模式没有任何瓜葛。为了体现出模式的优越性，我们需要让系统进化得更高级一些，于是我们决定加入另一个模块，开关控制。</p><pre><code class="java">public class Switcher {    // 此开关与灯耦合，无法替换为其他电器。    // private Bulb bulb = new Bulb();    // 此开关与电器接口耦合，可任意替换电器。    private Switchable switchable;    // 替换电器方法    public void setSwitchable(Switchable switchable) {        this.switchable = switchable;    }    // 按键事件绑定    // 按钮“开”按下    public void buttonOnClick() {        System.out.println(&quot;按下开……&quot;);        switchable.on();    }    // 按钮“关”按下    public void buttonOffClick() {        System.out.println(&quot;按下关……&quot;);        switchable.off();    }}</code></pre><p>这里的开关就类似一个控制器了，有“开”和“关”两个按键分别绑定了设备的“通电”与“断电”行为方法。需要特别注意的是，如果在第4行我们声明地是灯泡，那么无疑这个开关与灯泡就绑定死了，也就是强耦合了，所以第7行我们声明的是Switchable接口引用，并提供第10行的替换电器方法给外界注入任何的设备。好了，我们换个方式运行程序。</p><pre><code class="java">public class Client {    public static void main(String[] args) {        System.out.println(&quot;===客户端用【开关】操作电器===&quot;);        Switcher switcher = new Switcher();        switcher.setSwitchable(new Bulb());//灯泡接入开关。        switcher.buttonOnClick();        switcher.buttonOffClick();        switcher.setSwitchable(new Fan());//风扇接入开关。        switcher.buttonOnClick();        switcher.buttonOffClick();        /*打印输出：            ===客户端用【开关】操作电器===            按下开……            通电，灯亮。            按下关……            断电，灯灭。            按下开……            通电，风扇转动。            按下关……            断电，风扇停止。         */    }}</code></pre><p>这次看上去功能强大多了，开关可以随意地接入灯泡或者风扇，注入的是谁那么开关按钮直接就作用于谁，对于设备我们还可以继续扩展，设计模式开始体现优势了。等等，这个模式好像似曾相识的感觉，没错，这正是之前讲过的<strong>策略模式</strong>，可这跟命令模式有什么关系？不要着急，我们先看下这个开关策略模式是否满足了我们的需求。</p><p>假设我们的设备不断扩展，比如有了电视机，收音机等等设备，它们不止是开关通电这种简单行为模式了，还可以有转换频道、变音量等等更多的行为。</p><p>那么我们的简单开关还能满足对接电视机的琳琅满目的功能吗？注意之前我们的开关Switcher类中第7行代码：<em>private Switchable switchable;</em> 虽然可以替换设备，但只能是Switchable设备对象，这就与”可开关设备接口“强耦合了，也就是说它只能控制“灯泡或风扇”，并不能控制”电视或收音机”。</p><p>同时另一端我们的开关控制器也在不断进化，发展出了更多功能控制器、无线遥控器、甚至是手机App控制。</p><p>所以，如何把控制器与设备完全给拆解开势在必行，此时命令模式粉墨登场。现在我们得新定义出一组”命令“模块把控制器（发令者）与设备（执行者）彻底解耦，就以电视机和遥控器举例说明吧。</p><pre><code class="java">public interface Device extends Switchable{    // 频道+    public void channelUp();    // 频道-    public void channelDown();    // 音量+    public void volumeUp();    // 音量-    public void volumeDown();}</code></pre><p>注意代码第1行的接口继承，我们的高级设备接口则遗传了之前的简单通断电接口，并新增了调节频道和音量4个功能。接下来是电视机与收音机实现类。</p><pre><code class="java">public class TV implements Device {    @Override    public void on(){        System.out.println(&quot;电视机启动&quot;);    }       @Override    public void off(){        System.out.println(&quot;电视机关闭&quot;);    }    @Override    public void channelUp() {        System.out.println(&quot;电视机频道+&quot;);    }    @Override    public void channelDown() {        System.out.println(&quot;电视机频道-&quot;);    }    @Override    public void volumeUp() {        System.out.println(&quot;电视机音量+&quot;);    }    @Override    public void volumeDown() {        System.out.println(&quot;电视机音量-&quot;);    }}</code></pre><pre><code class="java"> 1public class Radio implements Device { 2 3    @Override 4    public void on(){ 5        System.out.println(&quot;收音机启动&quot;); 6    }    7 8    @Override 9    public void off(){10        System.out.println(&quot;收音机关闭&quot;);11    }1213    @Override14    public void channelUp() {15        System.out.println(&quot;收音机调频+&quot;);16    }1718    @Override19    public void channelDown() {20        System.out.println(&quot;收音机调频-&quot;);21    }2223    @Override24    public void volumeUp() {25        System.out.println(&quot;收音机音量+&quot;);26    }2728    @Override29    public void volumeDown() {30        System.out.println(&quot;收音机音量-&quot;);31    }32}</code></pre><p>没什么好说的，下来是解耦的重点了，我们在策略模式的基础上又增加一层中间模块，开始编写命令模块代码，首先是命令接口。</p><pre><code class="java">public interface Command {    //执行命令操作    public void exe();    //反执行命令操作    public void unexe();}</code></pre><p>命令接口有执行操作与反执行操作两个标准功能，然后定义其命令实现类，开关机命令、频道转换命令、以及音量调节命令。</p><pre><code class="java">public class SwitchCommand implements Command {    private Device device;// 此处持有高级设备接口。    public SwitchCommand(Device device) {        this.device = device;    }    @Override    public void exe() {        device.on();// 执行命令调用开机操作    }    @Override    public void unexe() {        device.off();// 反执行命令调用关机操作    }}</code></pre><pre><code class="java">public class ChannelCommand implements Command{    private Device device;    public ChannelCommand(Device device) {        this.device = device;    }    @Override    public void exe() {        device.channelUp();    }    @Override    public void unexe() {        device.channelDown();    }}</code></pre><pre><code class="java">public class VolumeCommand implements Command{    private Device device;    public VolumeCommand(Device device) {        this.device = device;    }    @Override    public void exe() {        device.volumeUp();    }    @Override    public void unexe() {        device.volumeDown();    }}</code></pre><p>代码很简单，但是系统模组相对复杂，所以一定要搞清楚各模块间关系再继续。最后一个模块是遥控器类，也就是命令发送方了。我们保持简单，遥控器集成了OK按键以及上下左右方向键。</p><pre><code class="java">public class Controller {    private Command okCommand;    private Command verticalCommand;    private Command horizontalCommand;    // 绑定OK键命令    public void bindOKCommand(Command okCommand) {        this.okCommand = okCommand;    }    // 绑定上下方向键命令    public void bindVerticalCommand(Command verticalCommand) {        this.verticalCommand = verticalCommand;    }    // 绑定左右方向键命令    public void bindHorizontalCommand(Command horizontalCommand) {        this.horizontalCommand = horizontalCommand;    }    // 开始按键映射命令    public void buttonOKHold() {        System.out.print(&quot;长按OK按键……&quot;);        okCommand.exe();    }    public void buttonOKClick() {        System.out.print(&quot;单击OK按键……&quot;);        okCommand.unexe();    }    public void buttonUpClick() {        System.out.print(&quot;单击↑按键……&quot;);        verticalCommand.exe();    }    public void buttonDownClick() {        System.out.print(&quot;单击↓按键……&quot;);        verticalCommand.unexe();    }    public void buttonLeftClick() {        System.out.print(&quot;单击←按键……&quot;);        horizontalCommand.unexe();    }    public void buttonRightClick() {        System.out.print(&quot;单击→按键……&quot;);        horizontalCommand.exe();    }}</code></pre><p>这个遥控器持有三个命令组件，并且于第7行开始定义命令绑定方法，最后从第22行开始定义各按键触发方法并映射到相应的命令操作上。可以看到，控制器对设备一无所知，也就是它上面不再绑定有任何设备了，而是只绑定命令。最后，客户端又换了一种方式运行程序。</p><pre><code class="java">public class Client {    public static void main(String[] args) {        System.out.println(&quot;===客户端用【可编程式遥控器】操作电器===&quot;);        Device tv = new TV();        Device radio = new Radio();        Controller controller = new Controller();        //绑定【电视机】的【命令】到【控制器按键】        controller.bindOKCommand(new SwitchCommand(tv));        controller.bindVerticalCommand(new ChannelCommand(tv));//上下调台        controller.bindHorizontalCommand(new VolumeCommand(tv));//左右调音        controller.buttonOKHold();        controller.buttonUpClick();        controller.buttonUpClick();        controller.buttonDownClick();        controller.buttonRightClick();        /*打印输出：            ===客户端用【可编程式遥控器】操作电器===            长按OK按键……电视机启动            单击↑按键……电视机频道+            单击↑按键……电视机频道+            单击↓按键……电视机频道-            单击→按键……电视机音量+        */        //绑定【收音机】的【命令】到【控制器按键】        controller.bindOKCommand(new SwitchCommand(radio));        controller.bindVerticalCommand(new VolumeCommand(radio));//上下调音        controller.bindHorizontalCommand(new ChannelCommand(radio));//左右调台        controller.buttonOKHold();        controller.buttonUpClick();        controller.buttonUpClick();        controller.buttonRightClick();        controller.buttonDownClick();        /*打印输出：            长按OK按键……收音机启动            单击↑按键……收音机音量+            单击↑按键……收音机音量+            单击→按键……收音机调频+            单击↓按键……收音机音量-        */    }}</code></pre><p>很显然，客户端可以肆意妄为地组装各个模块了，也就是说可以遥控电视，也可以遥控收音机，或许绑定上下键调音量，或许是换成左右键调音量，甚至可以定义一个宏命令去控制灯泡的切换开关实现一种霓虹灯闪烁的效果（读者可以思考怎样实现），而对于控制器端本身，同样可以继续扩展，或许干脆替换个游戏手柄或者键盘，一样可以发号施令。</p><p>至此，发令控制方与接受执行方完全被拆解开，这让我们实现了对各模块的自由扩展，对指令映射、设备绑定的灵活操控，松散的系统得以成就繁多模块解耦的最终目的。</p><h3 id="定义说明-16"><a href="#定义说明-16" class="headerlink" title="定义说明"></a>定义说明</h3><p><strong>定义：</strong>将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能。</p><p><strong>命令模式的结构</strong></p><p>顾名思义，命令模式就是对命令的封装，首先来看一下命令模式类图中的基本结构：</p><ul><li><p><strong><code>Command类</code>：</strong>是一个抽象类，类中对需要执行的命令进行声明，一般来说要对外公布一个execute方法用来执行命令。</p></li><li><p><strong><code>ConcreteCommand类</code>：</strong>Command类的实现类，对抽象类中声明的方法进行实现。</p></li><li><p><strong><code>Client类</code>：</strong>最终的客户端调用类。</p><p>以上三个类的作用应该是比较好理解的，下面我们重点说一下Invoker类和Recevier类。</p></li><li><p><strong><code>Invoker类</code>：</strong>调用者，负责调用命令。</p></li><li><p><strong><code>Receiver类</code>：</strong>接收者，负责接收命令并且执行命令。</p></li></ul><p><strong>命令模式的优缺点</strong></p><p>首先，命令模式的封装性很好：每个命令都被封装起来，对于客户端来说，需要什么功能就去调用相应的命令，而无需知道命令具体是怎么执行的。比如有一组文件操作的命令：新建文件、复制文件、删除文件。如果把这三个操作都封装成一个命令类，客户端只需要知道有这三个命令类即可，至于命令类中封装好的逻辑，客户端则无需知道。</p><p>其次，命令模式的扩展性很好，在命令模式中，在接收者类中一般会对操作进行最基本的封装，命令类则通过对这些基本的操作进行二次封装，当增加新命令的时候，对命令类的编写一般不是从零开始的，有大量的接收者类可供调用，也有大量的命令类可供调用，代码的复用性很好。比如，文件的操作中，我们需要增加一个剪切文件的命令，则只需要把复制文件和删除文件这两个命令组合一下就行了，非常方便。</p><p>最后说一下命令模式的缺点，那就是命令如果很多，开发起来就要头疼了。特别是很多简单的命令，实现起来就几行代码的事，而使用命令模式的话，不用管命令多简单，都需要写一个命令类来封装。</p><p><strong>命令模式的适用场景</strong></p><p>对于大多数请求-响应模式的功能，比较适合使用命令模式，正如命令模式定义说的那样，命令模式对实现记录日志、撤销操作等功能比较方便。</p><p> <strong>总结</strong></p><p>对于一个场合到底用不用模式，这对所有的开发人员来说都是一个很纠结的问题。有时候，因为预见到需求上会发生的某些变化，为了系统的灵活性和可扩展性而使用了某种设计模式，但这个预见的需求偏偏没有，相反，没预见到的需求倒是来了不少，导致在修改代码的时候，使用的设计模式反而起了相反的作用，以至于整个项目组怨声载道。这样的例子，我相信每个程序设计者都遇到过。所以，基于敏捷开发的原则，我们在设计程序的时候，如果按照目前的需求，不使用某种模式也能很好地解决，那么我们就不要引入它，因为要引入一种设计模式并不困难，我们大可以在真正需要用到的时候再对系统进行一下，引入这个设计模式。</p><p>拿命令模式来说吧，我们开发中，请求-响应模式的功能非常常见，一般来说，我们会把对请求的响应操作封装到一个方法中，这个封装的方法可以称之为命令，但不是命令模式。到底要不要把这种设计上升到模式的高度就要另行考虑了，因为，如果使用命令模式，就要引入调用者、接收者两个角色，原本放在一处的逻辑分散到了三个类中，设计时，必须考虑这样的代价是否值得。</p><h2 id="访问者"><a href="#访问者" class="headerlink" title="访问者"></a>访问者</h2><h3 id="初步理解-18"><a href="#初步理解-18" class="headerlink" title="初步理解"></a>初步理解</h3><p>众所周知，对于数据的封装我们通常会用到<code>POJO</code>类，它除了<code>getter</code>和<code>setter</code>之外是不包含任何业务逻辑的，也就是说它只对应一组数据并不包含任何功能。举个最常见的例子，比如数据库对应的实体类，一般我们不会在类里封装上业务逻辑，而是放在专门的<code>Service</code>类里去处理，也就是<code>Service</code>作为拜访者去访问实体类封装的数据。</p><p>现在假设有这么一个场景，我们有很多的实体数据封装类（各类食品）都要进行一段相同的业务处理（计算价格），而每个实体类对应着不同的业务逻辑（水果按斤卖，啤酒论瓶卖），但我们又不想每个类对应一个业务逻辑类（类太繁多），而是汇总到一处业务处理（结账台），那我们应该如何设计呢？</p><p>我们就以超市结账举例，首先是各种商品的实体类，包括糖、酒、和水果，它们都应该共享一些共通属性，那就先抽象出一个商品类吧。</p><pre><code class="java">public abstract class Product {    protected String name;// 品名    protected LocalDate producedDate;// 生产日期    protected float price;// 价格    public Product(String name, LocalDate producedDate, float price) {        this.name = name;        this.producedDate = producedDate;        this.price = price;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public LocalDate getProducedDate() {        return producedDate;    }    public void setProducedDate(LocalDate producedDate) {        this.producedDate = producedDate;    }    public float getPrice() {        return price;    }    public void setPrice(float price) {        this.price = price;    }}</code></pre><p>我们抽象出来的都是些最基本的商品属性，简单的数据封装，标准的<code>POJO</code>类，接下来我们把这些属性和方法都继承下来给具体商品类，它们依次是糖果、酒、和水果。</p><pre><code class="java">public class Candy extends Product {// 糖果类    public Candy(String name, LocalDate producedDate, float price) {        super(name, producedDate, price);    }}public class Wine extends Product {// 酒类    public Wine(String name, LocalDate producedDate, float price) {        super(name, producedDate, price);    }}public class Fruit extends Product {// 水果    private float weight;    public Fruit(String name, LocalDate producedDate, float price, float weight) {        super(name, producedDate, price);        this.weight = weight;    }    public float getWeight() {        return weight;    }    public void setWeight(float weight) {        this.weight = weight;    }}</code></pre><p>基本没什么特别的，除了水果是论斤销售，所以我们加了个重量属性，仅此而已。接下来就是我们的结算业务逻辑了，超市规定即将过期的给予一定打折优惠，日常促销可以吸引更多顾客。</p><p>我们思考一下怎样设计，针对不同商品的折扣力度显然是不一样的，其实不止是打折，我们知道过期商品超市不准继续售卖，但这对于酒类商品又不存在过期问题。这个业务很明显是针对不同的类要有不同的逻辑反应了，那对于我们所访问的商品应该加以区分，用<code>instanceof</code>判断并分流？这显然太混乱了，代码里会充斥着大量<code>if else</code>！那我们定义多个同名方法，以不同的商品参数去分流？没错，我们就用重载，首先定义访问者接口，为的是日后对访问者的扩展。</p><pre><code class="java">public interface Visitor {// 访问者接口    public void visit(Candy candy);// 糖果重载方法    public void visit(Wine wine);// 酒类重载方法    public void visit(Fruit fruit);// 水果重载方法}</code></pre><p>三个重载方法会响应不同的商品类对象，这是一种功能上的多态性。下面来看具体的业务实现类，我们这里实现一个日常打折并计算最终价格的业务类<code>DiscountVisitor</code>。</p><pre><code class="java">public class DiscountVisitor implements Visitor {    private LocalDate billDate;    public DiscountVisitor(LocalDate billDate) {        this.billDate = billDate;        System.out.println(&quot;结算日期：&quot; + billDate);    }    @Override    public void visit(Candy candy) {        System.out.println(&quot;=====糖果【&quot; + candy.getName() + &quot;】打折后价格=====&quot;);        float rate = 0;        long days = billDate.toEpochDay() - candy.getProducedDate().toEpochDay();        if (days &gt; 180) {            System.out.println(&quot;超过半年过期糖果，请勿食用！&quot;);        } else {            rate = 0.9f;        }        float discountPrice = candy.getPrice() * rate;        System.out.println(NumberFormat.getCurrencyInstance().format(discountPrice));    }    @Override    public void visit(Wine wine) {        System.out.println(&quot;=====酒品【&quot; + wine.getName() + &quot;】无折扣价格=====&quot;);        System.out.println(NumberFormat.getCurrencyInstance().format(wine.getPrice()));    }    @Override    public void visit(Fruit fruit) {        System.out.println(&quot;=====水果【&quot; + fruit.getName() + &quot;】打折后价格=====&quot;);        float rate = 0;        long days = billDate.toEpochDay() - fruit.getProducedDate().toEpochDay();        if (days &gt; 7) {            System.out.println(&quot;￥0.00元（超过一周过期水果，请勿食用！）&quot;);        } else if (days &gt; 3) {            rate = 0.5f;        } else {            rate = 1;        }        float discountPrice = fruit.getPrice() * fruit.getWeight() * rate;        System.out.println(NumberFormat.getCurrencyInstance().format(discountPrice));    }}</code></pre><p>业务看上去也许有些复杂，其中构造方法传入初始化结单日期（第4行），糖果（第10行）的过期日设置为半年否则按9折出售，酒品（第24行）则没有过期限制，一律按原价出售，对于水果（第30行）有效期设置为一周，如果超过3天按半价出售，总之就是三种商品对应不同的计算逻辑。其实我们可以完全忽略业务实现，这里应该着重于模式的思考，让我们看看怎样客户端访问数据。</p><pre><code class="java">public class Client {    public static void main(String[] args) {        //小黑兔奶糖，生产日期：2018-10-1，原价：￥20.00        Candy candy = new Candy(&quot;小黑兔奶糖&quot;, LocalDate.of(2018, 10, 1), 20.00f);        Visitor discountVisitor = new DiscountVisitor(LocalDate.of(2019, 1, 1));        discountVisitor.visit(candy);        /*打印输出：            结算日期：2019-01-01            =====糖果【小黑兔奶糖】打折后价格=====            ￥18.00        */    }}</code></pre><p>貌似程序运行地很好，业务逻辑没有问题，最后打了9折。但是，请注意第4行客户选了一包奶糖并以糖果类定义引用了糖果对象，这么做当然无可厚非，但试想我们如果选购多种产品并加入购物车<code>List&lt;Product&gt;</code>，购物车只认识泛化的<code>Product</code>，对具体品类不得而知，所以这里应该进行泛化处理，以产品<code>Product</code>定义引用，让我们选购多件商品实验下。</p><pre><code class="java">public class Client {    public static void main(String[] args) {        // 三件商品加入购物车        List&lt;Product&gt; products = Arrays.asList(            new Candy(&quot;小黑兔奶糖&quot;, LocalDate.of(2018, 10, 1), 20.00f),            new Wine(&quot;猫泰白酒&quot;, LocalDate.of(2017, 1, 1), 1000.00f),            new Fruit(&quot;草莓&quot;, LocalDate.of(2018, 12, 26), 10.00f, 2.5f)        );        Visitor discountVisitor = new DiscountVisitor(LocalDate.of(2018, 1, 1));        // 迭代购物车轮流结算        for (Product product : products) {            discountVisitor.visit(product);// 此处报错        }    }}</code></pre><p>注意重点来了，我们顺利地加入购物车并迭代轮流结算每个产品，可是第13行会报错，编译器对泛化后的<code>product</code>很是茫然，这到底是糖还是酒？该调用哪个<code>visit</code>方法呢？很多朋友疑问为什么不能在运行时根据对象类型动态地派发给对应的重载方法？试想，如果我们新加一个蔬菜产品类<code>Vegetable</code>，但没有在<code>Visitor</code>里加入其重载方法<code>visit(Vegetable vegetable)</code>，那运行起来岂不是更糟糕？所以编译器提前就应该禁止此种情形通过编译。</p><p>难道我们设计思路错了？有没有办法把产品派发到相应的重载方法？答案是肯定的，这里涉及到一个新的概念，我们需要利用<strong>“双派发”（double dispatch）</strong>巧妙地绕过这个错误，既然访问者访问不了，我们从被访问者（产品资源）入手，来看代码，先定义一个接待者接口。</p><pre><code class="java">public interface Acceptable {    // 主动接受拜访者    public void accept(Visitor visitor);}</code></pre><p>可以看到这个“接待者”定义了一个接待方法，凡是“来访者”身份的都予以接受。我们先用糖果类实现这个接口，并主动接受来访者的拜访。</p><pre><code class="java">public class Candy extends Product implements Acceptable{// 糖果类    public Candy(String name, LocalDate producedDate, float price) {        super(name, producedDate, price);    }    @Override    public void accept(Visitor visitor) {        visitor.visit(this);// 把自己交给拜访者。    }}</code></pre><p>糖果类顺理成章地成为了“接待者”（其他品类雷同，此处忽略代码），并把自己（this）交给了来访者（第9行），这样绕来绕去起到什么作用呢？别急，我们先来看双派发到底是怎样实现的。</p><pre><code class="java">public class Client {    public static void main(String[] args) {        // 三件商品加入购物车        List&lt;Acceptable&gt; products = Arrays.asList(            new Candy(&quot;小黑兔奶糖&quot;, LocalDate.of(2018, 10, 1), 20.00f),            new Wine(&quot;猫泰白酒&quot;, LocalDate.of(2017, 1, 1), 1000.00f),            new Fruit(&quot;草莓&quot;, LocalDate.of(2018, 12, 26), 10.00f, 2.5f)        );        Visitor discountVisitor = new DiscountVisitor(LocalDate.of(2019, 1, 1));        // 迭代购物车轮流结算        for (Acceptable product : products) {            product.accept(discountVisitor);        }        /*打印输出：            结算日期：2019-01-01            =====糖果【小黑兔奶糖】打折后价格=====            ￥18.00            =====酒品【猫泰白酒】无折扣价格=====            ￥1,000.00            =====水果【草莓】打折后价格=====            ￥12.50         */    }}</code></pre><p>注意看第4行的购物车<code>List&lt;Product&gt;</code>已经被改为泛型<code>Acceptable</code>了，也就是说所有商品统统被泛化且当作“接待者”了，由于泛型化后的商品像是被打了包裹一样让拜访者无法识别品类，所以在迭代里面我们让这些商品对象主动去“接待”来访者（第13行）。这类似于警察（访问者）办案时嫌疑人（接待者）需主动接受调查并出示自己的身份证给警察，如此就可以基于个人信息查询前科并展开相关调查。</p><p>如此一来，在运行时的糖果自己是认识自己的，它就把自己递交给来访者，此时的<code>this</code>必然就属糖果类了，所以能得偿所愿地派发到<code>Visitor</code>的<code>visit(Fruit fruit)</code>重载方法，这样便实现了“双派发”，也就是说我们先派发给商品去主动接待，然后又把自己派发回给访问者，我不认识你，你告诉我你是谁。</p><p>终于，我们巧妙地用双派发解决了方法重载的多态派发问题，如虎添翼，访问者模式框架至此搭建竣工，之后再添加业务逻辑不必再改动数据实体类了，比如我们再增加一个针对六一儿童节打折业务，加大对糖果类、玩具类的打折力度，而不需要为每个<code>POJO</code>类添加对应打折方法，数据资源（实现接待者接口）与业务（实现访问者接口）被分离开来，且业务处理集中化、多态化、亦可扩展。纯粹的数据，不应该多才多艺。</p><h3 id="定义说明-17"><a href="#定义说明-17" class="headerlink" title="定义说明"></a>定义说明</h3><p><strong>定义：</strong>封装某些作用于某种数据结构中各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。</p><p><strong>访问者模式的优点</strong></p><ul><li><p><strong>符合单一职责原则：</strong>凡是适用访问者模式的场景中，元素类中需要封装在访问者中的操作必定是与元素类本身关系不大且是易变的操作，使用访问者模式一方面符合单一职责原则，另一方面，因为被封装的操作通常来说都是易变的，所以当发生变化时，就可以在不改变元素类本身的前提下，实现对变化部分的扩展。</p></li><li><p><strong>扩展性良好：</strong>元素类可以通过接受不同的访问者来实现对不同操作的扩展。</p></li></ul><p><strong>访问者模式的适用场景</strong></p><p>假如一个对象中存在着一些与本对象不相干（或者关系较弱）的操作，为了避免这些操作污染这个对象，则可以使用访问者模式来把这些操作封装到访问者中去。</p><p>假如一组对象中，存在着相似的操作，为了避免出现大量重复的代码，也可以将这些重复的操作封装到访问者中去。</p><p>但是，访问者模式并不是那么完美，它也有着致命的缺陷：增加新的元素类比较困难。通过访问者模式的代码可以看到，在访问者类中，每一个元素类都有它对应的处理方法，也就是说，每增加一个元素类都需要修改访问者类（也包括访问者类的子类或者实现类），修改起来相当麻烦。也就是说，在元素类数目不确定的情况下，应该慎用访问者模式。所以，访问者模式比较适用于对已有功能的重构，比如说，一个项目的基本功能已经确定下来，元素类的数据已经基本确定下来不会变了，会变的只是这些元素内的相关操作，这时候，我们可以使用访问者模式对原有的代码进行重构一遍，这样一来，就可以在不修改各个元素类的情况下，对原有功能进行修改。</p><p><strong>总结</strong></p><p>正如《设计模式》的作者<code>GoF</code>对访问者模式的描述：大多数情况下，你并需要使用访问者模式，但是当你一旦需要使用它时，那你就是真的需要它了。当然这只是针对真正的大牛而言。在现实情况下（至少是我所处的环境当中），很多人往往沉迷于设计模式，他们使用一种设计模式时，从来不去认真考虑所使用的模式是否适合这种场景，而往往只是想展示一下自己对面向对象设计的驾驭能力。编程时有这种心理，往往会发生滥用设计模式的情况。所以，在学习设计模式时，一定要理解模式的适用性。必须做到使用一种模式是因为了解它的优点，不使用一种模式是因为了解它的弊端；而不是使用一种模式是因为不了解它的弊端，不使用一种模式是因为不了解它的优点。</p><h2 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h2><h3 id="初步理解-19"><a href="#初步理解-19" class="headerlink" title="初步理解"></a>初步理解</h3><p>解释，一定是针对某种语言的拆解、释意，并按照文法翻译、转换成另一种表达形式以达到目标能够理解的目的。比如我们都知道Java编程语言是人类可以理解的语言，程序写好后要先进行编译生成字节码（class文件），然后对此文件解释成机器码，最终机器才可以理解并执行，这就是解释器存在的意义。</p><p>就拿我们人类的自然语言来举例，比如我们要进行英文翻译工作，首先要对一句话（表达式）进行拆解，而拆开后的单词就成了不可再分的终极表达式，例如说对英语句子“I love you”（非终极表达式）进行拆解，按空格分割为单词“I”、“love”、“you”（终极表达式），然后翻译每个单词再合并成“我爱你”，貌似很简单的样子。再看句子“I love that you love”，翻译成“我爱你那个你爱”。</p><p>这简直太荒谬了，这句明明是“我爱你所爱”的意思，貌似这里的拆解方式是有讲究的。“that you love”在这里应该是作为从句出现，所以它应该属于一个特殊的“非终极表达式”，有自己独特的翻译方式，而不是简单的单词拼接了。我们意识到语言的翻译绝非易事，但至少我们通过思考搞明白了终极与非终极表达式的区别、表达式的多态性、以及表达式的自包含关系结构。</p><p>开个玩笑，所以呢我们研发了一款挂机程序并起名”耗子精“，它可以直接发送指令给鼠标驱动来实现点击、移动操作，从此解放我们的双手让游戏人物自动打怪升级。既然不操作鼠标，那就需要一段脚本告诉“耗子精”怎样去操作鼠标指针，于是我们发明了一种脚本语言“精神食粮”，像是下面这样：</p><pre><code class="java">BEGIN                // 脚本开始MOVE 500,600;        // 鼠标移动到坐标(500, 600)    BEGIN LOOP 5     // 开始循环5次        LEFT_CLICK;  // 循环体内单击左键        DELAY 1;     // 每次延时1秒    END;             // 循环体结束RIGHT_DOWN;          // 按下右键DELAY 7200;          // 延时2小时END;                 // 脚本结束</code></pre><p>看注释很容易就能理解这是要干什么了，玩家先让鼠标挪动到地图的某个点上，然后不停地点击了n次（比如此处简化为5次）过后人物便到达了刷怪地点了（计算好延时时间），最后按下右键触发技能并一直不松开，直到挂机2小时后结束，这样便实现了自动打怪升级。</p><p>我们现在来对这个语言的表达式进行拆解、抽象、建模，可以看到除了循环（非终极表达式）以外其他的都是单个命令不可以拆了，也就是我们之前讲过的终极表达式，按照这个脚本我们先看一张结构图。</p><p>可以看到从始发节点“指令序列表达式”（根）开始被拆解成三个分支，第一步和第三步都是执行鼠标动作的终极表达式了（叶），而第二步的“循环”则属于非终极表达式（枝），它的循环体内可以包含多步指令，所以它包括一个子指令集（枝），然后继续往下延续出“左键单击表达式”（枝）和“系统延时表达式”（叶），最后“单击”其实就是“按下”与“松开”的组合了。有没有这个语义树结构好像似曾相识？没错，这就是之前讲过的“<strong>组合模式</strong>”，我们正是利用了“组合模式”（强调结构型）的结构模型构建了这个<strong>语义树（Syntax Tree）</strong>，来完成我们的翻译工作（这里强调行为型）。</p><p>开始写代码，这么多表达式到底应该从哪里开始定义呢？不管三七二十一它们统统都是表达式，先写个表达式总抽象。</p><pre><code class="java">public interface Expression { // 表达式接口    public void interpret(); // 解释方法}</code></pre><p>可以看到这个接口定义了表达式的通用解释方法标准，一切表达式都得符合这个规则。接下来我们先从最基本的原子操作（终极表达式）开始定义实现类，它们应该依次是移动鼠标、左（右）键按下（松开）、系统延时表达式等，雷同的我们不做赘述，读者可以自己实现。</p><pre><code class="java">public class Move implements Expression {    // 鼠标位置坐标    private int x, y;    public Move(int x, int y) {        this.x = x;        this.y = y;    }    public void interpret() {        System.out.println(&quot;移动鼠标：【&quot; + x + &quot;,&quot; + y + &quot;】&quot;);    }}</code></pre><pre><code class="java">public class LeftDown implements Expression {    public void interpret() {        System.out.println(&quot;按下鼠标：左键&quot;);    }}</code></pre><pre><code class="java">public class LeftUp implements Expression {    public void interpret() {        System.out.println(&quot;松开鼠标：左键&quot;);    }}</code></pre><pre><code class="java">public class Delay implements Expression {    private int seconds;// 延时秒数    public Delay(int seconds) {        this.seconds = seconds;    }    public int getSeconds() {        return seconds;    }    public void interpret() {        System.out.println(&quot;系统延迟：&quot; + seconds + &quot;秒钟&quot;);        try {            Thread.sleep(seconds * 1000);        } catch (InterruptedException e) {            e.printStackTrace();        }    }}</code></pre><p>很简单，它们都实现了interpret方法，并进行了相关操作的模拟。照猫画虎，下来实现非终极表达式：左（右）键单击表达式、循环表达式、以及指令集序列表达式等。</p><pre><code class="java">public class LeftClick implements Expression {    private Expression leftDown;    private Expression leftUp;    public LeftClick() {        this.leftDown = new LeftDown();        this.leftUp = new LeftUp();    }    public void interpret() {        //单击=先按下再松开        leftDown.interpret();        leftUp.interpret();    }}</code></pre><p>这里有点意思了，单击表达式被我们继续拆分成“按下”及“松开”两个原子操作，由于点击是个固定的死操作，并不需要提供给客户端任何灵活性把它们传入进来，所以我们在构造时（第7行）主动实例化了它们。接下来是循环表达式，我们需要知道循环次数，以及循环体内要执行的表达式。</p><pre><code class="java">public class Repetition implements Expression {    private int loopCount;// 循环次数    private Expression expression;// 循环体表达式    public Repetition(Expression expression, int loopCount) {        this.expression = expression;        this.loopCount = loopCount;    }    public void interpret() {        while (loopCount &gt; 0) {            expression.interpret();            loopCount--;        }   }}</code></pre><p>清晰明了，循环表达式被初始化后用这些参数进行循环、并调用循环体表达式的解释方法，继续向下传递，至于这个表达式里具体还有什么子表达式我们根本不关心，这里主要负责循环调用，仅此而已。最后就是指令集序列表达式的实现了。</p><pre><code class="java">public class Sequence implements Expression {    // 指令集序列    private List&lt;Expression&gt; expressions;    public Sequence(List&lt;Expression&gt; expressions) {        this.expressions = expressions;    }    public void interpret() {        // 循环挨个解析每条指令        expressions.forEach(exp -&gt; exp.interpret());    }}</code></pre><p>我们要运行的脚本一定是有先后顺序的，所以这个指令集表达式里包含一个List<Expression>，在构造时（第5行）由客户端传入，并于第11行挨个顺序调用解释方法。貌似脚本用到的表达式已经定义完毕，客户端开始调用。</p><pre><code class="java">public class Client {    public static void main(String[] args) {        /*         * BEGIN             // 脚本开始         * MOVE 500,600;     // 鼠标移动到坐标(500, 600)         *  BEGIN LOOP 5     // 开始循环5次         *      LEFT_CLICK;  // 循环体内单击左键         *      DELAY 1;     // 每次延时1秒         *  END;             // 循环体结束         * RIGHT_DOWN;       // 按下右键         * DELAY 7200;       // 延时2小时         * END;              // 脚本结束         */        // 构造指令集语义树，实际情况会交给语法解析器（Evaluator or Parser）。        Expression sequence = new Sequence(Arrays.asList(            new Move(500, 600),             new Repetition(                new Sequence(                    Arrays.asList(new LeftClick(),                     new Delay(1))                ),                5            ),             new RightDown(),            new Delay(7200)        ));        sequence.interpret();        /*打印输出            移动鼠标：【500,600】            按下鼠标：左键            松开鼠标：左键            系统延迟：1秒钟            按下鼠标：左键            松开鼠标：左键            系统延迟：1秒钟            按下鼠标：左键            松开鼠标：左键            系统延迟：1秒钟            按下鼠标：左键            松开鼠标：左键            系统延迟：1秒钟            按下鼠标：左键            松开鼠标：左键            系统延迟：1秒钟            按下鼠标：右键            系统延迟：7200秒钟         */    }}</code></pre><p>注意看第16行，仔细参照注释中的脚本并实例化我们的语义树结构，最后只需调用根节点的interpret()方法即可完成整个解释工作。其实对于这个脚本转语义树的工作我们完全可以自己实现一个Evaluator来分析这段脚本并生成语义树（类似于编译的过程），由于这并不属于解释器模式的范畴，所以我们就不混淆进来了，这里我们留给读者朋友自己实现。</p><p>终于，“耗子精”有了脚本识别的能力，并顺利对接鼠标驱动，帮我们自动完成升级，玩家再也不用没日没夜地做那些无聊至极的重复动作了，并且后期如果需要更多的功能还可以对表达式继续进行扩展（比如对键盘指令的解释），我们只需优雅地植入语义树即可，就这么简单。正是因为我们对语言的语法解析、表达式抽象化，关系结构化，使得让翻译工作变得即插即用，解释器模式不但提高了代码的易读性、易用性、可维护性，更重要的是对未来语言变化的可扩展性。</p><p>语言是可以拆解的，句子是可以包括从句（子句）或单词的，单词是具有终极原子性的，它们统统重复出现。</p><h3 id="定义说明-18"><a href="#定义说明-18" class="headerlink" title="定义说明"></a>定义说明</h3><p><strong>定义：</strong>给定一种语言，定义他的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中句子。</p><p><strong>解释器模式的结构</strong></p><p><strong>抽象解释器：</strong>声明一个所有具体表达式都要实现的抽象接口（或者抽象类），接口中主要是一个<code>interpret()</code>方法，称为解释操作。具体解释任务由它的各个实现类来完成，具体的解释器分别由终结符解释器<code>TerminalExpression</code>和非终结符解释器<code>NonterminalExpression</code>完成。</p><p><strong>终结符表达式：</strong>实现与文法中的元素相关联的解释操作，通常一个解释器模式中只有一个终结符表达式，但有多个实例，对应不同的终结符。终结符一半是文法中的运算单元，比如有一个简单的公式<code>R=R1+R2</code>，在里面<code>R1</code>和<code>R2</code>就是终结符，对应的解析<code>R1</code>和<code>R2</code>的解释器就是终结符表达式。 </p><p><strong>非终结符表达式：</strong>文法中的每条规则对应于一个非终结符表达式，非终结符表达式一般是文法中的运算符或者其他关键字，比如公式<code>R=R1+R2</code>中，+就是非终结符，解析+的解释器就是一个非终结符表达式。非终结符表达式根据逻辑的复杂程度而增加，原则上每个文法规则都对应一个非终结符表达式。</p><p><strong>环境角色：</strong>这个角色的任务一般是用来存放文法中各个终结符所对应的具体值，比如<code>R=R1+R2</code>，我们给<code>R1</code>赋值100，给<code>R2</code>赋值200。这些信息需要存放到环境角色中，很多情况下我们使用Map来充当环境角色就足够了。</p><p><strong>解释器模式的优缺点</strong></p><p>解释器是一个简单的语法分析工具，它最显著的优点就是扩展性，修改语法规则只需要修改相应的非终结符就可以了，若扩展语法，只需要增加非终结符类就可以了。</p><p>但是，解释器模式会引起类的膨胀，每个语法都需要产生一个非终结符表达式，语法规则比较复杂时，就可能产生大量的类文件，为维护带来非常多的麻烦。同时，由于采用递归调用方法，每个非终结符表达式只关心与自己相关的表达式，每个表达式需要知道最终的结果，必须通过递归方式，无论是面向对象的语言还是面向过程的语言，递归都是一个不推荐的方式。由于使用了大量的循环和递归，效率是一个不容忽视的问题。特别是用于解释一个解析复杂、冗长的语法时，效率是难以忍受的。</p><p><strong>解释器模式的适用场景</strong></p><p>在以下情况下可以使用解释器模式：</p><p>有一个简单的语法规则，比如一个sql语句，如果我们需要根据sql语句进行rm转换，就可以使用解释器模式来对语句进行解释。</p><p>一些重复发生的问题，比如加减乘除四则运算，但是公式每次都不同，有时是a+b-c<em>d，有时是a</em>b+c-d，等等等等个，公式千变万化，但是都是由加减乘除四个非终结符来连接的，这时我们就可以使用解释器模式。</p><p><strong>注意事项</strong></p><p>解释器模式真的是一个比较少用的模式，因为对它的维护实在是太麻烦了，想象一下，一坨一坨的非终结符解释器，假如不是事先对文法的规则了如指掌，或者是文法特别简单，则很难读懂它的逻辑。解释器模式在实际的系统开发中使用的很少，因为他会引起效率、性能以及维护等问题。</p><h2 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h2><p>本文主要整理于：<a href="https://www.javazhiyin.com/topic/设计模式是什么鬼" target="_blank" rel="noopener">设计模式是什么鬼</a>      <a href="https://mp.weixin.qq.com/s/--Mnh-VWhcmskh1J3yU7CA" target="_blank" rel="noopener">java设计模式【全】</a></p><p>其中示例代码：<a href="https://github.com/kylin-lawliet/design-pattern.git" target="_blank" rel="noopener">https://github.com/kylin-lawliet/design-pattern.git</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL中left join,right join,inner join之间的区别</title>
      <link href="/2020/03/05/sql_join/"/>
      <url>/2020/03/05/sql_join/</url>
      
        <content type="html"><![CDATA[<p>记录关于inner join(内连接）、left join(左连接)、right join（右连接）、full join（全连）接四种连接查询的区别。<br>oracle里面有full join,但是在mysql中没有full join。使用union来达到目的。</p><a id="more"></a><h3 id="一些说明"><a href="#一些说明" class="headerlink" title="一些说明"></a>一些说明</h3><p><code>blog_article</code>文章表 category_id是外键<br><img src="/img/sql/join1.png" alt=""><br><code>blog_code</code>分类表<br><img src="/img/sql/join.png" alt=""></p><h3 id="inner-join-内连接）"><a href="#inner-join-内连接）" class="headerlink" title="inner join(内连接）"></a>inner join(内连接）</h3><p>查询内连接就是查询存在的关联关系的结果，join相当于我们平时用的where，就是把两张表中同时满足ba.category_id=bc.id的数据找出来；</p><p>在不使用链接查询及没有其他条件下两张表查询的区别:查询结果为 ba*bc 条数据<br><img src="/img/sql/join2.png" alt=""></p><p>加上条件：(不建议平时这样写)<br><img src="/img/sql/join3.png" alt=""></p><p>上面的语句就相当于下面的语句。就是内连接。<br><img src="/img/sql/join6.png" alt=""></p><h3 id="left-join-左连接"><a href="#left-join-左连接" class="headerlink" title="left join(左连接)"></a>left join(左连接)</h3><p>使用左联查询是以左表（blog_article）为参考对象，然后根据ba.category_id=bc.id的条件到右表（blog_code）中查找数据，在右表（blog_code）表中找不到数据的，就填充NULL；<br><img src="/img/sql/join4.png" alt=""></p><h3 id="right-join（右连接）"><a href="#right-join（右连接）" class="headerlink" title="right join（右连接）"></a>right join（右连接）</h3><p>使用右连的结果与左联相反，即以右表（blog_code）为参考对象，然后根据ba.category_id=bc.id的条件到左表（blog_article）中查找数据，在左表（blog_article）表中找不到数据的，就填充NULL；<br><img src="/img/sql/join5.png" alt=""></p><h3 id="full-join（全连）"><a href="#full-join（全连）" class="headerlink" title="full join（全连）"></a>full join（全连）</h3><p>两表关联，查询它们的所有记录。<br>oracle里面有full join,但是在mysql中没有full join。使用union来达到目的。<br><img src="/img/sql/join7.png" alt=""></p><p><img src="/img/sql/join8.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现无限极目录树/下拉框（递归）</title>
      <link href="/2020/03/05/javascript-menutree/"/>
      <url>/2020/03/05/javascript-menutree/</url>
      
        <content type="html"><![CDATA[<p>这个例子是web项目博客的前端页头导航菜单的例子。当时写的时候卡了一段时间，就把这个例子单独放出来。<br>为了方便参考，我吧前后端重要代码都贴出来，不用专门去看博客源码。</p><a id="more"></a><h3 id="后端数据生成数据代码"><a href="#后端数据生成数据代码" class="headerlink" title="后端数据生成数据代码"></a>后端数据生成数据代码</h3><p>实体类</p><pre><code class="java">package com.blackcat.blog.core.entity;import com.baomidou.mybatisplus.annotation.IdType;import com.baomidou.mybatisplus.annotation.TableField;import com.baomidou.mybatisplus.annotation.TableId;import com.baomidou.mybatisplus.extension.activerecord.Model;import com.fasterxml.jackson.annotation.JsonFormat;import lombok.Data;import lombok.EqualsAndHashCode;import lombok.experimental.Accessors;import javax.persistence.Transient;import java.io.Serializable;import java.time.LocalDateTime;import java.util.List;/** * &lt;p&gt; * 博客分类码表 * &lt;/p&gt; * * @author blackcat * @since 2020-02-26 */@Data@EqualsAndHashCode(callSuper = false)@Accessors(chain = true)public class BlogCode extends Model&lt;BlogCode&gt; implements Comparable&lt;BlogCode&gt;{    private static final long serialVersionUID = 1L;    @TableId(value = &quot;id&quot;, type = IdType.AUTO)    private Long id;    /**     * 名称     */    private String name;    /**     * 父节点     */    private Long parentId;    /**     * 码表总表id     */    private Long codeId;    /**     * 排序     */    private Integer sort;    /**     * 备注     */    private String remarks;    /**     * 添加时间     */    @JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)//数据库导出页面时json格式化    private LocalDateTime createTime;    /**     * 更新时间     */    @JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)//数据库导出页面时json格式化    private LocalDateTime updateTime;    @Transient    @TableField(exist = false)    private BlogCode parent;    @Transient    @TableField(exist = false)    private List&lt;BlogCode&gt; nodes;    @Override    protected Serializable pkVal() {        return this.id;    }    @Override    public int compareTo(BlogCode o) {        if (!this.getSort().equals(o.getSort())) {            return this.getSort()-o.getSort();        }        return 0;    }}</code></pre><p>查询</p><pre><code class="java">@Overridepublic List&lt;BlogCode&gt; getCodesByCodeListId(String id) {    // 该分类下所有码表数据    QueryWrapper&lt;BlogCode&gt; queryWrapper = new QueryWrapper&lt;&gt;();    queryWrapper.lambda().eq(BlogCode::getCodeId, id);    List&lt;BlogCode&gt; allCode=blogCodeMapper.selectList(queryWrapper);    // 根节点    List&lt;BlogCode&gt; rootCode = new ArrayList&lt;BlogCode&gt;();    // 找到根节点    allCode.forEach(code-&gt;{        if(code.getParentId()==null){            rootCode.add(code);        }    });    Collections.sort(rootCode);    //为根节点设置子节点，getClild是递归调用的    rootCode.forEach(code-&gt;{        List&lt;BlogCode&gt; childCodes=getChild(code.getId(),allCode);        code.setNodes(childCodes);    });    return rootCode;}/** * &lt;p&gt; 描述 : 递归设置栏目的子节点 * @author : blackcat * @date  : 2020/3/5 14:20  * @param id 码表id * @param allCode  所有码表数据 * @return java.util.List&lt;com.blackcat.blog.core.entity.BlogCode&gt;*/private List&lt;BlogCode&gt; getChild(Long id,List&lt;BlogCode&gt; allCode) {    //子菜单    List&lt;BlogCode&gt; childList = new ArrayList&lt;BlogCode&gt;();    // 遍历所有节点，将所有菜单的父id与传过来的根节点的id比较    allCode.forEach(code-&gt;{        if (code.getParentId() != null &amp;&amp; code.getParentId().equals(id)) {            childList.add(code);        }    });    // 递归子节点    childList.forEach(child-&gt;{        child.setNodes(getChild(child.getId(),allCode));    });    Collections.sort(childList);    // 如果节点下没有子节点，返回一个空List（递归退出）    if (childList.size() == 0) {        return new ArrayList&lt;BlogCode&gt;();    }    return childList;}</code></pre><h3 id="生成数据格式"><a href="#生成数据格式" class="headerlink" title="生成数据格式"></a>生成数据格式</h3><pre><code class="json">{    &quot;code&quot;: 200,    &quot;data&quot;: [        {            &quot;id&quot;: 28,            &quot;name&quot;: &quot;首页&quot;,            &quot;parentId&quot;: null,            &quot;codeId&quot;: 4,            &quot;sort&quot;: 1,            &quot;remarks&quot;: &quot;/&quot;,            &quot;createTime&quot;: &quot;2020-03-03 17:00:32&quot;,            &quot;updateTime&quot;: &quot;2020-03-03 17:00:32&quot;,            &quot;parent&quot;: null,            &quot;nodes&quot;: []        },        {            &quot;id&quot;: 29,            &quot;name&quot;: &quot;Java&quot;,            &quot;parentId&quot;: null,            &quot;codeId&quot;: 4,            &quot;sort&quot;: 2,            &quot;remarks&quot;: &quot;&quot;,            &quot;createTime&quot;: &quot;2020-03-03 17:43:04&quot;,            &quot;updateTime&quot;: &quot;2020-03-03 17:43:04&quot;,            &quot;parent&quot;: null,            &quot;nodes&quot;: [                {                    &quot;id&quot;: 33,                    &quot;name&quot;: &quot;Spring&quot;,                    &quot;parentId&quot;: 29,                    &quot;codeId&quot;: 4,                    &quot;sort&quot;: 1,                    &quot;remarks&quot;: &quot;&quot;,                    &quot;createTime&quot;: &quot;2020-03-03 17:45:24&quot;,                    &quot;updateTime&quot;: &quot;2020-03-03 17:45:24&quot;,                    &quot;parent&quot;: null,                    &quot;nodes&quot;: [                        {                            &quot;id&quot;: 36,                            &quot;name&quot;: &quot;SpringBoot&quot;,                            &quot;parentId&quot;: 33,                            &quot;codeId&quot;: 4,                            &quot;sort&quot;: 1,                            &quot;remarks&quot;: &quot;&quot;,                            &quot;createTime&quot;: &quot;2020-03-04 14:26:39&quot;,                            &quot;updateTime&quot;: &quot;2020-03-04 14:26:39&quot;,                            &quot;parent&quot;: null,                            &quot;nodes&quot;: []                        },                        {                            &quot;id&quot;: 37,                            &quot;name&quot;: &quot;Spring Ioc&quot;,                            &quot;parentId&quot;: 33,                            &quot;codeId&quot;: 4,                            &quot;sort&quot;: 2,                            &quot;remarks&quot;: &quot;&quot;,                            &quot;createTime&quot;: &quot;2020-03-05 14:08:35&quot;,                            &quot;updateTime&quot;: &quot;2020-03-05 14:08:35&quot;,                            &quot;parent&quot;: null,                            &quot;nodes&quot;: []                        }                    ]                }            ]        },        {            &quot;id&quot;: 30,            &quot;name&quot;: &quot;Linux&quot;,            &quot;parentId&quot;: null,            &quot;codeId&quot;: 4,            &quot;sort&quot;: 3,            &quot;remarks&quot;: &quot;&quot;,            &quot;createTime&quot;: &quot;2020-03-03 17:43:55&quot;,            &quot;updateTime&quot;: &quot;2020-03-03 17:43:55&quot;,            &quot;parent&quot;: null,            &quot;nodes&quot;: []        },        {            &quot;id&quot;: 31,            &quot;name&quot;: &quot;数据库&quot;,            &quot;parentId&quot;: null,            &quot;codeId&quot;: 4,            &quot;sort&quot;: 4,            &quot;remarks&quot;: &quot;&quot;,            &quot;createTime&quot;: &quot;2020-03-03 17:44:06&quot;,            &quot;updateTime&quot;: &quot;2020-03-03 17:44:06&quot;,            &quot;parent&quot;: null,            &quot;nodes&quot;: []        },        {            &quot;id&quot;: 32,            &quot;name&quot;: &quot;开发工具&quot;,            &quot;parentId&quot;: null,            &quot;codeId&quot;: 4,            &quot;sort&quot;: 5,            &quot;remarks&quot;: &quot;&quot;,            &quot;createTime&quot;: &quot;2020-03-03 17:44:18&quot;,            &quot;updateTime&quot;: &quot;2020-03-03 17:44:18&quot;,            &quot;parent&quot;: null,            &quot;nodes&quot;: []        },        {            &quot;id&quot;: 34,            &quot;name&quot;: &quot;前端&quot;,            &quot;parentId&quot;: null,            &quot;codeId&quot;: 4,            &quot;sort&quot;: 6,            &quot;remarks&quot;: &quot;&quot;,            &quot;createTime&quot;: &quot;2020-03-03 17:49:11&quot;,            &quot;updateTime&quot;: &quot;2020-03-03 17:49:11&quot;,            &quot;parent&quot;: null,            &quot;nodes&quot;: []        },        {            &quot;id&quot;: 35,            &quot;name&quot;: &quot;其他&quot;,            &quot;parentId&quot;: null,            &quot;codeId&quot;: 4,            &quot;sort&quot;: 7,            &quot;remarks&quot;: &quot;&quot;,            &quot;createTime&quot;: &quot;2020-03-03 17:50:04&quot;,            &quot;updateTime&quot;: &quot;2020-03-03 17:50:04&quot;,            &quot;parent&quot;: null,            &quot;nodes&quot;: []        }    ]}</code></pre><h3 id="实现无限极目录树"><a href="#实现无限极目录树" class="headerlink" title="实现无限极目录树"></a>实现无限极目录树</h3><pre><code class="html">&lt;ul id=&quot;nav&quot;&gt;    &lt;!--中间代码为加载后示例，有js的话只需要最外层ul--&gt;    &lt;!--一级菜单--&gt;    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;一级菜单&lt;/a&gt;&lt;/li&gt;    &lt;!--二级菜单--&gt;    &lt;li class=&quot;dropdown-trigger&quot;&gt;        &lt;a href=&quot;#&quot;&gt;一级菜单&lt;/a&gt;        &lt;ul class=&quot;dropdown-content&quot;&gt;            &lt;li&gt;&lt;a href=&quot;category-standard.html&quot;&gt;二级菜单&lt;/a&gt;&lt;/li&gt;            &lt;li&gt;&lt;a href=&quot;category-grid.html&quot;&gt;二级菜单&lt;/a&gt;&lt;/li&gt;            &lt;li&gt;&lt;a href=&quot;category-list.html&quot;&gt;二级菜单&lt;/a&gt;&lt;/li&gt;        &lt;/ul&gt;    &lt;/li&gt;    &lt;!--三级级菜单--&gt;    &lt;li class=&quot;dropdown-trigger&quot;&gt;        &lt;a href=&quot;#&quot;&gt;一级菜单&lt;/a&gt;        &lt;ul class=&quot;dropdown-content&quot;&gt;            &lt;li class=&quot;dropdown-trigger&quot;&gt;                &lt;a href=&quot;#&quot;&gt;二级菜单&lt;/a&gt;                    &lt;ul class=&quot;dropdown-content&quot;&gt;                        &lt;li&gt;&lt;a href=&quot;index.html&quot;&gt;三级级菜单&lt;/a&gt;&lt;/li&gt;                    &lt;/ul&gt;            &lt;/li&gt;            &lt;li class=&quot;dropdown-trigger&quot;&gt;                &lt;a href=&quot;#&quot;&gt;Blog&lt;/a&gt;                &lt;ul class=&quot;dropdown-content&quot;&gt;                    &lt;li&gt;&lt;a href=&quot;index06.html&quot;&gt;三级级菜单&lt;/a&gt;&lt;/li&gt;                &lt;/ul&gt;            &lt;/li&gt;        &lt;/ul&gt;    &lt;/li&gt;    .......    &lt;!--中间代码为加载后示例，有js的话只需要最外层ul--&gt;&lt;/ul&gt;</code></pre><pre><code class="javascript">/** * &lt;p&gt; 描述 : 加载导航多级菜单 * @author : blackcat * @date  : 2020/3/4 16:02 * @param codeId 系统参数配置 查看CodeKey类*/function navigation(codeId) {    $.get(&quot;/code/getCodesByCodeListId/&quot;+codeId,function (json) {        if (json){            var data=json.data;            var html=&#39;&#39;;            for (var i=0; i&lt;data.length; i++) {                var code=data[i];                if(code.nodes.length==0){                    html+=&#39;&lt;li&gt;&lt;a href=&quot;&#39; + code.remarks + &#39;&quot;&gt;&#39; + code.name + &#39;&lt;/a&gt;&lt;/li&gt;&#39;;                }else{                    html+=&#39;&lt;li class=&quot;dropdown-trigger&quot;&gt;&lt;a href=&quot;#&quot;&gt;&#39; + code.name + &#39;&lt;/a&gt;&#39;;                    html+=loadChild(code);                    html+=&#39;&lt;/li&gt;&#39;;                }            }            $(&quot;#nav&quot;).append(html);        }    });}/** * &lt;p&gt; 描述 : 加载导航子菜单（递归） * @author : blackcat * @date  : 2020/3/5 14:12*/function loadChild(code){    var str =&#39;&lt;ul class=&quot;dropdown-content&quot;&gt;&#39;;    for(var i=0;i&lt;code.nodes.length;i++){        var child=code.nodes[i];        if (child.nodes.length &gt; 0) {            str +=&#39;&lt;li class=&quot;dropdown-trigger&quot;&gt;&lt;a href=&quot;&#39; + child.remarks + &#39;&quot;&gt;&#39; + child.name + &#39;&lt;/a&gt;&#39;;            str += loadChild(child);        } else {            str +=&#39;&lt;li&gt;&lt;a href=&quot;&#39; + child.remarks + &#39;&quot;&gt;&#39; + child.name + &#39;&lt;/a&gt;&#39;;        }        str +=&#39;&lt;/li&gt;&#39;;    };    str +=&#39;&lt;/ul&gt;&#39;;    return str;}</code></pre><p><img src="/img/js/2.png" alt=""></p><h3 id="实现无限极下拉框"><a href="#实现无限极下拉框" class="headerlink" title="实现无限极下拉框"></a>实现无限极下拉框</h3><pre><code class="html">&lt;select id=&quot;parentId&quot;&gt;&lt;/select&gt;</code></pre><pre><code class="javascript">/** * &lt;p&gt; 描述 : 码表管理父级选择(下拉框树) * @author : blackcat * @date  : 2020/3/6 16:58*/function loadCode(codeId) {    $.get(&quot;/code/getCodesByCodeListId/&quot;+codeId,function (json) {        if (json){            var data=json.data;            var html=&#39;&#39;;            for (var i=0; i&lt;data.length; i++) {                var code=data[i];                html+=&#39;&lt;option value=&quot;&#39; + code.id + &#39;&quot;&gt;&#39; + code.name + &#39;&lt;/option&gt;&#39;;                if (code.nodes.length &gt; 0) {                    html += creatSelectTree(code);                }            }            $(&quot;#parentId&quot;).append(html);        }    });}var j=&quot;&amp;nbsp;&amp;nbsp;|-&quot;;//前缀符号，用于显示父子关系，这里可以使用其它符号/** * &lt;p&gt; 描述 : 生成树下拉菜单 * @author : blackcat * @date  : 2020/3/6 16:55*/function creatSelectTree(code){    var option=&quot;&quot;;    for(var i=0;i&lt;code.nodes.length;i++){        var child=code.nodes[i];        if(child.nodes.length &gt; 0){//如果有子集            option+=&quot;&lt;option value=&#39;&quot;+child.id+&quot;&#39;&gt;&quot;+j+child.name+&quot;&lt;/option&gt;&quot;;            j+=&quot;&amp;nbsp;&amp;nbsp;|-&quot;;//前缀符号加一个符号            option+=creatSelectTree(child);//递归调用子集            j=j.slice(0,j.length-1);//每次递归结束返回上级时，前缀符号需要减一个符号        }else{//没有子集直接显示            option+=&quot;&lt;option value=&#39;&quot;+child.id+&quot;&#39;&gt;&quot;+j+child.name+&quot;&lt;/option&gt;&quot;;        }    }    return option;//返回最终html结果}</code></pre><p><img src="/img/js/1.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>收藏网站（生活）</title>
      <link href="/2020/02/17/website-life/"/>
      <url>/2020/02/17/website-life/</url>
      
        <content type="html"><![CDATA[<p>整理一些收藏的好用网站</p><a id="more"></a><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p><a href="http://www.bigpixel.cn/index.html" target="_blank" rel="noopener">千亿像素看中国</a> ：超高像素的城市图片<br><a href="https://artbreeder.com/" target="_blank" rel="noopener">AI 捏图</a> ：捏图<br><a href="https://www.nvidia.com/en-us/research/ai-playground/?fbclid=IwAR2QEjuH4aCYP3SycnKwa_LO36rfmDhulB4WCeY1plGCfofwIU-qf1anBTY" target="_blank" rel="noopener">N卡深度学习</a><br><a href="https://duotone.shapefactory.co/?f=f56468&t=27184f&q=_" target="_blank" rel="noopener">双色</a> ：给图片配双色</p><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p><a href="https://humanbenchmark.com/" target="_blank" rel="noopener">人类测试</a> ：集合各种测试的网站<br><a href="https://melody.ml/" target="_blank" rel="noopener">音乐分轨</a> ：简单的音乐分轨网站<br><a href="https://neave.com/" target="_blank" rel="noopener">neave</a> ：一个大佬做个各种软件<br><a href="https://www.materialtools.com/?page=1" target="_blank" rel="noopener">临时手机号</a> ：使用公共手机接收验证码<br><a href="http://24mail.chacuo.net/" target="_blank" rel="noopener">临时邮箱</a> ：使用公共邮箱接收验证码<br><a href="https://wejizan.com/" target="_blank" rel="noopener">点赞生成器</a> ：点赞生成器<br><a href="https://wangyasai.github.io/" target="_blank" rel="noopener">亚塞</a> ： 用P5.js做的一些小工具<br><a href="https://zh.wix.com/" target="_blank" rel="noopener">做网站</a> ：无基础网站制作</p><h3 id="学习知识"><a href="#学习知识" class="headerlink" title="学习知识"></a>学习知识</h3><p><a href="https://learningmusic.ableton.com/" target="_blank" rel="noopener">学音乐</a> ：简单的学习音乐的网站<br><a href="https://www.allhistory.com/" target="_blank" rel="noopener">全历史</a> ：详细世界历史网站<br><a href="https://www.ageeye.cn/" target="_blank" rel="noopener">中国地图</a> ：将海外各大图书馆开放下载的中国古旧地图整理翻译，汇集为结构化数据库<br><a href="https://www.visualcapitalist.com/" target="_blank" rel="noopener">数据表</a> ：整合各种数据的精细图表（纯英文）<br><a href="https://www.msdmanuals.com/zh#%20mission" target="_blank" rel="noopener">默沙东诊疗手册</a> ：一个涵盖了医学所有领域成千上万主题的广泛医学信息来源。<br><a href="https://www.cn-ki.net/" target="_blank" rel="noopener">idata</a> ：专业知识搜索</p><h3 id="兴趣"><a href="#兴趣" class="headerlink" title="兴趣"></a>兴趣</h3><p><a href="http://nazo.one-story.cn/nazo-1" target="_blank" rel="noopener">解谜</a> ：解谜</p>]]></content>
      
      
      <categories>
          
          <category> 网址 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot 集成 solr</title>
      <link href="/2020/02/16/springboot-solr/"/>
      <url>/2020/02/16/springboot-solr/</url>
      
        <content type="html"><![CDATA[<p>springboot 2.2<br>solr 8.0.0</p><a id="more"></a><h2 id="win10下载安装配置"><a href="#win10下载安装配置" class="headerlink" title="win10下载安装配置"></a>win10下载安装配置</h2><h3 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h3><p><strong><em>下载</em></strong> ：<a href="http://archive.apache.org/dist/lucene/solr/8.0.0/" target="_blank" rel="noopener">solr 8.0.0下载地址</a><br><strong><em>安装</em></strong> ：</p><blockquote><p>保存到本地任意目录，解压。cmd：cd到解压目录/bin下，执行</p></blockquote><pre><code class="xml">solr start</code></pre><p><img src="/img/solr/01.png" alt=""></p><blockquote><p>即可以默认端口启动solr控制台，浏览器输入地址：</p></blockquote><p><a href="http://localhost:8983/solr/#/" target="_blank" rel="noopener">http://localhost:8983/solr/#/</a></p><blockquote><p>创建模块。两种方式：</p></blockquote><p>1：命令模式，<code>articles</code>为模块名称。</p><pre><code class="xml">solr create -c articles</code></pre><p><img src="/img/solr/02.png" alt=""></p><p>2：控制台增加一个core：Core Admin -&gt; Add Core -&gt; demo_core，如下图所示：<br><img src="/img/solr/4.png" alt=""></p><h3 id="安装中文分词库"><a href="#安装中文分词库" class="headerlink" title="安装中文分词库"></a>安装中文分词库</h3><p><strong><em>下载</em></strong> ：<a href="https://search.maven.org/search?q=com.github.magese" target="_blank" rel="noopener">IK分词器 ik-analyzer-solr7:7.x</a><br><strong><em>配置</em></strong> ：<br>solr-8.0.0\server\solr\articles\conf managed-schema 文件，在文件末尾</schema>之前添加以下代码：</p><pre><code class="xml">&lt;fieldType name=&quot;text_ik&quot; class=&quot;solr.TextField&quot;&gt;    &lt;analyzer type=&quot;index&quot;&gt;        &lt;tokenizer class=&quot;org.wltea.analyzer.lucene.IKTokenizerFactory&quot; useSmart=&quot;false&quot; conf=&quot;ik.conf&quot;/&gt;        &lt;filter class=&quot;solr.LowerCaseFilterFactory&quot;/&gt;    &lt;/analyzer&gt;    &lt;analyzer type=&quot;query&quot;&gt;      &lt;tokenizer class=&quot;org.wltea.analyzer.lucene.IKTokenizerFactory&quot; useSmart=&quot;true&quot; conf=&quot;ik.conf&quot;/&gt;      &lt;filter class=&quot;solr.LowerCaseFilterFactory&quot;/&gt;    &lt;/analyzer&gt;&lt;/fieldType&gt;</code></pre><p><strong><em>注</em></strong> ：路径中<code>articles</code>为模块名称，不同创建方式<code>schema</code>文件名称也有略有不同。</p><p><strong><em>测试</em></strong> ：<br><img src="/img/solr/2.png" alt=""></p><h3 id="连接mysql数据库"><a href="#连接mysql数据库" class="headerlink" title="连接mysql数据库"></a>连接mysql数据库</h3><h4 id="建表"><a href="#建表" class="headerlink" title="建表"></a><strong><em>建表</em></strong></h4><p>确保数据库中有表articles，且有id和name属性（这里为了方便测试，后续可根据需求增改表字段）</p><h4 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a><strong><em>修改配置文件</em></strong></h4><p>将solr根目录\dist下的两个jar：<code>solr-dataimporthandler-8.2.0.jar</code> 和 <code>solr-dataimporthandler-extras-8.2.0.jar</code><br>以及 <a href="https://mvnrepository.com/artifact/mysql/mysql-connector-java" target="_blank" rel="noopener">mysql-connector-java.jar</a> 拷贝到solr根目录\server\solr-webapp\webapp\WEB-INF\lib文件夹下</p><p>修改solr根目录\server\solr\articles\conf\solrconfig.xml</p><p>打开文件，找到下面语句的位置</p><pre><code class="xml">&lt;requestHandler name=&quot;/select&quot; class=&quot;solr.SearchHandler&quot;&gt;</code></pre><p>在该语句的上方添加如下语句：</p><pre><code class="xml">&lt;requestHandler name=&quot;/dataimport&quot; class=&quot;org.apache.solr.handler.dataimport.DataImportHandler&quot;&gt;    &lt;lst name=&quot;defaults&quot;&gt;        &lt;str name=&quot;config&quot;&gt;data-config.xml&lt;/str&gt;    &lt;/lst&gt;&lt;/requestHandler&gt;</code></pre><h4 id="新建data-config-xml文件"><a href="#新建data-config-xml文件" class="headerlink" title="新建data-config.xml文件"></a><strong><em>新建data-config.xml文件</em></strong></h4><p>修改文件managed-schema</p><pre><code class="xml">&lt;field name=&quot;id&quot; type=&quot;string&quot; indexed=&quot;true&quot; stored=&quot;true&quot; required=&quot;true&quot; multiValued=&quot;false&quot; /&gt;</code></pre><p>后加上</p><pre><code class="xml">&lt;field name=&quot;name&quot; type=&quot;text_ik&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt;</code></pre><p>这里不一定就是要再那一句后面加上，写在一起为了以后方便查看修改</p><p>在路径D:\solr\solr-8.2.0\server\solr\articles\conf下新建data-config.xml文件，文件内容如下：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;dataConfig&gt;    &lt;dataSource name = &quot;source1&quot; type = &quot;JdbcDataSource&quot; driver = &quot;com.mysql.jdbc.Driver&quot;                url = &quot;jdbc:mysql://localhost:3306/blog&quot; user=&quot;root&quot; password = &quot;111111&quot;                encoding=&quot;UTF-8&quot;/&gt;    &lt;document&gt;        &lt;entity name = &quot;articles&quot; processor = &quot;SqlEntityProcessor&quot; pk=&quot;id&quot;            query = &quot;select id,name from articles&quot;&gt;                &lt;field name = &quot;id&quot; column = &quot;id&quot;/&gt;                &lt;field name = &quot;name&quot; column = &quot;name&quot;/&gt;        &lt;/entity&gt;    &lt;/document&gt;&lt;/dataConfig&gt;</code></pre><p>配置说明：</p><ul><li><code>dataSource</code>是数据库数据源</li><li><code>entity</code>是一张表对应的实体，</li><li><code>pk</code>是主键，</li><li><code>query</code>是查询语句</li><li><code>field</code>对应一个字段，</li><li><code>column</code>是数据库里的column名，</li><li><code>name</code>属性对应着solr的filed的名字</li></ul><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>测试工具使用postman，执行成功可与solr admin控制台比对数据。</p><h3 id="新增-更新索引"><a href="#新增-更新索引" class="headerlink" title="新增/更新索引"></a>新增/更新索引</h3><p>请求地址：localhost:9983/solr/addOrUpdate<br><img src="/img/solr/5.png" alt=""></p><h3 id="根据id查询索引"><a href="#根据id查询索引" class="headerlink" title="根据id查询索引"></a>根据id查询索引</h3><p>localhost:9983/solr/getById?id=1<br><img src="/img/solr/6.png" alt=""></p><h3 id="根据id删除索引"><a href="#根据id删除索引" class="headerlink" title="根据id删除索引"></a>根据id删除索引</h3><p>localhost:9983/solr/delete?id=1<br><img src="/img/solr/7.png" alt=""></p><h3 id="综合查询"><a href="#综合查询" class="headerlink" title="综合查询"></a>综合查询</h3><p>localhost:9983/solr/search?q=name:测试<br><img src="/img/solr/8.png" alt=""></p><h2 id="solr常用启动命令"><a href="#solr常用启动命令" class="headerlink" title="solr常用启动命令"></a><strong><em>solr常用启动命令</em></strong></h2><ul><li><code>solr start -help</code> 查看start帮助</li><li><code>solr start</code> 启动单机版</li><li><code>solr start -f</code> 前台启动</li><li><code>solr start -p 8984</code> 指定端口启动</li><li><code>solr start -cloud</code> 启动分布式版本</li><li><code>solr start -e cloud -noprompt -e</code> 启动一个现有的SolrCloud例子，名称是cloud</li><li><code>solr restart -p 8983</code> 重启项目</li></ul><h2 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h2><h3 id="solr-Admin的dataimport无法显示entity"><a href="#solr-Admin的dataimport无法显示entity" class="headerlink" title="solr Admin的dataimport无法显示entity"></a><strong><em>solr Admin的dataimport无法显示entity</em></strong></h3><p>在data-config.xml文件中，如果连接的是MySQL8.0，那么在url中，如上所示在数据库名后面加上serverTimezone=CST即可，切忌一股脑加上<br>useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone=CST</p><h3 id="Expected-mime-type-application-octet-stream-but-got-text-html"><a href="#Expected-mime-type-application-octet-stream-but-got-text-html" class="headerlink" title="Expected mime type application/octet-stream but got text/html."></a>Expected mime type application/octet-stream but got text/html.</h3><p>配置文件 spring.data.solr.host 值后面不要带#<br>示例</p><pre><code class="xml">spring.data.solr.host=http://localhost:8983/solr/</code></pre>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> Solr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Springboot 集成 Shiro</title>
      <link href="/2020/02/01/springboot-shiro/"/>
      <url>/2020/02/01/springboot-shiro/</url>
      
        <content type="html"><![CDATA[<p>Springboot 2.2 + mybatis-plus 3.3.0 + Shiro 1.4.0.<br>写该文章的用意主要是很多博客使用springboot版本过低有些方法并不适用或没有示例或说的过于简洁或过于深入，不适用与初学者。<br>自己了解尚浅，文章只是给出主要方法。后附有示例源码可参考。密码加密及登录次数验证需看博客代码。<br>参考的博客后附有相关文章。</p><a id="more"></a><h2 id="简单登陆跳转"><a href="#简单登陆跳转" class="headerlink" title="简单登陆跳转"></a>简单登陆跳转</h2><h3 id="maven依赖"><a href="#maven依赖" class="headerlink" title="maven依赖"></a>maven依赖</h3><pre><code class="java">&lt;!--web--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--日志--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- Shiro 核心依赖 --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;    &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--shiro freemarker页面标签--&gt;&lt;dependency&gt;    &lt;groupId&gt;net.mingsoft&lt;/groupId&gt;    &lt;artifactId&gt;shiro-freemarker-tags&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--shiro redis--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.crazycake&lt;/groupId&gt;    &lt;artifactId&gt;shiro-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- Redis --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-redis-reactive&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- mysql --&gt;&lt;dependency&gt;    &lt;groupId&gt;mysql&lt;/groupId&gt;    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;    &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;!--druid--&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;druid&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- mybatisPlus 核心库 --&gt;&lt;dependency&gt;    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--分页--&gt;&lt;dependency&gt;    &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;    &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- mybatisPlus 代码生成器插件--&gt;&lt;dependency&gt;    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- 代码生成器模板--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.freemarker&lt;/groupId&gt;    &lt;artifactId&gt;freemarker&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--java持久化API--&gt;&lt;dependency&gt;    &lt;groupId&gt;javax.persistence&lt;/groupId&gt;    &lt;artifactId&gt;persistence-api&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><h3 id="表Sql"><a href="#表Sql" class="headerlink" title="表Sql"></a>表Sql</h3><pre><code class="sql">SET FOREIGN_KEY_CHECKS=0;-- ------------------------------ Table structure for sys_menu-- ----------------------------DROP TABLE IF EXISTS `sys_menu`;CREATE TABLE `sys_menu` (  `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT,  `name` varchar(100) DEFAULT NULL COMMENT &#39;权限名称&#39;,  `type`  enum(&#39;menu&#39;,&#39;button&#39;) DEFAULT &#39;menu&#39; COMMENT &#39;权限类型（菜单，按钮）&#39;,  `url` varchar(200) DEFAULT NULL COMMENT &#39;资源路径&#39;,  `permission` varchar(100) DEFAULT NULL COMMENT &#39;权限标识(多个用逗号分隔，如：user:list,user:create)&#39;,  `parent_id` bigint(20) unsigned DEFAULT &#39;0&#39; COMMENT &#39;父节点&#39;,  `sort` int(10) unsigned DEFAULT NULL COMMENT &#39;排序&#39;,  `external` tinyint(1) unsigned DEFAULT NULL COMMENT &#39;是否外部链接&#39;,  `available` tinyint(1) unsigned DEFAULT &#39;0&#39; COMMENT &#39;是否可用&#39;,  `icon` varchar(100) DEFAULT NULL COMMENT &#39;菜单图标&#39;,  `create_time` datetime DEFAULT CURRENT_TIMESTAMP COMMENT &#39;添加时间&#39;,  `update_time` datetime DEFAULT CURRENT_TIMESTAMP COMMENT &#39;更新时间&#39;,  PRIMARY KEY (`id`) USING BTREE,  KEY `idx_sys_resource_parent_id` (`parent_id`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=22 DEFAULT CHARSET=utf8 COMMENT = &#39;权限表&#39; ROW_FORMAT=COMPACT;INSERT INTO `sys_menu` VALUES (&#39;1&#39;, &#39;用户管理&#39;, &#39;menu&#39;, null, null, &#39;0&#39;, &#39;1&#39;, &#39;0&#39;, &#39;1&#39;, &#39;fa fa-users&#39;, &#39;2018-05-16 17:02:54&#39;, &#39;2018-05-16 17:02:54&#39;);INSERT INTO `sys_menu` VALUES (&#39;2&#39;, &#39;用户列表&#39;, &#39;menu&#39;, &#39;/user/index&#39;, &#39;users&#39;, &#39;1&#39;, &#39;1&#39;, &#39;0&#39;, &#39;1&#39;, null, &#39;2017-12-22 13:56:15&#39;, &#39;2018-05-16 14:44:20&#39;);INSERT INTO `sys_menu` VALUES (&#39;3&#39;, &#39;新增用户&#39;, &#39;button&#39;, null, &#39;user:add&#39;, &#39;2&#39;, &#39;2&#39;, &#39;0&#39;, &#39;1&#39;, null, &#39;2018-05-16 14:07:43&#39;, &#39;2018-05-16 14:16:23&#39;);INSERT INTO `sys_menu` VALUES (&#39;4&#39;, &#39;批量删除用户&#39;, &#39;button&#39;, null, &#39;user:batchDelete&#39;, &#39;2&#39;, &#39;3&#39;, &#39;0&#39;, &#39;1&#39;, null, &#39;2018-05-16 14:12:23&#39;, &#39;2018-05-16 14:16:35&#39;);INSERT INTO `sys_menu` VALUES (&#39;5&#39;, &#39;编辑用户&#39;, &#39;button&#39;, null, &#39;user:edit&#39;, &#39;2&#39;, &#39;4&#39;, &#39;0&#39;, &#39;1&#39;, null, &#39;2018-05-16 14:12:50&#39;, &#39;2018-05-16 14:16:43&#39;);INSERT INTO `sys_menu` VALUES (&#39;6&#39;, &#39;删除用户&#39;, &#39;button&#39;, null, &#39;user:delete&#39;, &#39;2&#39;, &#39;5&#39;, &#39;0&#39;, &#39;1&#39;, null, &#39;2018-05-16 14:13:09&#39;, &#39;2018-05-16 14:51:50&#39;);INSERT INTO `sys_menu` VALUES (&#39;7&#39;, &#39;分配用户角色&#39;, &#39;button&#39;, null, &#39;user:allotRole&#39;, &#39;2&#39;, &#39;6&#39;, &#39;0&#39;, &#39;1&#39;, null, &#39;2018-05-16 14:15:28&#39;, &#39;2018-05-16 14:16:54&#39;);INSERT INTO `sys_menu` VALUES (&#39;8&#39;, &#39;系统配置&#39;, &#39;menu&#39;, null, null, &#39;0&#39;, &#39;2&#39;, &#39;0&#39;, &#39;1&#39;, &#39;fa fa-cogs&#39;, &#39;2017-12-20 16:40:06&#39;, &#39;2017-12-20 16:40:08&#39;);INSERT INTO `sys_menu` VALUES (&#39;9&#39;, &#39;资源管理&#39;, &#39;menu&#39;, &#39;/menu/index&#39;, &#39;resources&#39;, &#39;8&#39;, &#39;1&#39;, &#39;0&#39;, &#39;1&#39;, null, &#39;2017-12-22 15:31:05&#39;, &#39;2017-12-22 15:31:05&#39;);INSERT INTO `sys_menu` VALUES (&#39;10&#39;, &#39;新增资源&#39;, &#39;button&#39;, null, &#39;resource:add&#39;, &#39;9&#39;, &#39;2&#39;, &#39;0&#39;, &#39;1&#39;, null, &#39;2018-05-16 14:07:43&#39;, &#39;2018-05-16 14:16:23&#39;);INSERT INTO `sys_menu` VALUES (&#39;11&#39;, &#39;批量删除资源&#39;, &#39;button&#39;, null, &#39;resource:batchDelete&#39;, &#39;9&#39;, &#39;3&#39;, &#39;0&#39;, &#39;1&#39;, null, &#39;2018-05-16 14:12:23&#39;, &#39;2018-05-16 14:16:35&#39;);INSERT INTO `sys_menu` VALUES (&#39;12&#39;, &#39;编辑资源&#39;, &#39;button&#39;, null, &#39;resource:edit&#39;, &#39;9&#39;, &#39;4&#39;, &#39;0&#39;, &#39;1&#39;, null, &#39;2018-05-16 14:12:50&#39;, &#39;2018-05-16 14:16:43&#39;);INSERT INTO `sys_menu` VALUES (&#39;13&#39;, &#39;删除资源&#39;, &#39;button&#39;, null, &#39;resource:delete&#39;, &#39;9&#39;, &#39;5&#39;, &#39;0&#39;, &#39;1&#39;, null, &#39;2018-05-16 14:13:09&#39;, &#39;2018-05-16 14:51:50&#39;);INSERT INTO `sys_menu` VALUES (&#39;14&#39;, &#39;角色管理&#39;, &#39;menu&#39;, &#39;/role/index&#39;, &#39;roles&#39;, &#39;8&#39;, &#39;2&#39;, &#39;0&#39;, &#39;1&#39;, &#39;&#39;, &#39;2017-12-22 15:31:27&#39;, &#39;2018-05-17 12:51:06&#39;);INSERT INTO `sys_menu` VALUES (&#39;15&#39;, &#39;新增角色&#39;, &#39;button&#39;, null, &#39;role:add&#39;, &#39;14&#39;, &#39;2&#39;, &#39;0&#39;, &#39;1&#39;, null, &#39;2018-05-16 14:07:43&#39;, &#39;2018-05-16 14:16:23&#39;);INSERT INTO `sys_menu` VALUES (&#39;16&#39;, &#39;批量删除角色&#39;, &#39;button&#39;, null, &#39;role:batchDelete&#39;, &#39;14&#39;, &#39;3&#39;, &#39;0&#39;, &#39;1&#39;, null, &#39;2018-05-16 14:12:23&#39;, &#39;2018-05-16 14:16:35&#39;);INSERT INTO `sys_menu` VALUES (&#39;17&#39;, &#39;编辑角色&#39;, &#39;button&#39;, null, &#39;role:edit&#39;, &#39;14&#39;, &#39;4&#39;, &#39;0&#39;, &#39;1&#39;, null, &#39;2018-05-16 14:12:50&#39;, &#39;2018-05-16 14:16:43&#39;);INSERT INTO `sys_menu` VALUES (&#39;18&#39;, &#39;删除角色&#39;, &#39;button&#39;, null, &#39;role:delete&#39;, &#39;14&#39;, &#39;5&#39;, &#39;0&#39;, &#39;1&#39;, null, &#39;2018-05-16 14:13:09&#39;, &#39;2018-05-16 14:51:50&#39;);INSERT INTO `sys_menu` VALUES (&#39;19&#39;, &#39;分配角色资源&#39;, &#39;button&#39;, null, &#39;role:allotResource&#39;, &#39;14&#39;, &#39;6&#39;, &#39;0&#39;, &#39;1&#39;, null, &#39;2018-05-17 10:04:21&#39;, &#39;2018-05-17 10:04:21&#39;);INSERT INTO `sys_menu` VALUES (&#39;20&#39;, &#39;数据监控&#39;, &#39;menu&#39;, &#39;&#39;, &#39;&#39;, null, &#39;3&#39;, &#39;0&#39;, &#39;1&#39;, &#39;fa fa-heartbeat&#39;, &#39;2018-05-17 12:38:20&#39;, &#39;2018-05-17 12:53:06&#39;);INSERT INTO `sys_menu` VALUES (&#39;21&#39;, &#39;Druid监控&#39;, &#39;menu&#39;, &#39;/druid/index.html&#39;, &#39;druid&#39;, &#39;20&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;&#39;, &#39;2018-05-17 12:46:37&#39;, &#39;2018-05-17 12:52:33&#39;);-- ------------------------------ Table structure for sys_role-- ----------------------------DROP TABLE IF EXISTS `sys_role`;CREATE TABLE `sys_role` (  `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT,  `name` varchar(100) DEFAULT NULL COMMENT &#39;角色名&#39;,  `description` varchar(100) DEFAULT NULL COMMENT &#39;描述&#39;,  `available` tinyint(1) DEFAULT &#39;0&#39; COMMENT &#39;是否可用&#39;,  `create_time` datetime DEFAULT CURRENT_TIMESTAMP COMMENT &#39;添加时间&#39;,  `update_time` datetime DEFAULT CURRENT_TIMESTAMP COMMENT &#39;更新时间&#39;,  PRIMARY KEY (`id`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8 COMMENT = &#39;角色表&#39; ROW_FORMAT=COMPACT;INSERT INTO `sys_role` VALUES (&#39;1&#39;, &#39;role:root&#39;, &#39;超级管理员&#39;, &#39;1&#39;, &#39;2017-12-20 16:40:24&#39;, &#39;2017-12-20 16:40:26&#39;);INSERT INTO `sys_role` VALUES (&#39;2&#39;, &#39;role:admin&#39;, &#39;管理员&#39;, &#39;1&#39;, &#39;2017-12-22 13:56:39&#39;, &#39;2017-12-22 13:56:39&#39;);-- ------------------------------ Table structure for sys_role_menu-- ----------------------------DROP TABLE IF EXISTS `sys_role_menu`;CREATE TABLE `sys_role_menu`  (  `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT,  `role_id` bigint(20) unsigned NOT NULL COMMENT &#39;角色ID&#39;,  `menu_id` bigint(20) unsigned NOT NULL COMMENT &#39;权限ID&#39;,  `create_time` datetime DEFAULT CURRENT_TIMESTAMP COMMENT &#39;添加时间&#39;,  `update_time` datetime DEFAULT CURRENT_TIMESTAMP COMMENT &#39;更新时间&#39;,  PRIMARY KEY (`id`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=57 DEFAULT CHARSET=utf8 COMMENT = &#39;角色与权限关系表&#39; ROW_FORMAT=COMPACT;INSERT INTO `sys_role_menu` VALUES (&#39;27&#39;, &#39;1&#39;, &#39;20&#39;, &#39;2018-05-17 12:52:41&#39;, &#39;2018-05-17 12:52:41&#39;);INSERT INTO `sys_role_menu` VALUES (&#39;28&#39;, &#39;1&#39;, &#39;21&#39;, &#39;2018-05-17 12:52:41&#39;, &#39;2018-05-17 12:52:41&#39;);INSERT INTO `sys_role_menu` VALUES (&#39;29&#39;, &#39;1&#39;, &#39;1&#39;, &#39;2018-05-17 12:52:41&#39;, &#39;2018-05-17 12:52:41&#39;);INSERT INTO `sys_role_menu` VALUES (&#39;30&#39;, &#39;1&#39;, &#39;2&#39;, &#39;2018-05-17 12:52:41&#39;, &#39;2018-05-17 12:52:41&#39;);INSERT INTO `sys_role_menu` VALUES (&#39;31&#39;, &#39;1&#39;, &#39;3&#39;, &#39;2018-05-17 12:52:41&#39;, &#39;2018-05-17 12:52:41&#39;);INSERT INTO `sys_role_menu` VALUES (&#39;32&#39;, &#39;1&#39;, &#39;4&#39;, &#39;2018-05-17 12:52:41&#39;, &#39;2018-05-17 12:52:41&#39;);INSERT INTO `sys_role_menu` VALUES (&#39;33&#39;, &#39;1&#39;, &#39;5&#39;, &#39;2018-05-17 12:52:41&#39;, &#39;2018-05-17 12:52:41&#39;);INSERT INTO `sys_role_menu` VALUES (&#39;34&#39;, &#39;1&#39;, &#39;6&#39;, &#39;2018-05-17 12:52:41&#39;, &#39;2018-05-17 12:52:41&#39;);INSERT INTO `sys_role_menu` VALUES (&#39;35&#39;, &#39;1&#39;, &#39;7&#39;, &#39;2018-05-17 12:52:41&#39;, &#39;2018-05-17 12:52:41&#39;);INSERT INTO `sys_role_menu` VALUES (&#39;36&#39;, &#39;1&#39;, &#39;8&#39;, &#39;2018-05-17 12:52:41&#39;, &#39;2018-05-17 12:52:41&#39;);INSERT INTO `sys_role_menu` VALUES (&#39;37&#39;, &#39;1&#39;, &#39;9&#39;, &#39;2018-05-17 12:52:41&#39;, &#39;2018-05-17 12:52:41&#39;);INSERT INTO `sys_role_menu` VALUES (&#39;38&#39;, &#39;1&#39;, &#39;10&#39;, &#39;2018-05-17 12:52:41&#39;, &#39;2018-05-17 12:52:41&#39;);INSERT INTO `sys_role_menu` VALUES (&#39;39&#39;, &#39;1&#39;, &#39;11&#39;, &#39;2018-05-17 12:52:41&#39;, &#39;2018-05-17 12:52:41&#39;);INSERT INTO `sys_role_menu` VALUES (&#39;40&#39;, &#39;1&#39;, &#39;12&#39;, &#39;2018-05-17 12:52:41&#39;, &#39;2018-05-17 12:52:41&#39;);INSERT INTO `sys_role_menu` VALUES (&#39;41&#39;, &#39;1&#39;, &#39;13&#39;, &#39;2018-05-17 12:52:41&#39;, &#39;2018-05-17 12:52:41&#39;);INSERT INTO `sys_role_menu` VALUES (&#39;42&#39;, &#39;1&#39;, &#39;14&#39;, &#39;2018-05-17 12:52:41&#39;, &#39;2018-05-17 12:52:41&#39;);INSERT INTO `sys_role_menu` VALUES (&#39;43&#39;, &#39;1&#39;, &#39;15&#39;, &#39;2018-05-17 12:52:41&#39;, &#39;2018-05-17 12:52:41&#39;);INSERT INTO `sys_role_menu` VALUES (&#39;44&#39;, &#39;1&#39;, &#39;16&#39;, &#39;2018-05-17 12:52:41&#39;, &#39;2018-05-17 12:52:41&#39;);INSERT INTO `sys_role_menu` VALUES (&#39;45&#39;, &#39;1&#39;, &#39;17&#39;, &#39;2018-05-17 12:52:41&#39;, &#39;2018-05-17 12:52:41&#39;);INSERT INTO `sys_role_menu` VALUES (&#39;46&#39;, &#39;1&#39;, &#39;18&#39;, &#39;2018-05-17 12:52:41&#39;, &#39;2018-05-17 12:52:41&#39;);INSERT INTO `sys_role_menu` VALUES (&#39;47&#39;, &#39;1&#39;, &#39;19&#39;, &#39;2018-05-17 12:52:41&#39;, &#39;2018-05-17 12:52:41&#39;);INSERT INTO `sys_role_menu` VALUES (&#39;48&#39;, &#39;2&#39;, &#39;20&#39;, &#39;2018-05-17 12:52:51&#39;, &#39;2018-05-17 12:52:51&#39;);INSERT INTO `sys_role_menu` VALUES (&#39;49&#39;, &#39;2&#39;, &#39;21&#39;, &#39;2018-05-17 12:52:51&#39;, &#39;2018-05-17 12:52:51&#39;);INSERT INTO `sys_role_menu` VALUES (&#39;50&#39;, &#39;2&#39;, &#39;2&#39;, &#39;2018-05-17 12:52:51&#39;, &#39;2018-05-17 12:52:51&#39;);INSERT INTO `sys_role_menu` VALUES (&#39;51&#39;, &#39;2&#39;, &#39;3&#39;, &#39;2018-05-17 12:52:51&#39;, &#39;2018-05-17 12:52:51&#39;);INSERT INTO `sys_role_menu` VALUES (&#39;52&#39;, &#39;2&#39;, &#39;8&#39;, &#39;2018-05-17 12:52:51&#39;, &#39;2018-05-17 12:52:51&#39;);INSERT INTO `sys_role_menu` VALUES (&#39;53&#39;, &#39;2&#39;, &#39;9&#39;, &#39;2018-05-17 12:52:51&#39;, &#39;2018-05-17 12:52:51&#39;);INSERT INTO `sys_role_menu` VALUES (&#39;54&#39;, &#39;2&#39;, &#39;10&#39;, &#39;2018-05-17 12:52:51&#39;, &#39;2018-05-17 12:52:51&#39;);INSERT INTO `sys_role_menu` VALUES (&#39;55&#39;, &#39;2&#39;, &#39;14&#39;, &#39;2018-05-17 12:52:51&#39;, &#39;2018-05-17 12:52:51&#39;);INSERT INTO `sys_role_menu` VALUES (&#39;56&#39;, &#39;2&#39;, &#39;15&#39;, &#39;2018-05-17 12:52:51&#39;, &#39;2018-05-17 12:52:51&#39;);INSERT INTO `sys_role_menu` VALUES (&#39;57&#39;, &#39;2&#39;, &#39;1&#39;, &#39;2018-05-17 12:52:51&#39;, &#39;2018-05-17 12:52:51&#39;);-- ------------------------------ Table structure for sys_user-- ----------------------------DROP TABLE IF EXISTS `sys_user`;CREATE TABLE `sys_user`  (  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,  `username` varchar(100) DEFAULT NULL COMMENT &#39;用户名称&#39;,  `password` varchar(100) DEFAULT NULL COMMENT &#39;登录密码&#39;,  `nickname` varchar(30) DEFAULT &#39;&#39; COMMENT &#39;昵称&#39;,  `mobile` varchar(30) DEFAULT NULL COMMENT &#39;手机号&#39;,  `email` varchar(100) DEFAULT NULL COMMENT &#39;邮箱地址&#39;,  `birthday` date DEFAULT NULL COMMENT &#39;生日&#39;,  `gender` tinyint(2) unsigned DEFAULT NULL COMMENT &#39;性别&#39;,  `avatar` varchar(255) DEFAULT NULL COMMENT &#39;头像地址&#39;,  `user_type` enum(&#39;ROOT&#39;,&#39;ADMIN&#39;,&#39;USER&#39;) DEFAULT &#39;ADMIN&#39; COMMENT &#39;ROOT超级管理员、ADMIN管理员、USER普通用户&#39;,  `reg_ip` varchar(30) DEFAULT NULL COMMENT &#39;注册IP&#39;,  `last_login_ip` varchar(30) DEFAULT NULL COMMENT &#39;最近登录IP&#39;,  `last_login_time` datetime DEFAULT NULL COMMENT &#39;最近登录时间&#39;,  `login_count` int(10) unsigned DEFAULT &#39;0&#39; COMMENT &#39;登录次数&#39;,  `remark` varchar(100) DEFAULT NULL COMMENT &#39;备注&#39;,  `status` int(1) unsigned DEFAULT NULL COMMENT &#39;状态  0:禁用 1:正常&#39;,  `create_time` datetime DEFAULT CURRENT_TIMESTAMP COMMENT &#39;注册时间&#39;,  `update_time` datetime DEFAULT CURRENT_TIMESTAMP COMMENT &#39;更新时间&#39;,  PRIMARY KEY (`id`) USING BTREE) ENGINE=MyISAM AUTO_INCREMENT=3 DEFAULT CHARSET=utf8 COMMENT = &#39;系统用户表&#39; ROW_FORMAT=DYNAMIC;INSERT INTO `sys_user` VALUES (&#39;1&#39;, &#39;root&#39;, &#39;123456&#39;, &#39;超级管理员&#39;, &#39;15151551516&#39;, &#39;123456789@qq.com&#39;, null, null, &#39;https://static.zhyd.me/static/img/favicon.ico&#39;, &#39;ROOT&#39;, null, &#39;127.0.0.1&#39;, &#39;2018-05-17 13:09:35&#39;, &#39;228&#39;, null, &#39;1&#39;, &#39;2018-01-02 09:32:15&#39;, &#39;2018-05-17 13:09:35&#39;);INSERT INTO `sys_user` VALUES (&#39;2&#39;, &#39;admin&#39;, &#39;123456&#39;, &#39;管理员&#39;, &#39;15151551516&#39;, &#39;123456789@qq.com&#39;, null, null, null, &#39;ADMIN&#39;, &#39;0:0:0:0:0:0:0:1&#39;, &#39;0:0:0:0:0:0:0:1&#39;, &#39;2018-05-17 13:08:30&#39;, &#39;13&#39;, null, &#39;1&#39;, &#39;2018-01-02 15:56:34&#39;, &#39;2018-05-17 13:08:30&#39;);-- ------------------------------ Table structure for sys_user_role-- ----------------------------DROP TABLE IF EXISTS `sys_user_role`;CREATE TABLE `sys_user_role`  (  `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT,  `user_id` bigint(20) unsigned NOT NULL COMMENT &#39;用户ID&#39;,  `role_id` bigint(20) unsigned NOT NULL COMMENT &#39;角色ID&#39;,  `create_time` datetime DEFAULT CURRENT_TIMESTAMP COMMENT &#39;添加时间&#39;,  `update_time` datetime DEFAULT CURRENT_TIMESTAMP COMMENT &#39;更新时间&#39;,  PRIMARY KEY (`id`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8 COMMENT = &#39;用户与角色关系表&#39; ROW_FORMAT=COMPACT;INSERT INTO `sys_user_role` VALUES (&#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;2018-01-02 10:47:27&#39;, &#39;2018-01-02 10:47:27&#39;);INSERT INTO `sys_user_role` VALUES (&#39;2&#39;, &#39;2&#39;, &#39;2&#39;, &#39;2018-01-05 18:21:02&#39;, &#39;2018-01-05 18:21:02&#39;);</code></pre><h3 id="entity，mapper，service，serviceImpl"><a href="#entity，mapper，service，serviceImpl" class="headerlink" title="entity，mapper，service，serviceImpl"></a>entity，mapper，service，serviceImpl</h3><p>这些类直接根据mybatis-plus-generator生成即可。mybatis-plus-generator也有对应的文章源码可直接使用。<br>不想用代码生成器我的源码也有提供。这里附录一下主要方法。<br>没有在这里写出的，说明只是用mybatis-plus自带的查询就可以。mybatis-plus QueryWrapper不能使用外联。<br>用到的手写SQL：<br><strong><em>menu</em></strong></p><pre><code class="java">List&lt;SysMenu&gt; listByUserId(Integer userId);MenuMapper.xml&lt;!--查询用户权限--&gt;&lt;select id=&quot;listByUserId&quot; parameterType=&quot;Integer&quot; resultMap=&quot;BaseResultMap&quot;&gt;    SELECT        re.id,        re.`name`,        re.parent_id,        re.url,        re.permission,        re.icon,        re.sort    FROM        sys_menu re    INNER JOIN sys_role_menu rr ON re.id = rr.menu_id    INNER JOIN sys_user_role ur ON rr.role_id = ur.role_id    WHERE        ur.user_id = #{userId}    AND re.available = 1    ORDER BY        re.parent_id ASC,        re.sort ASC&lt;/select&gt;</code></pre><p><strong><em>role</em></strong></p><pre><code class="java">List&lt;SysRole&gt; listRolesByUserId(Integer userId);&lt;!--查询用户角色--&gt;&lt;select id=&quot;listRolesByUserId&quot; parameterType=&quot;Integer&quot; resultMap=&quot;BaseResultMap&quot;&gt;    SELECT        r.id,        r.name,        r.description    FROM        sys_role r    INNER JOIN sys_user_role ur ON ur.role_id = r.id    WHERE        ur.user_id = #{userId}    AND r.available = 1&lt;/select&gt;</code></pre><h3 id="LoginController"><a href="#LoginController" class="headerlink" title="LoginController"></a>LoginController</h3><pre><code class="java">package com.blackcat.shiro.controller;import com.blackcat.shiro.entity.SysUser;import org.apache.shiro.SecurityUtils;import org.apache.shiro.authc.UsernamePasswordToken;import org.apache.shiro.authz.annotation.RequiresAuthentication;import org.apache.shiro.subject.Subject;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.ResponseBody;import javax.servlet.http.HttpSession;/** * &lt;p&gt; 描述 ： * * @author : blackcat * @date : 2020/2/3 11:14 */@Controllerpublic class LoginController {    /**     * 跳转到login页面     * @return     */    @RequestMapping(value = &quot;/login&quot;,method = RequestMethod.GET)    public String login(Model model) {        Subject subject = SecurityUtils.getSubject();        SysUser user=(SysUser) subject.getPrincipal();        if (user == null){            return &quot;login&quot;;        }else{            return &quot;redirect:index&quot;;        }    }    /**     * &lt;p&gt; 描述 : 用户登录     * @author : blackcat     * @date  : 2020/2/3 17:04     */    @RequestMapping(value = &quot;/login&quot;,method = RequestMethod.POST)    @ResponseBody    public String loginUser(String username, String password, boolean rememberMe) {        UsernamePasswordToken token = new UsernamePasswordToken(username, password, rememberMe);        //获取当前的Subject        Subject currentUser = SecurityUtils.getSubject();        try {            // 在调用了login方法后,SecurityManager会收到AuthenticationToken,并将其发送给已配置的Realm执行必须的认证检查            // 每个Realm都能在必要时对提交的AuthenticationTokens作出反应            // 所以这一步在调用login(token)方法时,它会走到xxRealm.doGetAuthenticationInfo()方法中,具体验证方式详见此方法            currentUser.login(token);            return &quot;登录成功！&quot;;        } catch (Exception e) {            token.clear();            return &quot;登录失败&quot;;        }    }    /**     * &lt;p&gt; 描述 : 访问项目根路径     * @author : blackcat     * @date  : 2020/2/3 17:02     */    @RequiresAuthentication    @GetMapping(value = {&quot;&quot;, &quot;/index&quot;})    public String home() {        Subject subject = SecurityUtils.getSubject();        SysUser user=(SysUser) subject.getPrincipal();        if (user == null){            return &quot;login&quot;;        }else{            return &quot;index&quot;;        }    }    /**     * 登出  这个方法没用到,用的是shiro默认的logout     * @param session     * @param model     * @return     */    @RequestMapping(&quot;/logout&quot;)    public String logout(HttpSession session, Model model) {        model.addAttribute(&quot;msg&quot;,&quot;安全退出！&quot;);        return &quot;login&quot;;    }    /**     * 跳转到无权限页面     * @param session     * @param model     * @return     */    @RequestMapping(&quot;/unauthorized&quot;)    public String unauthorized(HttpSession session, Model model) {        return &quot;unauthorized&quot;;    }}</code></pre><h3 id="ShiroConfig"><a href="#ShiroConfig" class="headerlink" title="ShiroConfig"></a>ShiroConfig</h3><pre><code class="java">package com.blackcat.shiro.config;import org.apache.shiro.mgt.SecurityManager;import org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor;import org.apache.shiro.spring.web.ShiroFilterFactoryBean;import org.apache.shiro.web.mgt.DefaultWebSecurityManager;import org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.beans.factory.config.MethodInvokingFactoryBean;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.handler.SimpleMappingExceptionResolver;import java.util.LinkedHashMap;import java.util.Properties;/** * &lt;p&gt; 描述 ：Shiro配置 * @author : blackcat * @date : 2020/2/3 10:53 */@Configurationpublic class ShiroConfig {    /**     * 解决： 无权限页面不跳转 shiroFilterFactoryBean.setUnauthorizedUrl(&quot;/unauthorized&quot;) 无效     * shiro的源代码ShiroFilterFactoryBean.Java定义的filter必须满足filter instanceof AuthorizationFilter，     * 只有perms，roles，ssl，rest，port才是属于AuthorizationFilter，而anon，authcBasic，auchc，user是AuthenticationFilter，     * 所以unauthorizedUrl设置后页面不跳转 Shiro注解模式下，登录失败与没有权限都是通过抛出异常。     * 并且默认并没有去处理或者捕获这些异常。在SpringMVC下需要配置捕获相应异常来通知用户信息     * @return     */    @Bean    public SimpleMappingExceptionResolver simpleMappingExceptionResolver() {        SimpleMappingExceptionResolver simpleMappingExceptionResolver=new SimpleMappingExceptionResolver();        Properties properties=new Properties();        //这里的 /unauthorized 是页面，不是访问的路径        properties.setProperty(&quot;org.apache.shiro.authz.UnauthorizedException&quot;,&quot;/unauthorized&quot;);        properties.setProperty(&quot;org.apache.shiro.authz.UnauthenticatedException&quot;,&quot;/unauthorized&quot;);        simpleMappingExceptionResolver.setExceptionMappings(properties);        return simpleMappingExceptionResolver;    }    @Bean    public MethodInvokingFactoryBean methodInvokingFactoryBean(SecurityManager securityManager){        MethodInvokingFactoryBean bean = new MethodInvokingFactoryBean();        bean.setStaticMethod(&quot;org.apache.shiro.SecurityUtils.setSecurityManager&quot;);        bean.setArguments(securityManager);        return bean;    }    /**     * ShiroFilterFactoryBean 处理拦截资源文件问题。     * 注意：初始化ShiroFilterFactoryBean的时候需要注入：SecurityManager     * Web应用中,Shiro可控制的Web请求必须经过Shiro主过滤器的拦截     * @param securityManager     * @return     */    @Bean(name = &quot;shirFilter&quot;)    public ShiroFilterFactoryBean shiroFilter(@Qualifier(&quot;securityManager&quot;) SecurityManager securityManager) {        ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean();        //必须设置 SecurityManager,Shiro的核心安全接口        shiroFilterFactoryBean.setSecurityManager(securityManager);        //这里的/login是后台的接口名,非页面，如果不设置默认会自动寻找Web工程根目录下的&quot;/login.jsp&quot;页面        shiroFilterFactoryBean.setLoginUrl(&quot;/login&quot;);        //这里的/index是后台的接口名,非页面,登录成功后要跳转的链接        shiroFilterFactoryBean.setSuccessUrl(&quot;/index&quot;);        //未授权界面,该配置无效，并不会进行页面跳转        shiroFilterFactoryBean.setUnauthorizedUrl(&quot;/unauthorized&quot;);        //自定义拦截器限制并发人数,参考博客：        //LinkedHashMap&lt;String, Filter&gt; filtersMap = new LinkedHashMap&lt;&gt;();        //限制同一帐号同时在线的个数        //filtersMap.put(&quot;kickout&quot;, kickoutSessionControlFilter());        //shiroFilterFactoryBean.setFilters(filtersMap);        // 配置访问权限 必须是LinkedHashMap，因为它必须保证有序        // 过滤链定义，从上向下顺序执行，一般将 /**放在最为下边 一定要注意顺序,否则就不好使了        LinkedHashMap&lt;String, String&gt; filterChainDefinitionMap = new LinkedHashMap&lt;&gt;();        //配置不登录可以访问的资源，anon 表示资源都可以匿名访问        filterChainDefinitionMap.put(&quot;/login&quot;, &quot;anon&quot;);        //filterChainDefinitionMap.put(&quot;/&quot;, &quot;anon&quot;);        filterChainDefinitionMap.put(&quot;/bootstrap/**&quot;, &quot;anon&quot;);        filterChainDefinitionMap.put(&quot;/ztree/**&quot;, &quot;anon&quot;);        filterChainDefinitionMap.put(&quot;/jquery/**&quot;, &quot;anon&quot;);        filterChainDefinitionMap.put(&quot;/css/**&quot;, &quot;anon&quot;);        filterChainDefinitionMap.put(&quot;/js/**&quot;, &quot;anon&quot;);        filterChainDefinitionMap.put(&quot;/images/**&quot;, &quot;anon&quot;);        filterChainDefinitionMap.put(&quot;/druid/**&quot;, &quot;anon&quot;);        //logout是shiro提供的过滤器        filterChainDefinitionMap.put(&quot;/logout&quot;, &quot;logout&quot;);        //此时访问/userInfo/del需要del权限,在自定义Realm中为用户授权。        //filterChainDefinitionMap.put(&quot;/userInfo/del&quot;, &quot;perms[\&quot;userInfo:del\&quot;]&quot;);        //其他资源都需要认证  authc 表示需要认证才能进行访问        filterChainDefinitionMap.put(&quot;/**&quot;, &quot;user&quot;);        shiroFilterFactoryBean.setFilterChainDefinitionMap(filterChainDefinitionMap);        return shiroFilterFactoryBean;    }    /**     * 配置核心安全事务管理器     * @param shiroRealm     * @return     */    @Bean(name=&quot;securityManager&quot;)    public SecurityManager securityManager(@Qualifier(&quot;shiroRealm&quot;) ShiroRealm shiroRealm) {        DefaultWebSecurityManager securityManager =  new DefaultWebSecurityManager();        //设置自定义realm.        securityManager.setRealm(shiroRealm);        return securityManager;    }    /**     *  身份认证realm; (这个需要自己写，账号密码校验；权限等)     * @return     */    @Bean    public ShiroRealm shiroRealm(){        ShiroRealm shiroRealm = new ShiroRealm();        return shiroRealm;    }    /**     * &lt;p&gt; 描述 : 开启Shiro的注解(如@RequiresRoles,@RequiresPermissions),需借助SpringAOP扫描使用Shiro注解的类,并在必要时进行安全逻辑验证     *  配置以下两个bean(DefaultAdvisorAutoProxyCreator和AuthorizationAttributeSourceAdvisor)即可实现此功能     * @author : blackcat     * @date  : 2020/2/3 16:59     */    @Bean    public DefaultAdvisorAutoProxyCreator advisorAutoProxyCreator(){        DefaultAdvisorAutoProxyCreator advisorAutoProxyCreator = new DefaultAdvisorAutoProxyCreator();        advisorAutoProxyCreator.setProxyTargetClass(true);        return advisorAutoProxyCreator;    }    /**     * &lt;p&gt; 描述 : 开启shiro aop注解支持.     * 可以在controller中的方法前加上注解 如 @RequiresPermissions(&quot;user:add&quot;)     * @author : blackcat     * @date  : 2020/2/2 10:21     */    @Bean    public AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor(SecurityManager securityManager) {        AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor = new AuthorizationAttributeSourceAdvisor();        authorizationAttributeSourceAdvisor.setSecurityManager(securityManager);        return authorizationAttributeSourceAdvisor;    }}</code></pre><h3 id="ShiroRealm"><a href="#ShiroRealm" class="headerlink" title="ShiroRealm"></a>ShiroRealm</h3><pre><code class="java">package com.blackcat.shiro.config;import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;import com.blackcat.shiro.entity.SysMenu;import com.blackcat.shiro.entity.SysRole;import com.blackcat.shiro.entity.SysUser;import com.blackcat.shiro.service.SysMenuService;import com.blackcat.shiro.service.SysRoleService;import com.blackcat.shiro.service.SysUserService;import org.apache.commons.lang3.StringUtils;import org.apache.shiro.authc.*;import org.apache.shiro.authz.AuthorizationInfo;import org.apache.shiro.authz.SimpleAuthorizationInfo;import org.apache.shiro.realm.AuthorizingRealm;import org.apache.shiro.subject.PrincipalCollection;import javax.annotation.Resource;import java.util.List;/** * &lt;p&gt; 描述 ：身份认证 * @author : blackcat * @date : 2020/2/3 10:54 */public class ShiroRealm extends AuthorizingRealm {    @Resource    private SysUserService sysUserService;    @Resource    private SysRoleService sysRoleService;    @Resource    private SysMenuService sysMenuService;    @Override    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) {        SimpleAuthorizationInfo info = new SimpleAuthorizationInfo();        // 用户信息        SysUser sysUser = (SysUser) principalCollection.getPrimaryPrincipal();        // 赋予角色        List&lt;SysRole&gt; roleList = sysRoleService.listRolesByUserId(sysUser.getId());        roleList.forEach(role -&gt; info.addRole(role.getName()));        // 赋予权限        List&lt;SysMenu&gt; menusList = sysMenuService.listByUserId(sysUser.getId());        menusList.forEach(menu -&gt; {            if (StringUtils.isNotBlank(menu.getPermission())) {                info.addStringPermission(menu.getPermission());            }        });        return info;    }    @Override    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException {        String username = (String) authenticationToken.getPrincipal();        String password = new String((char[]) authenticationToken.getCredentials());        SysUser user = sysUserService.getOne(new QueryWrapper&lt;SysUser&gt;().eq(&quot;username&quot;, username));        //可以在这里直接对用户名校验,或者调用 CredentialsMatcher 校验        if (user == null) {            throw new UnknownAccountException(&quot;用户名或密码错误！&quot;);        }        if (!password.equals(user.getPassword())) {            throw new IncorrectCredentialsException(&quot;用户名或密码错误！&quot;);        }        if (&quot;1&quot;.equals(user.getStatus())) {            throw new LockedAccountException(&quot;账号已被锁定,请联系管理员！&quot;);        }        SimpleAuthenticationInfo info = new SimpleAuthenticationInfo(user,user.getPassword(), getName());        return info;    }}</code></pre><h3 id="application-yml"><a href="#application-yml" class="headerlink" title="application.yml"></a>application.yml</h3><pre><code class="java"># Server settingsserver:    port: 8083    # HTTP请求和响应头的最大量，以字节为单位，默认值为4096字节,超过此长度的部分不予处理,一般8K。解决java.io.EOFException: null问题    max-http-header-size: 8192    # use-forward-headers: true Spring Boot 2.2中的弃用 使用下列参数    forward-headers-strategy: native    compression:        enabled: true        min-response-size: 1024        mime-types: text/plain,text/css,text/xml,text/javascript,application/json,application/javascript,application/xml,application/xml+rss,application/x-javascript,application/x-httpd-php,image/jpeg,image/gif,image/png    tomcat:        remote-ip-header: X-Forwarded-for        protocol-header: X-Forwarded-Proto        port-header: X-Forwarded-Port        uri-encoding: UTF-8        basedir: /var/tmp/website-app    #servlet:        #context-path: /blackcat# SPRING PROFILESspring:    datasource:        type: com.alibaba.druid.pool.DruidDataSource        driver-class-name: com.mysql.cj.jdbc.Driver        url: jdbc:mysql://localhost:3306/blog?useUnicode=true&amp;characterEncoding=utf-8&amp;autoReconnect=true&amp;zeroDateTimeBehavior=convertToNull&amp;allowMultiQueries=true&amp;useSSL=false&amp;serverTimezone=UTC        username: root        password: 111111    application:        name: blog    freemarker:        allow-request-override: false        allow-session-override: false        cache: false #缓存配置        charset: UTF-8 #编码格式        request-context-attribute: request # 访问request名称定义        check-template-location: true        content-type: text/html # 设置Content-Type        enabled: true        expose-request-attributes: false # 设定所有request的属性在merge到模板的时候，是否要都添加到model中        expose-session-attributes: false # 是否在merge模板的时候，将HttpSession属性都添加到model中        expose-spring-macro-helpers: true # 设定是否以springMacroRequestContext的形式暴露RequestContext给Spring’s macro library使用        prefer-file-system-access: true        suffix: .ftl        template-loader-path: classpath:/templates/ #模板加载路径 按需配置        settings:            template_update_delay: 0            default_encoding: UTF-8            classic_compatible: true #解决前台使用${}赋值值为空的情况    # HTTP ENCODING    http:        multipart:            #max-file-size: 2MB            #max-request-size: 10MB        encoding:            enabled: true            charset: UTF-8            force: true    messages:        encoding: UTF-8    jmx:        enabled: true        default-domain: agentservice    resources:        static-locations: classpath:/static/        chain:            strategy:                content:                    enabled: true                    paths: /**    # redis缓存服务配置    session:        store-type: redis    # Redis数据库索引（默认为0）    redis:        database: 1        # Redis服务器地址        host: 127.0.0.1        # Redis服务器连接端口        port: 6379        # Redis服务器连接密码（默认为空）        password: 111111        # 连接池最大连接数（使用负值表示没有限制）        jedis:            pool:                max-active: 1000  # 连接池最大连接数（使用负值表示没有限制）                max-wait: -1      # 连接池最大阻塞等待时间（使用负值表示没有限制）                max-idle: 10      # 连接池中的最大空闲连接                min-idle: 5       # 连接池中的最小空闲连接        # 连接超时时间（毫秒）        timeout: 0        # 默认的数据过期时间，主要用于shiro权限管理        expire: 2592000# MyBatis plusmybatis-plus:    mapper-locations: classpath:/mappers/*.xml    #实体扫描，多个package用逗号或者分号分隔    typeAliasesPackage: com.blackcat.shiro.entity    global-config:        #刷新mapper 调试神器        db-config:            #主键类型  0:&quot;数据库ID自增&quot;, 1:&quot;用户输入ID&quot;,2:&quot;全局唯一ID (数字类型唯一ID)&quot;, 3:&quot;全局唯一ID UUID&quot;;            #idtype: 0            #字段策略 0:&quot;忽略判断&quot;,1:&quot;非 NULL 判断&quot;),2:&quot;非空判断&quot;            field-strategy: not_empty            #驼峰下划线转换            column-underline: true            #数据库大写下划线转换            capitalmode: true            #逻辑删除配置            logic-delete-value: 1            logic-not-delete-value: 0            db-type: mysql        refresh: true        #自定义填充策略接口实现        #metaobjecthandler: com.baomidou.springboot.xxx        #自定义SQL注入器        #sqlinjector: com.baomidou.mybatisplus.extension.injector.LogicSqlInjector        configuration:            # 这个配置会将执行的sql打印出来，在开发或测试的时候可以用            log-impl: org.apache.ibatis.logging.stdout.StdOutImpl            map-underscore-to-camel-case: true            cache-enabled: falsebanner:    #charset: UTF-8</code></pre><h3 id="index-ftl"><a href="#index-ftl" class="headerlink" title="index.ftl"></a>index.ftl</h3><pre><code class="java">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;shiro:hasPermission name=&quot;user:add&quot;&gt;&lt;a href=&quot;/user/add&quot;&gt;点击添加固定用户信息(后台写死,方便测试)&lt;/a&gt;&lt;/shiro:hasPermission&gt;&lt;br/&gt;&lt;shiro:hasPermission name=&quot;user:del&quot;&gt;&lt;a href=&quot;/user/del&quot;&gt;点击删除固定用户信息(后台写死,方便测试)&lt;/a&gt;&lt;/shiro:hasPermission&gt;&lt;br/&gt;&lt;shiro:hasPermission name=&quot;user:view&quot;&gt;&lt;a href=&quot;/user/view&quot;&gt;显示此内容表示拥有查看用户列表的权限&lt;/a&gt;&lt;/shiro:hasPermission&gt;&lt;br/&gt;&lt;!-- 用户没有身份验证时显示相应信息，即游客访问信息 --&gt;&lt;shiro:guest&gt;游客显示的信息&lt;/shiro:guest&gt;&lt;br/&gt;&lt;!-- 用户已经身份验证/记住我登录后显示相应的信息 --&gt;&lt;shiro:user&gt;用户已经登录过了&lt;/shiro:user&gt;&lt;br/&gt;&lt;!-- 用户已经身份验证通过，即Subject.login登录成功，不是记住我登录的 --&gt;&lt;shiro:authenticated&gt;不是记住我登录&lt;/shiro:authenticated&gt;&lt;br/&gt;&lt;!-- 显示用户身份信息，通常为登录帐号信息，默认调用Subject.getPrincipal()获取，即Primary Principal --&gt;&lt;shiro:principal&gt;&lt;/shiro:principal&gt;&lt;br/&gt;&lt;!--用户已经身份验证通过，即没有调用Subject.login进行登录，包括记住我自动登录的也属于未进行身份验证，与guest标签的区别是，该标签包含已记住用户 --&gt;&lt;shiro:notAuthenticated&gt;已记住用户&lt;/shiro:notAuthenticated&gt;&lt;br/&gt;&lt;!-- 相当于Subject.getPrincipals().oneByType(String.class) --&gt;&lt;shiro:principal type=&quot;java.lang.String&quot;/&gt;&lt;br/&gt;&lt;!-- 相当于((User)Subject.getPrincipals()).getUsername() --&gt;&lt;shiro:principal property=&quot;username&quot;/&gt;&lt;br/&gt;&lt;!-- 如果当前Subject有角色将显示body体内容 name=&quot;角色名&quot; --&gt;&lt;shiro:hasRole name=&quot;admin&quot;&gt;这是admin角色&lt;/shiro:hasRole&gt;&lt;br/&gt;&lt;!-- 如果当前Subject有任意一个角色（或的关系）将显示body体内容。 name=&quot;角色名1,角色名2...&quot; --&gt;&lt;shiro:hasAnyRoles name=&quot;admin,vip&quot;&gt;用户拥有admin角色 或者 vip角色&lt;/shiro:hasAnyRoles&gt;&lt;br/&gt;&lt;!-- 如果当前Subject没有角色将显示body体内容 --&gt;&lt;shiro:lacksRole name=&quot;admin&quot;&gt;如果不是admin角色,显示内容&lt;/shiro:lacksRole&gt;&lt;br/&gt;&lt;!-- 如果当前Subject有权限将显示body体内容 name=&quot;权限名&quot; --&gt;&lt;shiro:hasPermission name=&quot;user:add&quot;&gt;用户拥有添加权限&lt;/shiro:hasPermission&gt;&lt;br/&gt;&lt;!-- 用户同时拥有以下两种权限,显示内容 --&gt;&lt;shiro:hasAllPermissions name=&quot;user:add,user:view&quot;&gt;用户同时拥有列表权限和添加权限&lt;/shiro:hasAllPermissions&gt;&lt;br/&gt;&lt;!-- 用户拥有以下权限任意一种 --&gt;&lt;shiro:hasAnyPermissions name=&quot;user:view,user:delete&quot;&gt;用户拥有列表权限或者删除权限&lt;/shiro:hasAnyPermissions&gt;&lt;br/&gt;&lt;!-- 如果当前Subject没有权限将显示body体内容 name=&quot;权限名&quot; --&gt;&lt;shiro:lacksPermission name=&quot;user:add&quot;&gt;如果用户没有添加权限，显示的内容&lt;/shiro:lacksPermission&gt;&lt;br/&gt;&lt;a href=&quot;/logout&quot;&gt;点我注销&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="login-ftl"><a href="#login-ftl" class="headerlink" title="login.ftl"></a>login.ftl</h3><pre><code class="java">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;#assign basePath=request.contextPath /&gt;    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;    &lt;meta charset=&quot;utf-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;    &lt;title&gt;后台管理&lt;/title&gt;    &lt;link href=&quot;${basePath}/images/favicon.ico&quot; rel=&quot;icon&quot;&gt;    &lt;link href=&quot;${basePath}/bootstrap/css/bootstrap.css&quot; rel=&quot;stylesheet&quot;&gt;    &lt;link href=&quot;${basePath}/bootstrap/css/font-awesome.css&quot; rel=&quot;stylesheet&quot;&gt;    &lt;link href=&quot;${basePath}/css/jquery-confirm.min.css&quot; rel=&quot;stylesheet&quot;&gt;    &lt;link href=&quot;${basePath}/css/nprogress2.min.css&quot; rel=&quot;stylesheet&quot;&gt;    &lt;link href=&quot;${basePath}/css/zhyd.core.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;/head&gt;&lt;body class=&quot;login&quot;&gt;&lt;div class=&quot;modal fade&quot; id=&quot;modal&quot; tabindex=&quot;-1&quot; role=&quot;dialog&quot; aria-labelledby=&quot;myModalLabel&quot; aria-hidden=&quot;true&quot; data-backdrop=&quot;static&quot;     data-keyboard=&quot;false&quot;&gt;    &lt;div class=&quot;modal-dialog&quot; role=&quot;document&quot;&gt;        &lt;div class=&quot;modal-content&quot;&gt;            &lt;div class=&quot;modal-body&quot;&gt;                &lt;div class=&quot;login_wrapper&quot;&gt;                    &lt;div class=&quot;animate form login_form&quot; style=&quot;position: relative;&quot;&gt;                        &lt;section class=&quot;login_content&quot;&gt;                            &lt;form action=&quot;/login&quot; method=&quot;POST&quot; id=&quot;login-form&quot;&gt;                                &lt;h1&gt;登录管理系统&lt;/h1&gt;                                &lt;div&gt;                                    &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;请输入用户名&quot; name=&quot;username&quot; required=&quot;&quot;/&gt;                                &lt;/div&gt;                                &lt;div&gt;                                    &lt;input type=&quot;password&quot; class=&quot;form-control&quot; placeholder=&quot;请输入密码&quot; name=&quot;password&quot; required=&quot;&quot;/&gt;                                &lt;/div&gt;                                &lt;div class=&quot;form-group&quot; style=&quot;text-align : left&quot;&gt;                                    &lt;label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;rememberMe&quot; name=&quot;rememberMe&quot; style=&quot;width: 12px; height: 12px;margin-right: 5px;&quot;&gt;记住我&lt;/label&gt;                                &lt;/div&gt;                                &lt;div&gt;                                    &lt;button type=&quot;button&quot; class=&quot;btn btn-success btn-login&quot; style=&quot;width: 100%;&quot;&gt;登录&lt;/button&gt;                                &lt;/div&gt;                                &lt;div class=&quot;clearfix&quot;&gt;&lt;/div&gt;                                &lt;div class=&quot;separator&quot;&gt;                                    &lt;div class=&quot;clearfix&quot;&gt;&lt;/div&gt;                                    &lt;div&gt;                                        &lt;h1&gt;&lt;i class=&quot;fa fa-coffee&quot;&gt;&lt;/i&gt; BlackCat 博客系统&lt;/h1&gt;                                        &lt;p&gt;Copyright © 2019 &lt;a href=&quot;https://www.kylin-blackcat.com&quot;&gt;blackcat&lt;/a&gt;. All Rights Reserved. &lt;/p&gt;                                    &lt;/div&gt;                                &lt;/div&gt;                            &lt;/form&gt;                        &lt;/section&gt;                    &lt;/div&gt;                &lt;/div&gt;            &lt;/div&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src=&quot;${basePath}/jquery/jquery-2.1.4.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;&lt;script src=&quot;${basePath}/js/jquery-confirm.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;&lt;script src=&quot;${basePath}/bootstrap/js/bootstrap.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;&lt;script src=&quot;${basePath}/js/blog-table-tool.js&quot;&gt;&lt;/script&gt;&lt;script&gt;    $(&quot;#modal&quot;).modal(&#39;show&#39;);    $(&quot;.btn-login&quot;).click(function () {        $.ajax({            type: &quot;POST&quot;,            url: &quot;/login&quot;,            data: $(&quot;#login-form&quot;).serialize(),            //dataType: &quot;json&quot;,            success: function (json) {                window.location.href = &quot;/index&quot;;            }        });    });    document.onkeydown = function (event) {        var e = event || window.event || arguments.callee.caller.arguments[0];        if (e &amp;&amp; e.keyCode === 13) {            $(&quot;.btn-login&quot;).click();        }    };&lt;/script&gt;&lt;/html&gt;</code></pre><h3 id="unauthorized-ftl"><a href="#unauthorized-ftl" class="headerlink" title="unauthorized.ftl"></a>unauthorized.ftl</h3><pre><code class="java">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;对不起,您没有权限&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="记住我"><a href="#记住我" class="headerlink" title="记住我"></a>记住我</h2><h3 id="ShiroConfig-添加"><a href="#ShiroConfig-添加" class="headerlink" title="ShiroConfig 添加"></a>ShiroConfig 添加</h3><pre><code class="java">/** * &lt;p&gt; 描述 : 配置核心安全事务管理器 * @author : blackcat * @date  : 2020/2/4 16:37*/@Bean(name=&quot;securityManager&quot;)public SecurityManager securityManager(@Qualifier(&quot;shiroRealm&quot;) ShiroRealm shiroRealm) {    DefaultWebSecurityManager securityManager =  new DefaultWebSecurityManager();    //设置自定义realm.    securityManager.setRealm(shiroRealm);    //配置记住我 (加入此行代码)    securityManager.setRememberMeManager(rememberMeManager());    return securityManager;}加入下方两个方法/** * &lt;p&gt; 描述 : cookie对象;会话Cookie模板 ,默认为: JSESSIONID  * 问题: 与SERVLET容器名冲突,重新定义为sid或rememberMe，自定义 * @author : blackcat * @date  : 2020/2/6 13:25   */@Beanpublic SimpleCookie rememberMeCookie(){    //这个参数是cookie的名称，对应前端的checkbox的name = rememberMe    SimpleCookie simpleCookie = new SimpleCookie(&quot;rememberMe&quot;);    //setcookie的httponly属性如果设为true的话，会增加对xss防护的安全系数。它有以下特点：    //setcookie()的第七个参数    //设为true后，只能通过http访问，javascript无法访问    //防止xss读取cookie    simpleCookie.setHttpOnly(true);    simpleCookie.setPath(&quot;/&quot;);    //&lt;!-- 记住我cookie生效时间30天 ,单位秒;--&gt;    simpleCookie.setMaxAge(2592000);    return simpleCookie;}/** * &lt;p&gt; 描述 : cookie管理对象;记住我功能,rememberMe管理器 * @author : blackcat * @date  : 2020/2/6 13:25   */@Beanpublic CookieRememberMeManager rememberMeManager(){    CookieRememberMeManager cookieRememberMeManager = new CookieRememberMeManager();    cookieRememberMeManager.setCookie(rememberMeCookie());    //rememberMe cookie加密的密钥 建议每个项目都不一样 默认AES算法 密钥长度(128 256 512 位)    cookieRememberMeManager.setCipherKey(Base64.decode(&quot;4AvVhmFLUs0KTA3Kprsdag==&quot;));    return cookieRememberMeManager;}</code></pre><h3 id="修改访问首页访问权限"><a href="#修改访问首页访问权限" class="headerlink" title="修改访问首页访问权限"></a>修改访问首页访问权限</h3><p>如果使用@RequiresAuthentication该注释，记住我登陆关闭浏览器，重新访问项目，主页会显示无权限。<br>@RequiresUser：验证用户是否被记忆。</p><pre><code class="java">/** * &lt;p&gt; 描述 : 访问项目根路径 * @author : blackcat * @date  : 2020/2/3 17:02 */@RequiresUser@GetMapping(value = {&quot;&quot;, &quot;/index&quot;})public String home() {    Subject subject = SecurityUtils.getSubject();    SysUser user=(SysUser) subject.getPrincipal();    if (user == null){        return &quot;login&quot;;    }else{        return &quot;index&quot;;    }}</code></pre><h2 id="配置redis缓存管理器"><a href="#配置redis缓存管理器" class="headerlink" title="配置redis缓存管理器"></a>配置redis缓存管理器</h2><h3 id="Redis配置文件"><a href="#Redis配置文件" class="headerlink" title="Redis配置文件"></a>Redis配置文件</h3><pre><code class="java">package com.blackcat.blog.common.config;import com.fasterxml.jackson.annotation.JsonAutoDetect;import com.fasterxml.jackson.annotation.PropertyAccessor;import com.fasterxml.jackson.databind.ObjectMapper;import org.springframework.cache.CacheManager;import org.springframework.cache.annotation.CachingConfigurerSupport;import org.springframework.cache.annotation.EnableCaching;import org.springframework.cache.interceptor.KeyGenerator;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.data.redis.cache.RedisCacheConfiguration;import org.springframework.data.redis.cache.RedisCacheManager;import org.springframework.data.redis.cache.RedisCacheWriter;import org.springframework.data.redis.connection.RedisConnectionFactory;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;import org.springframework.data.redis.serializer.StringRedisSerializer;import java.lang.reflect.Method;import java.time.Duration;/** * &lt;p&gt; 描述 : Redis配置文件 * @author : blackcat * @date  : 2020/2/8 15:58*/@Configuration@EnableCachingpublic class RedisConfig extends CachingConfigurerSupport {    /**     * 缓存数据时Key的生成器，可以依据业务和技术场景自行定制     *     * @return     */    @Bean    @Override    @Deprecated    public KeyGenerator keyGenerator() {        return new KeyGenerator() {            @Override            public Object generate(Object target, Method method, Object... params) {                StringBuilder sb = new StringBuilder();                sb.append(target.getClass().getName());                sb.append(method.getName());                for (Object obj : params) {                    sb.append(obj.toString());                }                return sb.toString();            }        };    }    /**     * &lt;p&gt; 描述 : 管理缓存     * @author : blackcat     * @date  : 2020/2/8 16:00     * 注：在springboot2.x中，RedisCacheManager已经没有了单参数的构造方法    */    @SuppressWarnings(&quot;rawtypes&quot;)    @Bean    public CacheManager cacheManager(RedisConnectionFactory redisConnectionFactory) {        RedisCacheConfiguration redisCacheConfiguration = RedisCacheConfiguration.defaultCacheConfig()                .entryTtl(Duration.ofHours(1)); // 设置缓存有效期一小时        return RedisCacheManager                .builder(RedisCacheWriter.nonLockingRedisCacheWriter(redisConnectionFactory))                .cacheDefaults(redisCacheConfiguration).build();    }    /**     * &lt;p&gt; 描述 : RedisTemplate配置     * @author : blackcat     * @date  : 2020/2/8 16:00    */    @Bean    @SuppressWarnings({&quot;rawtypes&quot;, &quot;unchecked&quot;})    public RedisTemplate&lt;Object,Object&gt; redisTemplate(RedisConnectionFactory connectionFactory){        RedisTemplate&lt;Object,Object&gt; redisTemplate=new RedisTemplate&lt;&gt;();        redisTemplate.setConnectionFactory(connectionFactory);        //使用Jackson2JsonRedisSerializer替换默认的序列化规则        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer=new Jackson2JsonRedisSerializer(Object.class);        ObjectMapper objectMapper=new ObjectMapper();        objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);        objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);        jackson2JsonRedisSerializer.setObjectMapper(objectMapper);        //设置value的序列化规则        redisTemplate.setValueSerializer(jackson2JsonRedisSerializer);        //设置key的序列化规则        redisTemplate.setKeySerializer(new StringRedisSerializer());        redisTemplate.afterPropertiesSet();        return redisTemplate;    }}</code></pre><h3 id="redis属性配置文件"><a href="#redis属性配置文件" class="headerlink" title="redis属性配置文件"></a>redis属性配置文件</h3><pre><code class="java">package com.blackcat.blog.common.property;import lombok.Data;import lombok.EqualsAndHashCode;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.context.annotation.PropertySource;import org.springframework.core.annotation.Order;import org.springframework.stereotype.Component;/** * &lt;p&gt; 描述 : redis属性配置文件 * @author : blackcat * @date  : 2020/2/2 11:36*/@Component@PropertySource(&quot;classpath:application.yml&quot;)@ConfigurationProperties(prefix = &quot;spring.redis&quot;)@Data@EqualsAndHashCode(callSuper = false)@Order(-1)public class RedisProperties {    private Integer database;    private String host;    private Integer port;    private String password;    private Integer timeout;    /**     * 默认30天 = 2592000s     */    private Integer expire = 2592000;}</code></pre><h3 id="ShiroConfig-配置"><a href="#ShiroConfig-配置" class="headerlink" title="ShiroConfig 配置"></a>ShiroConfig 配置</h3><p>添加以下方法</p><pre><code class="java">/** * cacheManager 缓存 redis实现 * 使用的是shiro-redis开源插件 * * @return */@Beanpublic RedisCacheManager redisCacheManager() {    RedisCacheManager redisCacheManager = new RedisCacheManager();    redisCacheManager.setRedisManager(redisManager());    return redisCacheManager;}/** * 配置shiro redisManager * 使用的是shiro-redis开源插件 * * @return */public RedisManager redisManager() {    RedisManager redisManager = new RedisManager();    redisManager.setHost(redisProperties.getHost());    redisManager.setPort(redisProperties.getPort());    redisManager.setDatabase(redisProperties.getDatabase());    redisManager.setTimeout(redisProperties.getTimeout());    redisManager.setPassword(redisProperties.getPassword());    return redisManager;}/** * RedisSessionDAO shiro sessionDao层的实现 通过redis * 使用的是shiro-redis开源插件 *///    @Beanpublic RedisSessionDAO redisSessionDAO() {    RedisSessionDAO redisSessionDAO = new RedisSessionDAO();    redisSessionDAO.setRedisManager(redisManager());    return redisSessionDAO;}/** * shiro session的管理 */@Beanpublic DefaultWebSessionManager sessionManager() {    DefaultWebSessionManager sessionManager = new DefaultWebSessionManager();    sessionManager.setGlobalSessionTimeout(redisProperties.getExpire() * 1000L);    sessionManager.setSessionDAO(redisSessionDAO());    return sessionManager;}/** * cookie对象; * * @return */public SimpleCookie rememberMeCookie() {    // 这个参数是cookie的名称，对应前端的checkbox的name = rememberMe    SimpleCookie simpleCookie = new SimpleCookie(&quot;rememberMe&quot;);    // 记住我cookie生效时间30天 ,单位秒。 注释掉，默认永久不过期    simpleCookie.setMaxAge(redisProperties.getExpire());    //setcookie的httponly属性如果设为true的话，会增加对xss防护的安全系数。它有以下特点：    //设为true后，只能通过http访问，javascript无法访问    //防止xss读取cookie    simpleCookie.setHttpOnly(true);    simpleCookie.setPath(&quot;/&quot;);    return simpleCookie;}</code></pre><h3 id="Redis-command-timed-out-nested-exception-is-io-lettuce-core-RedisCommandTimeoutException-Command-timed-out-after-no-timeout"><a href="#Redis-command-timed-out-nested-exception-is-io-lettuce-core-RedisCommandTimeoutException-Command-timed-out-after-no-timeout" class="headerlink" title="Redis command timed out; nested exception is io.lettuce.core.RedisCommandTimeoutException: Command timed out after no timeout"></a>Redis command timed out; nested exception is io.lettuce.core.RedisCommandTimeoutException: Command timed out after no timeout</h3><p>错误原因：连接超时时间设置的过于短暂  我在配置文件中设置了0<br>解决：将<code>spring.redis.timeout</code>值修改成几秒左右差不多 改值单位为毫秒</p><h2 id="密码加密及登录次数验证"><a href="#密码加密及登录次数验证" class="headerlink" title="密码加密及登录次数验证"></a>密码加密及登录次数验证</h2><h3 id="Shiro-密码凭证匹配器"><a href="#Shiro-密码凭证匹配器" class="headerlink" title="Shiro-密码凭证匹配器"></a>Shiro-密码凭证匹配器</h3><pre><code class="java">package com.blackcat.blog.common.shiro.credentials;import com.blackcat.blog.util.PasswordUtil;import org.apache.shiro.authc.AuthenticationInfo;import org.apache.shiro.authc.AuthenticationToken;import org.apache.shiro.authc.UsernamePasswordToken;import org.apache.shiro.authc.credential.SimpleCredentialsMatcher;/** * &lt;p&gt; 描述 : Shiro-密码凭证匹配器 * @author : blackcat * @date  : 2020/2/14 11:20*/public class CredentialsMatcher extends SimpleCredentialsMatcher {    @Override    public boolean doCredentialsMatch(AuthenticationToken token, AuthenticationInfo info) {        UsernamePasswordToken utoken = (UsernamePasswordToken) token;        //获得用户输入的密码:(可以采用加盐(salt)的方式去检验)        String inPassword = new String(utoken.getPassword());        //获得数据库中的密码        String dbPassword = (String) info.getCredentials();        try {            dbPassword = PasswordUtil.decrypt(dbPassword, utoken.getUsername());        } catch (Exception e) {            e.printStackTrace();            return false;        }        //进行密码的比对        return this.equals(inPassword, dbPassword);    }}</code></pre><h3 id="Shiro-密码输入错误的状态下重试次数的匹配管理"><a href="#Shiro-密码输入错误的状态下重试次数的匹配管理" class="headerlink" title="Shiro-密码输入错误的状态下重试次数的匹配管理"></a>Shiro-密码输入错误的状态下重试次数的匹配管理</h3><pre><code class="java">package com.blackcat.blog.common.shiro.credentials;import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;import com.baomidou.mybatisplus.core.conditions.update.UpdateWrapper;import com.blackcat.blog.common.holder.RequestHolder;import com.blackcat.blog.core.entity.SysUser;import com.blackcat.blog.core.service.SysUserService;import com.blackcat.blog.util.IpUtil;import org.apache.shiro.SecurityUtils;import org.apache.shiro.authc.AccountException;import org.apache.shiro.authc.AuthenticationInfo;import org.apache.shiro.authc.AuthenticationToken;import org.apache.shiro.authc.ExcessiveAttemptsException;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.core.ValueOperations;import java.time.LocalDateTime;import java.util.concurrent.TimeUnit;/** * &lt;p&gt; 描述 : Shiro-密码输入错误的状态下重试次数的匹配管理 * @author : blackcat * @date  : 2020/2/14 11:26*/public class RetryLimitCredentialsMatcher extends CredentialsMatcher {    public static final String USER_SESSION_KEY = &quot;user&quot;;    /**     * 用户登录次数计数  redisKey 前缀     */    private static final String SHIRO_LOGIN_COUNT = &quot;shiro_login_count_&quot;;    /**     * 用户登录是否被锁定    一小时 redisKey 前缀     */    private static final String SHIRO_IS_LOCK = &quot;shiro_is_lock_&quot;;    @Autowired    private RedisTemplate redisTemplate;    @Autowired    private SysUserService userService;    @Override    public boolean doCredentialsMatch(AuthenticationToken token, AuthenticationInfo info) {        SysUser shiroUser = (SysUser) info.getPrincipals().getPrimaryPrincipal();        SysUser user = userService.getOne(new QueryWrapper&lt;SysUser&gt;().eq(&quot;id&quot;,shiroUser.getId()));        String username = user.getUsername();        // 访问一次，计数一次        ValueOperations&lt;String, String&gt; opsForValue = redisTemplate.opsForValue();        String loginCountKey = SHIRO_LOGIN_COUNT + username;        String isLockKey = SHIRO_IS_LOCK + username;        opsForValue.increment(loginCountKey, 1);        if (redisTemplate.hasKey(isLockKey)) {            throw new ExcessiveAttemptsException(&quot;帐号[&quot; + username + &quot;]已被禁止登录！&quot;);        }        // 计数大于5时，设置用户被锁定一小时        String loginCount = String.valueOf(opsForValue.get(loginCountKey));        int retryCount = (5 - Integer.parseInt(loginCount));        if (retryCount &lt;= 0) {            opsForValue.set(isLockKey, &quot;LOCK&quot;);            redisTemplate.expire(isLockKey, 1, TimeUnit.HOURS);            redisTemplate.expire(loginCountKey, 1, TimeUnit.HOURS);            throw new ExcessiveAttemptsException(&quot;由于密码输入错误次数过多，帐号[&quot; + username + &quot;]已被禁止登录！&quot;);        }        boolean matches = super.doCredentialsMatch(token, info);        if (!matches) {            String msg = retryCount &lt;= 0 ? &quot;您的账号一小时内禁止登录！&quot; : &quot;您还剩&quot; + retryCount + &quot;次重试的机会&quot;;            throw new AccountException(&quot;帐号或密码不正确！&quot; + msg);        }        //清空登录计数        redisTemplate.delete(loginCountKey);        try {            SysUser sysUser= new SysUser();            sysUser.setLastLoginIp(IpUtil.getRealIp(RequestHolder.getRequest()));            sysUser.setLastLoginTime(LocalDateTime.now());            sysUser.setLoginCount(user.getLoginCount() + 1);            userService.update(user, new UpdateWrapper&lt;SysUser&gt;().eq(&quot;id&quot;, user.getId()));        } catch (Exception e) {            e.printStackTrace();        }        // 当验证都通过后，把用户信息放在session里        // 注：User必须实现序列化        SecurityUtils.getSubject().getSession().setAttribute(USER_SESSION_KEY, user);        return true;    }}</code></pre><h3 id="ShiroRealm-身份认证修改"><a href="#ShiroRealm-身份认证修改" class="headerlink" title="ShiroRealm 身份认证修改"></a>ShiroRealm 身份认证修改</h3><pre><code class="java">/** * &lt;p&gt; 描述 : 身份认证 * @author : blackcat * @date  : 2020/2/1 12:32 * @return org.apache.shiro.authc.AuthenticationInfo*/@Overrideprotected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException {    String username = (String) authenticationToken.getPrincipal();    String userPwd = new String((char[]) authenticationToken.getCredentials());    // 可以根据实际情况做缓存,如果不做,Shiro自己也是有时间间隔机制,2分钟内不会重复执行该方法    SysUser user = sysUserService.getOne(new QueryWrapper&lt;SysUser&gt;().eq(&quot;username&quot;, username));    if (user == null) {        throw new UnknownAccountException(&quot;账号不存在！&quot;);    }    if (user.getStatus() != null &amp;&amp; 0==user.getStatus()) {        throw new LockedAccountException(&quot;帐号已被锁定，禁止登录！&quot;);    }    // principal参数使用用户Id，方便动态刷新用户权限    return new SimpleAuthenticationInfo(            user,            user.getPassword(),            ByteSource.Util.bytes(username),            getName()    );}</code></pre><h3 id="Shiro-配置修改"><a href="#Shiro-配置修改" class="headerlink" title="Shiro 配置修改"></a>Shiro 配置修改</h3><pre><code class="java">/** * &lt;p&gt; 描述 : 身份认证realm * @author : blackcat * @date  : 2020/2/4 16:37*/@Beanpublic ShiroRealm shiroRealm(){    ShiroRealm shiroRealm = new ShiroRealm();    // 使用加密凭证    shiroRealm.setCredentialsMatcher(credentialsMatcher());    return shiroRealm;}</code></pre><h3 id="修改数据库密码"><a href="#修改数据库密码" class="headerlink" title="修改数据库密码"></a>修改数据库密码</h3><p>只是修改代码没有修改数据库的密码会报：Input length must be multiple of 16 when decrypting with padded cipher<br><strong><em>root</em></strong>:CGUx1FN++xS+4wNDFeN6DA==<br><strong><em>admin</em></strong>:gXp2EbyZ+sB/A6QUMhiUJQ==</p><h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><p>用户：root  密码：123456<br>用户：admin  密码：123456<br>访问：<a href="http://localhost:8083/login" target="_blank" rel="noopener">http://localhost:8083/login</a><br>源码：<br><a href="https://github.com/kylin-lawliet/blackcat-blog-web/tree/master/demo-shiro" target="_blank" rel="noopener">https://github.com/kylin-lawliet/blackcat-blog-web/tree/master/demo-shiro</a> 简单demo 无相关实体类数据库<br><a href="https://github.com/kylin-lawliet/blackcat-blog-web/tree/master/demo-shiro2" target="_blank" rel="noopener">https://github.com/kylin-lawliet/blackcat-blog-web/tree/master/demo-shiro2</a> 实现登陆跳转主页 附数据库</p><h2 id="相关注解"><a href="#相关注解" class="headerlink" title="相关注解"></a>相关注解</h2><h3 id="RequiresAuthentication"><a href="#RequiresAuthentication" class="headerlink" title="@RequiresAuthentication"></a><strong><em>@RequiresAuthentication</em></strong></h3><p>　　验证用户是否登录，等同于方法subject.isAuthenticated() 结果为true时。</p><h3 id="RequiresUser"><a href="#RequiresUser" class="headerlink" title="@RequiresUser"></a><strong><em>@RequiresUser</em></strong></h3><p>　　验证用户是否被记忆，user有两种含义：<br>　　一种是成功登录的（subject.isAuthenticated() 结果为true）；<br>　　另外一种是被记忆的（subject.isRemembered()结果为true）。</p><h3 id="RequiresGuest"><a href="#RequiresGuest" class="headerlink" title="@RequiresGuest"></a><strong><em>@RequiresGuest</em></strong></h3><p>　　验证是否是一个guest的请求，与@RequiresUser完全相反。<br> 　　换言之，RequiresUser  == !RequiresGuest。<br>　　此时subject.getPrincipal() 结果为null.</p><h3 id="RequiresRoles"><a href="#RequiresRoles" class="headerlink" title="@RequiresRoles"></a><strong><em>@RequiresRoles</em></strong></h3><p>　　例如：@RequiresRoles(“aRoleName”);<br> 　　void someMethod();<br>　　如果subject中有aRoleName角色才可以访问方法someMethod。如果没有这个权限则会抛出异常AuthorizationException。</p><h3 id="RequiresPermissions"><a href="#RequiresPermissions" class="headerlink" title="@RequiresPermissions"></a><strong><em>@RequiresPermissions</em></strong></h3><p>　　例如： @RequiresPermissions({“file:read”, “write:aFile.txt”} )<br> 　　void someMethod();<br>　　要求subject中必须同时含有file:read和write:aFile.txt的权限才能执行方法someMethod()。否则抛出异常AuthorizationException。</p><h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><p><a href="http://shiro.apache.org/documentation.html" target="_blank" rel="noopener">Shiro官方文档</a><br><a href="https://blog.csdn.net/qq_34021712/category_9278670.html" target="_blank" rel="noopener">Shiro 学习博客系列 SpringBoot</a><br><a href="https://www.iteye.com/blog/jinnianshilongnian-2018398" target="_blank" rel="noopener">Shiro 学习博客系列 spring</a><br><a href="https://blog.csdn.net/bicheng4769/article/details/86668209" target="_blank" rel="noopener">SpringBoot2.0 集成Shiro 基础版</a><br><a href="https://juejin.im/post/5d087d605188256de9779e64" target="_blank" rel="noopener">SpringBoot 整合Shiro实现动态权限加载更新+Session共享+单点登录 有源码</a><br><a href="https://www.jianshu.com/p/b919c0dded5a" target="_blank" rel="noopener">Springboot+shiro权限管理系统 有源码</a><br><a href="https://gitee.com/xiaobingby/bing-upms" target="_blank" rel="noopener">Spring Boot + Mybatis-Plus + Apache Shiro + FreeMarker 制作的通用权限管理</a><br><a href="http://vblog.chacode.cn/#/" target="_blank" rel="noopener">springboot2.0、mybatis-plus、shiro技术栈开发的vblog博客</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Shiro </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shiro </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM回收与调优</title>
      <link href="/2020/01/24/jvm-tuning/"/>
      <url>/2020/01/24/jvm-tuning/</url>
      
        <content type="html"><![CDATA[<p>JVM调优相关整理。<br>部分是我学习过程整理的笔记。<br>部分是从看过一些文章整理的。<br>应该很明显能分辨出来。</p><a id="more"></a><p><strong>分代说明</strong></p><ul><li><strong><em>年轻代空间（Young Generation）</em></strong> GC日志中的<code>PSYoungGen</code>（PS是指Parallel Scavenge）为Eden+FromSpace，而整个YoungGeneration为Eden+FromSpace+ToSpace。</li><li><strong><em>老年代空间（Old Generation）</em></strong> <code>ParOldGen</code>表示gc回收前后老年代的内存变化</li><li><strong><em>元空间（Metaspace）</em></strong> 主要用于存储类的信息、常量池、方法数据、方法代码等。元空间的本质和永久代类似，都是对JVM规范中方法区的实现。<br>不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。</li></ul><p>JDK1.8以前的HotSpot JVM有方法区，也叫<strong><em>永久代(permanent generation)</em></strong>。<br>JDK1.7开始了方法区的部分移除：符号引用<code>(Symbols)</code>移至<code>native heap</code>，字面量<code>(interned strings)</code>和静态变量<code>(class statics)</code>移至<code>java heap</code>。</p><p><strong>GC说明</strong></p><ul><li><strong><em>新生代GC（Minor GC）</em></strong>:指发生新生代的的垃圾收集动作，Minor GC非常频繁，回收速度一般也比较快。</li><li><strong><em>老年代GC（Major GC/Full GC）</em></strong>:指发生在老年代的GC，出现了Major GC经常会伴随至少一次的Minor GC（并非绝对），Major GC的速度一般会比Minor GC的慢10倍以上。</li></ul><p>从不同的的角度去划分垃圾回收算法</p><p><strong>按照基本回收策略分</strong></p><ul><li>引用计数（Reference Counting）</li><li>标记-清除（Mark-Sweep）</li><li>复制（Copying）</li><li>标记-整理（Mark-Compact）</li></ul><p><strong>按分区对待的方式分</strong></p><ul><li>增量收集（Incremental Collecting）</li><li>分代收集（Generational Collecting）</li></ul><p><strong>按系统线程分</strong></p><ul><li>串行收集（Serial）</li><li>并行收集（Parallel）</li><li>并发收（Concurrent）</li></ul><h2 id="一些统计信息参数"><a href="#一些统计信息参数" class="headerlink" title="一些统计信息参数"></a>一些统计信息参数</h2><p><img src="/img/jvm/2.png" alt="设置参数"></p><h3 id="XX-PrintGCDetails"><a href="#XX-PrintGCDetails" class="headerlink" title="-XX:+PrintGCDetails"></a><strong>-XX:+PrintGCDetails</strong></h3><p>输出详细GC日志模式。<br><img src="/img/jvm/1.png" alt="运行效果"></p><h3 id="XX-PrintTenuringDistribution"><a href="#XX-PrintTenuringDistribution" class="headerlink" title="-XX:+PrintTenuringDistribution"></a><strong>-XX:+PrintTenuringDistribution</strong></h3><p>输出每次minor GC后新的存活周期的阈值。<br><img src="/img/jvm/4.png" alt="运行效果"></p><h3 id="XX-PrintGCTimeStamps"><a href="#XX-PrintGCTimeStamps" class="headerlink" title="-XX:+PrintGCTimeStamps"></a><strong>-XX:+PrintGCTimeStamps</strong></h3><p>输出gc的触发时间<br><img src="/img/jvm/5.png" alt="运行效果"></p><h3 id="XX-PrintGCApplicationConcurrentTime"><a href="#XX-PrintGCApplicationConcurrentTime" class="headerlink" title="-XX:+PrintGCApplicationConcurrentTime"></a><strong>-XX:+PrintGCApplicationConcurrentTime</strong></h3><p>打印每次垃圾回收前，程序未中断的执行时间。<br><img src="/img/jvm/34.png" alt="运行效果"></p><h3 id="XX-PrintGCApplicationStoppedTime"><a href="#XX-PrintGCApplicationStoppedTime" class="headerlink" title="-XX:+PrintGCApplicationStoppedTime"></a><strong>-XX:+PrintGCApplicationStoppedTime</strong></h3><p>打印垃圾回收期间程序暂停的时间。<br><img src="/img/jvm/35.png" alt="运行效果"></p><h3 id="XX-PrintHeapAtGC"><a href="#XX-PrintHeapAtGC" class="headerlink" title="-XX:PrintHeapAtGC"></a><strong>-XX:PrintHeapAtGC</strong></h3><p>打印GC前后的详细堆栈信息。</p><h3 id="Xloggc-filename"><a href="#Xloggc-filename" class="headerlink" title="-Xloggc:filename"></a><strong>-Xloggc:filename</strong></h3><p>将GC日志输出到文件</p><h2 id="Java对象的大小"><a href="#Java对象的大小" class="headerlink" title="Java对象的大小"></a>Java对象的大小</h2><p>基本数据的类型有：<strong><em>byte</em></strong> ,<strong><em>short</em></strong> ,<strong><em>int</em></strong> ,<strong><em>long</em></strong> ,<strong><em>char</em></strong> ,<strong><em>float</em></strong> ,<strong><em>double</em></strong> ,<strong><em>Boolean</em></strong> ,<strong><em>returnAddress</em></strong><br>基本数据的类型的大小是固定的，这里就不多说了。对于非基本类型的Java对象，其大小就值得商榷。</p><h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a><strong>引用类型</strong></h3><p>对象引用类型分为强引用、软引用、弱引用和虚引用。</p><p><strong><em>强引用</em></strong>   ：就是我们一般声明对象是时虚拟机生成的引用，强引用环境下，垃圾回收时需要严格判断当前对象是否被强引用，如果被强引用，则不会被垃圾回收。<br><strong><em>软引用</em></strong>   ：软引用一般被做为缓存来使用。与强引用的区别是，软引用在垃圾回收时，虚拟机会根据当前系统的剩余内存来决定是否对软引用进行回收。<br>如果剩余内存比较紧张，则虚拟机会回收软引用所引用的空间；如果剩余内存相对富裕，则不会进行回收。换句话说，虚拟机在发生OutOfMemory时，肯定是没有软引用存在的。<br><strong><em>弱引用</em></strong>   ：弱引用与软引用类似，都是作为缓存来使用。但与软引用不同，弱引用在进行垃圾回收时，是一定会被回收掉的，因此其生命周期只存在于一个垃圾回收周期内。<br>强引用不用说，我们系统一般在使用时都是用的强引用。而“软引用”和“弱引用”比较少见。他们一般被作为缓存使用，而且一般是在内存大小比较受限的情况下做为缓存。<br>因为如果内存足够大的话，可以直接使用强引用作为缓存即可，同时可控性更高。因而，他们常见的是被使用在桌面应用系统的缓存。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h3><p>在<strong>Java</strong>中，一个空<code>Object</code>对象的大小是<code>8byte</code>，这个大小只是保存堆中一个没有任何属性的对象的大小。<br>看下面语句：<br><img src="/img/jvm/33.png" alt=""><br>这样在程序中完成了一个<strong>Java</strong>对象的生命，但是它所占的空间为：<code>4byte</code>+<code>8byte</code>。</p><ul><li><code>4byte</code>是上面部分所说的Java栈中保存引用的所需要的空间。</li><li><code>8byte</code>则是<strong>Java</strong>堆中对象的信息。</li></ul><p>因为所有的<strong>Java</strong>非基本类型的对象都需要默认继承<code>Object</code>对象，<br>因此不论什么样的<strong>Java</strong>对象，其大小都必须是大于<code>8byte</code>。<br>有了<code>Object对象</code>的大小，我们就可以计算其他对象的大小了。<br><img src="/img/jvm/32.png" alt=""></p><p><strong><em>其大小为</em></strong>：<strong><em>空对象</em></strong> 大小(<code>8byte</code>)+<strong><em>int</em></strong> 大小(<code>4byte</code>)+<strong><em>Boolean</em></strong> 大小(<code>1byte</code>)+<strong><em>空Object</em></strong> 引用的大小(<code>4byte</code>)=<code>17byte</code>。<br>但是因为<strong>Java</strong>在对对象内存分配时都是以8的整数倍来分，因此大于<code>17byte</code>的最接近8的整数倍的是24，因此此对象的大小为<code>24byte</code>。</p><p>这里需要注意一下基本类型的包装类型的大小。因为这种包装类型已经成为对象了，因此需要把他们作为对象来看待。<br>包装类型的大小至少是<code>12byte</code>（声明一个<strong><em>空Object</em></strong> 至少需要的空间），而且<code>12byte</code>没有包含任何有效信息，<br>同时，因为<strong>Java</strong>对象大小是8的整数倍，因此一个基本类型包装类的大小至少是<code>16byte</code>。<br>这个内存占用是很恐怖的，它是使用基本类型的N倍（N&gt;2），有些类型的内存占用更是夸张。<br>因此，可能的话应尽量少使用包装类。在JDK5.0以后，因为加入了自动类型装换，因此，<strong>Java</strong>虚拟机会在存储方面进行相应的优化。</p><h2 id="JVM内存分配与回收"><a href="#JVM内存分配与回收" class="headerlink" title="JVM内存分配与回收"></a>JVM内存分配与回收</h2><h3 id="对象优先在Eden区分配"><a href="#对象优先在Eden区分配" class="headerlink" title="对象优先在Eden区分配"></a><strong>对象优先在Eden区分配</strong></h3><p>大多数情况下，对象在新生代中 Eden 区分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次Minor GC。<br><strong><em>对象在新生代中 Eden 区分配</em></strong>示例：<br><img src="/img/jvm/6.png" alt="运行效果"></p><p>当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC.GC期间虚拟机又发现新的对象无法存入Survior空间<br>所以只好通过<strong><em>分配担保机制</em></strong>把新生代的对象提前转移到老年代中去，老年代上的空间足够存放新的对象，所以不会出现Full GC。<br>执行Minor GC后，后面分配的对象如果能够存在eden区的话，还是会在eden区分配内存。<br><img src="/img/jvm/7.png" alt="示例"></p><h3 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a><strong>大对象直接进入老年代</strong></h3><p>大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。<br>为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率。</p><h3 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a><strong>长期存活的对象将进入老年代</strong></h3><p>既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别那些对象应放在新生代，那些对象应放在老年代中。为了做到这一点，<br>虚拟机给每个对象一个<code>对象年龄（Age）</code>计数器。<br>如果对象在 Eden 出生并经过第一次 <code>Minor GC</code> 后仍然能够存活，并且能被 <code>Survivor</code> 容纳的话，将被移动到 <code>Survivor</code> 空间中，并将对象年龄设为1.对象在 <code>Survivor</code> 中每熬过一次 MinorGC,年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁），就会被晋升到老年代中。<br>对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</p><h2 id="如何判断对象可以被回收"><a href="#如何判断对象可以被回收" class="headerlink" title="如何判断对象可以被回收"></a>如何判断对象可以被回收</h2><p>堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断那些对象已经死亡（即不能再被任何途径使用的对象）。</p><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a><strong>引用计数法</strong></h3><blockquote><p>给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加1；当引用失效，计数器就减1；任何时候计数器为0的对象就是不可能再被使用的。</p></blockquote><p>这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。<br><img src="/img/jvm/8.png" alt="示例"></p><h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a><strong>可达性分析算法</strong></h3><p>这个算法的基本思想就是通过一系列的称为 <strong><em>GC Roots</em></strong> 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到<strong><em>GC Roots</em></strong>没有任何引用链相连的话，则证明此对象是不可用的。<br><strong><em>GC Roots</em></strong>根节点：类加载器、Thread、虚拟机栈的本地变量表、static成员、常量引用、本地方法栈的变量等等。<br><img src="/img/jvm/9.png" alt="示例"></p><h3 id="finalize-方法最终判定对象是否存活"><a href="#finalize-方法最终判定对象是否存活" class="headerlink" title="finalize()方法最终判定对象是否存活"></a><strong>finalize()方法最终判定对象是否存活</strong></h3><p>即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历再次标记过程。<br>标记的前提是对象在进行可达性分析后发现没有与GC Roots相连接的引用链。</p><p><strong><em>1. 第一次标记并进行一次筛选</em></strong></p><ul><li>筛选的条件是此对象是否有必要执行finalize()方法。</li><li>当对象没有覆盖finalize方法，或者finzlize方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”，对象被回收。</li></ul><p><strong><em>2. 第二次标记</em></strong></p><ul><li>如果这个对象被判定为有必要执行finalize（）方法，那么这个对象将会被放置在一个名为：F-Queue的队列之中，并在稍后由一条虚拟机自动建立的、低优先级的Finalizer线程去执行。</li><li>这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束。</li></ul><p><strong><em>这样做的原因</em></strong>:</p><ul><li>如果一个对象finalize（）方法中执行缓慢，或者发生死循环（更极端的情况），将很可能会导致F-Queue队列中的其他对象永久处于等待状态，甚至导致整个内存回收系统崩溃。</li><li><code>finalize（）</code>方法是对象脱逃死亡命运的最后一次机会，稍后<code>GC</code>将对<code>F-Queue</code>中的对象进行第二次小规模标记</li><li>对象要在<code>finalize（）</code>中成功拯救自己只要重新与引用链上的任何的一个对象建立关联即可</li></ul><p>譬如:</p><ul><li>把自己赋值给某个类变量或对象的成员变量，那在第二次标记时它将移除出“即将回收”的集合。</li><li>如果对象这时候还没逃脱，那基本上它就真的被回收了。</li></ul><h3 id="如何判断一个常量是废弃常量"><a href="#如何判断一个常量是废弃常量" class="headerlink" title="如何判断一个常量是废弃常量"></a><strong>如何判断一个常量是废弃常量</strong></h3><blockquote><p>运行时常量池主要回收的是废弃的常量。那么，我们如何判断一个常量是废弃常量呢？</p></blockquote><p>假如在常量池中存在字符串 “abc”，如果当前没有任何String对象引用该字符串常量的话，就说明常量 “abc” 就是废弃常量，如果这时发生内存回收的话而且有必要的话，”abc” 就会被系统清理出常量池。</p><h3 id="如何判断一个类是无用的类"><a href="#如何判断一个类是无用的类" class="headerlink" title="如何判断一个类是无用的类"></a><strong>如何判断一个类是无用的类</strong></h3><blockquote><p>方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？</p></blockquote><p>判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。<br>类需要同时满足下面3个条件才能算是 “无用的类” ：</p><ul><li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li><li>加载该类的 ClassLoader 已经被回收。</li><li>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul><p>虚拟机可以对满足上述3个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。</p><h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a><strong>标记-清除算法</strong></h3><p>算法分为“标记”和“清除”阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。它是最基础的收集算法，效率也很高，但是会带来两个明显的问题：</p><ul><li>效率问题</li><li>空间问题（标记清除后会产生大量不连续的碎片）</li></ul><p><img src="/img/jvm/10.png" alt=""></p><h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a><strong>复制算法</strong></h3><p>为了解决效率问题，“复制”收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。<br><img src="/img/jvm/11.png" alt=""></p><h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a><strong>标记-整理算法</strong></h3><p>根据老年代的特点特出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一段移动，然后直接清理掉端边界以外的内存。<br><img src="/img/jvm/12.png" alt=""></p><h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a><strong>分代收集算法</strong></h3><p>当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。<br>一般将java堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。<br>比如在新生代中，每次收集都会有大量对象死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。<br>而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。</p><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。<br>虽然我们对各个收集器进行比较，但并非为了挑选出一个最好的收集器。<br>因为直到现在为止还没有最好的垃圾收集器出现，更加没有万能的垃圾收集器，我们能做的就是根据具体应用场景选择适合自己的垃圾收集器。<br>试想一下：如果有一种四海之内、任何场景下都适用的完美收集器存在，那么我们的HotSpot虚拟机就不会实现那么多不同的垃圾收集器了。</p><h3 id="Serial-串行收集器"><a href="#Serial-串行收集器" class="headerlink" title="Serial 串行收集器"></a><strong>Serial 串行收集器</strong></h3><p>Serial（串行）收集器收集器是最基本、历史最悠久的垃圾收集器了。<br>大家看名字就知道这个收集器是一个单线程收集器了。<br>它的 “单线程” 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ “Stop The World” ），直到它收集结束。<br>新生代采用复制算法，老年代采用标记-整理算法。<br><img src="/img/jvm/21.png" alt=""><br><img src="/img/jvm/22.png" alt=""><br>用单线程处理所有垃圾回收工作，因为无需多线程交互，所以效率比较高。但是，也无法使用多处理器的优势，所以此收集器适合单处理器机器。<br>当然，此收集器也可以用在小数据量（100M左右）情况下的多处理器机器上。<br>可以使用-XX:+UseSerialGC打开。</p><p><img src="/img/jvm/13.png" alt=""><br>它简单而高效（与其他收集器的单线程相比）。Serial收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。</p><p>此收集器可以进行如下配置：</p><ul><li>最大垃圾回收暂停:指定垃圾回收时的最长暂停时间-XX:MaxGCPauseMillis=<N><N>指定。<N><N>为毫秒.如果指定了此值的话，堆大小和垃圾回收相关参数会进行调整以达到指定值。设定此值可能会减少应用的吞吐量。</li><li>吞吐量:吞吐量为垃圾回收时间与非垃圾回收时间的比值，通过-XX:GCTimeRatio=<N><N>来设定，公&gt;式为1/（1+N）。<br>例如，-XX:GCTimeRatio=19时，表示5%的时间用于垃圾回收。默认情况为99，即&gt;1%的时间用于垃圾回收。</li></ul><h3 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a><strong>ParNew 收集器</strong></h3><p>ParNew收集器其实就是Serial收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和Serial收集器完全一样。<br>新生代采用复制算法，老年代采用标记-整理算法。<br><img src="/img/jvm/15.png" alt=""><br>它是许多运行在Server模式下的虚拟机的首要选择，除了Serial收集器外，只有它能与CMS收集器（真正意义上的并发收集器，后面会介绍到）配合工作。</p><h3 id="Parallel-Scavenge-并行收集器"><a href="#Parallel-Scavenge-并行收集器" class="headerlink" title="Parallel Scavenge 并行收集器"></a><strong>Parallel Scavenge 并行收集器</strong></h3><p>指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。适合科学计算、后台处理等弱交互场景。</p><p>Parallel Scavenge 收集器类似于ParNew 收集器，是Server 模式（内存大于2G，2个cpu）下的默认收集器，那么它有什么特别之处呢？<br>Parallel Scavenge收集器关注点是吞吐量（高效率的利用CPU）。CMS等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。<br>所谓吞吐量就是CPU中用于运行用户代码的时间与CPU总消耗时间的比值。 Parallel Scavenge收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解的话，可以选择把内存管理优化交给虚拟机去完成也是一个不错的选择。<br>新生代采用复制算法，老年代采用标记-整理算法。<br><img src="/img/jvm/14.png" alt=""></p><h3 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a><strong>Serial Old收集器</strong></h3><p>Serial收集器的老年代版本，它同样是一个单线程收集器。它主要有两大用途：一种用途是在JDK1.5以及以前的版本中与Parallel Scavenge收集器搭配使用，另一种用途是作为CMS收集器的后备方案。</p><h3 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a><strong>Parallel Old收集器</strong></h3><p>Parallel Scavenge收集器的老年代版本。使用多线程和“标记-整理”算法。在注重吞吐量以及CPU资源的场合，都可以优先考虑 Parallel Scavenge收集器和Parallel Old收集器。</p><h3 id="CMS-并发收集器-XX-UseConcMarkSweepGC-主要是old区使用"><a href="#CMS-并发收集器-XX-UseConcMarkSweepGC-主要是old区使用" class="headerlink" title="CMS 并发收集器(-XX:+UseConcMarkSweepGC(主要是old区使用)"></a><strong>CMS 并发收集器(-XX:+UseConcMarkSweepGC(主要是old区使用)</strong></h3><p><img src="/img/jvm/23.png" alt=""><br>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。<br>指用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行），用户程序在继续运行，而垃圾收集器运行在另一个CPU上。适合Web应用。<br>它而非常符合在注重用户体验的应用上使用，它是HotSpot虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。<br>可以保证大部分工作都并发进行（应用不停止），垃圾回收只暂停很少的时间，此收集器适合对响应时间要求比较高的中、大规模应用。<br>使用-XX:+UseConcMarkSweepGC打开。</p><p>从名字中的Mark Sweep这两个词可以看出，CMS收集器是一种 “标记-清除”算法实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。</p><p>整个过程分为四个步骤：</p><ul><li>初始标记： 暂停所有的其他线程(STW)，并记录下直接与root相连的对象，速度很快 ；</li><li>并发标记： 同时开启GC和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。<br>因为用户线程可能会不断的更新引用域，所以GC线程无法保证-可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。</li><li>重新标记： 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</li><li>并发清除： 开启用户线程，同时GC线程开始对未标记的区域做清扫。<br><img src="/img/jvm/16.png" alt=""><br>从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：并发收集、低停顿。但是它有下面三个明显的缺点：<br>对CPU资源敏感（会和服务抢资源）；<br>无法处理浮动垃圾(在java业务程序线程与垃圾收集线程并发执行过程中又产生的垃圾，这种浮动垃圾只能等到下一次gc再清理了)；<br>它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。</li></ul><h3 id="G1收集器-XX-UseG1GC"><a href="#G1收集器-XX-UseG1GC" class="headerlink" title="G1收集器(-XX:+UseG1GC)"></a><strong>G1收集器(-XX:+UseG1GC)</strong></h3><p>G1 (Garbage-First)是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足GC停顿时间要求的同时,还具备高吞吐量性能特征.<br><img src="/img/jvm/17.png" alt=""><br><img src="/img/jvm/18.png" alt=""><br>G1将Java堆划分为多个大小相等的独立区域（Region），虽保留新生代和老年代的概念，但不再是物理隔阂了，它们都是（可以不连续）Region的集合。<br>分配大对象（直接进Humongous区，专门存放短期巨型对象，不用直接进老年代，避免Full GC的大量开销）不会因为无法找到连续空间而提前触发下一次GC。<br>被视为JDK1.7中HotSpot虚拟机的一个重要进化特征。</p><p>它具备以下特点：<br><strong><em>并行与并发</em></strong>：G1能充分利用CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短Stop-The-World停顿时间。部分其他收集器原本需要停顿Java线程来执行GC动作，G1收集器仍然可以通过并发的方式让java程序继续执行。<br><strong><em>分代收集</em></strong>：虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但是还是保留了分代的概念。<br><strong><em>空间整合</em></strong>：与CMS的“标记–清理”算法不同，G1从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的。<br><strong><em>可预测的停顿</em></strong>：这是G1相对于CMS的另一个大优势，降低停顿时间是G1 和 CMS 共同的关注点，但G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内完成垃圾收集。</p><p>G1收集器的运作大致分为以下几个步骤：</p><ul><li>初始标记（initial mark，STW）：在此阶段，G1 GC 对根进行标记。该阶段与常规的 (STW) 年轻代垃圾回收密切相关。</li><li>并发标记（Concurrent Marking）：G1 GC 在整个堆中查找可访问的（存活的）对象。</li><li>最终标记（Remark，STW）：该阶段是 STW 回收，帮助完成标记周期。</li><li>筛选回收（Cleanup，STW）：筛选回收阶段首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划，这个阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅提高收集效率。<br><img src="/img/jvm/19.png" alt=""><br>G1收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的Region(这也就是它的名字Garbage-First的由来)。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了GF收集器在有限时间内可以尽可能高的收集效率。</li></ul><p>G1垃圾收集分类<br>YoungGC<br>新对象进入Eden区<br>存活对象拷贝到Survivor区<br>存活时间达到年龄阈值时，对象晋升到Old区<br>MixedGC<br>不是FullGC，回收所有的Young和部分Old(根据期望的GC停顿时间确定old区垃圾收集的优先顺序)<br>global concurrent marking （全局并发标记）<br>Initial marking phase:标记GC Root，STW<br>Root region scanning phase：标记存活Region<br>Concurrent marking phase：标记存活的对象<br>Remark phase :重新标记,STW<br>Cleanup phase:部分STW</p><p>相关参数<br>G1MixedGCLiveThresholdPercent Old区的region被回收的时候的存活对象占比<br>G1MixedGCCountTarget：一次global concurrent marking之后，最多执行Mixed GC的次数<br>G1OldCSetRegionThresholdPercent  一次Mixed GC中能被选入CSet的最多old区的region数量</p><p>触发的时机<br>InitiatingHeapOccupancyPercent:堆占有率达到这个值则触发global concurrent marking，默认45%<br>G1HeapWastePercent:在global concurrent marking结束之后，可以知道区有多少空间要被回收，在每次YGC之后和再次发生Mixed GC之前，会检查垃圾占比是否达到了此参数，只有达到了，下次才会发生Mixed GC</p><p>从设计目标看G1完全是为了大型应用而准备的。<br>支持很大的堆<br>高吞吐量<br>  –支持多CPU和垃圾回收线程<br>  –在主线程暂停的情况下，使用并行收集<br>  –在主线程运行的情况下，使用并发收集<br>实时目标：可配置在N毫秒内最多只占用M毫秒的时间进行垃圾回收</p><p>算法详解<br><img src="/img/jvm/24.png" alt=""></p><p>回收步骤：<br><strong><em>初始标记（Initial Marking）</em></strong></p><p>G1对于每个region都保存了两个标识用的bitmap，一个为previous marking bitmap，一个为next marking bitmap，bitmap中包含了一个bit的地址信息来指向对象的起始点。<br>开始Initial Marking之前，首先并发的清空next marking bitmap，然后停止所有应用线程，并扫描标识出每个region中root可直接访问到的对象，将region中top的值放入next top at mark start（TAMS）中，之后恢复所有应用线程。</p><p>触发这个步骤执行的条件为：<br>G1定义了一个JVM Heap大小的百分比的阀值，称为h，另外还有一个H，H的值为(1-h)<em>Heap Size，目前这个h的值是固定的，后续G1也许会将其改为动态的，根据jvm的运行情况来动态的调整，在分代方式下，G1还定义了一个u以及soft limit，soft limit的值为H-u</em>Heap Size，当Heap中使用的内存超过了soft limit值时，就会在一次clean up执行完毕后在应用允许的GC暂停时间范围内尽快的执行此步骤；</p><p>在pure方式下，G1将marking与clean up组成一个环，以便clean up能充分的使用marking的信息，当clean up开始回收时，首先回收能够带来最多内存空间的regions，当经过多次的clean up，回收到没多少空间的regions时，G1重新初始化一个新的marking与clean up构成的环。</p><p><strong><em>并发标记（Concurrent Marking）</em></strong></p><p>按照之前Initial Marking扫描到的对象进行遍历，以识别这些对象的下层对象的活跃状态，对于在此期间应用线程并发修改的对象的以来关系则记录到remembered set logs中，新创建的对象则放入比top值更高的地址区间中，这些新创建的对象默认状态即为活跃的，同时修改top值。</p><p><strong><em>最终标记暂停（Final Marking Pause）</em></strong></p><p>当应用线程的remembered set logs未满时，是不会放入filled RS buffers中的，在这样的情况下，这些remebered set logs中记录的card的修改就会被更新了，因此需要这一步，这一步要做的就是把应用线程中存在的remembered set logs的内容进行处理，并相应的修改remembered sets，这一步需要暂停应用，并行的运行。</p><p><strong><em>存活对象计算及清除（Live Data Counting and Cleanup）</em></strong></p><p>值得注意的是，在G1中，并不是说Final Marking Pause执行完了，就肯定执行Cleanup这步的，由于这步需要暂停应用，G1为了能够达到准实时的要求，需要根据用户指定的最大的GC造成的暂停时间来合理的规划什么时候执行Cleanup，另外还有几种情况也是会触发这个步骤的执行的：</p><p>G1采用的是复制方法来进行收集，必须保证每次的”to space”的空间都是够的，因此G1采取的策略是当已经使用的内存空间达到了H时，就执行Cleanup这个步骤；</p><p>对于full-young和partially-young的分代模式的G1而言，则还有情况会触发Cleanup的执行，full-young模式下，G1根据应用可接受的暂停时间、回收young regions需要消耗的时间来估算出一个yound regions的数量值，当JVM中分配对象的young regions的数量达到此值时，Cleanup就会执行；partially-young模式下，则会尽量频繁的在应用可接受的暂停时间范围内执行Cleanup，并最大限度的去执行non-young regions的Cleanup。</p><h2 id="实战调优"><a href="#实战调优" class="headerlink" title="实战调优"></a><strong>实战调优</strong></h2><p>JVM调优主要就是调整下面两个指标<br><strong><em>停顿时间</em></strong>:  垃圾收集器做垃圾回收中断应用执行的时间。-XX:MaxGCPauseMillis<br><strong><em>吞吐量</em></strong>：花在垃圾收集的时间和花在应用时间的占比 -XX:GCTimeRatio=<n>,垃圾收集时间占比：1/(1+n)</p><h3 id="调优步骤"><a href="#调优步骤" class="headerlink" title="调优步骤"></a><strong>调优步骤</strong></h3><p>打印GC日志<br>-XX:+PrintGCDetails  -XX:+PrintGCTimeStamps  -XX:+PrintGCDateStamps  -Xloggc:./gc.log<br>分析日志得到关键性指标<br>分析GC原因，调优JVM参数</p><h4 id="1、Parallel-Scavenge收集器-默认"><a href="#1、Parallel-Scavenge收集器-默认" class="headerlink" title="1、Parallel Scavenge收集器(默认)"></a><strong>1、Parallel Scavenge收集器(默认)</strong></h4><p>分析parallel-gc.log<br><strong><em>第一次调优</em></strong>设置Metaspace大小：增大元空间大小-XX:MetaspaceSize=64M  -XX:MaxMetaspaceSize=64M<br><strong><em>第二次调优</em></strong>添加吞吐量和停顿时间参数：-XX:MaxGCPauseMillis=100   -XX:GCTimeRatio=99<br><strong><em>第三次调优</em></strong>修改动态扩容增量：-XX:YoungGenerationSizeIncrement=30</p><h4 id="2、配置CMS收集器"><a href="#2、配置CMS收集器" class="headerlink" title="2、配置CMS收集器"></a><strong>2、配置CMS收集器</strong></h4><p> -XX:+UseConcMarkSweepGC<br>分析cms-gc.log</p><h4 id="3、配置G1收集器"><a href="#3、配置G1收集器" class="headerlink" title="3、配置G1收集器"></a><strong>3、配置G1收集器</strong></h4><p>-XX:+UseG1GC<br>分析g1-gc.log </p><p><strong><em>查看发生MixedGC的阈值</em></strong>：jinfo -flag InitiatingHeapOccupancyPercent 进程id<br><strong><em>分析工具</em></strong>：gceasy，GCViewer </p><h2 id="如何选择垃圾收集器"><a href="#如何选择垃圾收集器" class="headerlink" title="如何选择垃圾收集器"></a><strong>如何选择垃圾收集器</strong></h2><p>优先调整堆的大小让服务器自己来选择</p><ul><li>如果内存小于100M，使用串行收集器</li><li>如果是单核，并且没有停顿时间的要求，串行或JVM自己选择</li><li>如果允许停顿时间超过1秒，选择并行或者JVM自己选</li><li>如果响应时间最重要，并且不能超过1秒，使用并发收集器</li></ul><p>下图有连线的可以搭配使用，官方推荐使用G1，因为性能高<br><img src="/img/jvm/20.png" alt=""></p><p>串行处理器：</p><ul><li><strong><em>适用情况</em></strong>：数据量比较小（100M左右）；单处理器下并且对响应时间无要求的应用。</li><li><strong><em>缺点</em></strong>：只能用于小型应用</li></ul><p>并行处理器：</p><ul><li><strong><em>适用情况</em></strong>：“对吞吐量有高要求”，多CPU、对应用响应时间无要求的中、大型应用。举例：后台处理、科学计算。</li><li><strong><em>缺点</em></strong>：垃圾收集过程中应用响应时间可能加长</li></ul><p>并发处理器：</p><ul><li><strong><em>适用情况</em></strong>：“对响应时间有高要求”，多CPU、对应用响应时间有较高要求的中、大型应用。</li><li><strong><em>举例</em></strong>：Web服务器/应用服务器、电信交换、集成开发环境。</li></ul><h3 id="吞吐量优先的并行收集器"><a href="#吞吐量优先的并行收集器" class="headerlink" title="吞吐量优先的并行收集器"></a>吞吐量优先的并行收集器</h3><p>如上文所述，并行收集器主要以到达一定的吞吐量为目标，适用于科学技术和后台处理等。<br>典型设置：<br>java -Xmx3800m -Xms3800m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:ParallelGCThreads=20</p><ul><li>-XX:+UseParallelGC：选择垃圾收集器为并行收集器。此配置仅对年轻代有效。即上述配置下，年轻代使用并发收集，而年老代仍旧使用串行收集。</li><li>-XX:ParallelGCThreads=20：配置并行收集器的线程数，即：同时多少个线程一起进行垃圾回收。此值最好配置与处理器数目相等。<br>java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:ParallelGCThreads=20 -XX:+UseParallelOldGC</li><li>-XX:+UseParallelOldGC：配置年老代垃圾收集方式为并行收集。JDK6.0支持对年老代并行收集。<br>java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC  -XX:MaxGCPauseMillis=100</li><li>-XX:MaxGCPauseMillis=100:设置每次年轻代垃圾回收的最长时间，如果无法满足此时间，JVM会自动调整年轻代大小，以满足此值。<br>n java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC  -XX:MaxGCPauseMillis=100 -XX:+UseAdaptiveSizePolicy</li><li>-XX:+UseAdaptiveSizePolicy：设置此选项后，并行收集器会自动选择年轻代区大小和相应的Survivor区比例，以达到目标系统规定的最低相应时间或者收集频率等，此值建议使用并行收集器时，一直打开。</li></ul><h3 id="响应时间优先的并发收集器"><a href="#响应时间优先的并发收集器" class="headerlink" title="响应时间优先的并发收集器"></a>响应时间优先的并发收集器</h3><p>如上文所述，并发收集器主要是保证系统的响应时间，减少垃圾收集时的停顿时间。适用于应用服务器、电信领域等。<br>典型设置：</p><ul><li>java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:ParallelGCThreads=20 -XX:+UseConcMarkSweepGC -XX:+UseParNewGC</li><li>-XX:+UseConcMarkSweepGC：设置年老代为并发收集。测试中配置这个以后，-XX:NewRatio=4的配置失效了，原因不明。所以，此时年轻代大小最好用-Xmn设置。</li><li>-XX:+UseParNewGC: 设置年轻代为并行收集。可与CMS收集同时使用。JDK5.0以上，JVM会根据系统配置自行设置，所以无需再设置此值。</li></ul><p>java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseConcMarkSweepGC -XX:CMSFullGCsBeforeCompaction=5 -XX:+UseCMSCompactAtFullCollection</p><ul><li>-XX:CMSFullGCsBeforeCompaction：由于并发收集器不对内存空间进行压缩、整理，所以运行一段时间以后会产生“碎片”，使得运行效率降低。此值设置运行多少次GC以后对内存空间进行压缩、整理。</li><li>-XX:+UseCMSCompactAtFullCollection：打开对年老代的压缩。可能会影响性能，但是可以消除碎片</li></ul><h3 id="年轻代的设置很关键"><a href="#年轻代的设置很关键" class="headerlink" title="年轻代的设置很关键"></a>年轻代的设置很关键</h3><p>JVM中最大堆大小有三方面限制：相关操作系统的数据模型（32-bt还是64-bit）限制；系统的可用虚拟内存限制；系统的可用物理内存限制。32位系统下，一般限制在1.5G~2G；64为操作系统对内存无限制。在Windows Server 2003 系统，3.5G物理内存，JDK5.0下测试，最大可设置为1478m。<br>典型设置：<br>java -Xmx3550m -Xms3550m -Xmn2g –Xss128k</p><ul><li>-Xmx3550m：设置JVM最大可用内存为3550M。</li><li>-Xms3550m：设置JVM促使内存为3550m。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。</li><li>-Xmn2g：设置年轻代大小为2G。整个堆大小=年轻代大小 + 年老代大小 + 持久代大小。持久代一般固定大小为64m，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。</li><li>-Xss128k：设置每个线程的堆栈大小。JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。<br>更具应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。<br>但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。</li></ul><p>java -Xmx3550m -Xms3550m -Xss128k -XX:NewRatio=4 -XX:SurvivorRatio=4 -XX:MaxPermSize=16m -XX:MaxTenuringThreshold=0</p><ul><li>-XX:NewRatio=4:设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）。设置为4，则年轻代与年老代所占比值为1：4，年轻代占整个堆栈的1/5</li><li>-XX:SurvivorRatio=4：设置年轻代中Eden区与Survivor区的大小比值。设置为4，则两个Survivor区与一个Eden区的比值为2:4，一个Survivor区占整个年轻代的1/6</li><li>-XX:MaxPermSize=16m:设置持久代大小为16m。</li><li>-XX:MaxTenuringThreshold=0：设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。<br>对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概论。</li></ul><h3 id="G1调优相关"><a href="#G1调优相关" class="headerlink" title="G1调优相关"></a>G1调优相关</h3><h4 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a><strong>常用参数</strong></h4><ul><li>-XX:+UseG1GC 开启G1</li><li>-XX:G1HeapRegionSize=n,region的大小，1-32M，2048个</li><li>-XX:MaxGCPauseMillis=200 最大停顿时间</li><li>-XX:G1NewSizePercent   -XX:G1MaxNewSizePercent</li><li>-XX:G1ReservePercent=10 保留防止to space溢出（）</li><li>-XX:ParallelGCThreads=n SWT线程数（停止应用程序）</li><li>-XX:ConcGCThreads=n 并发线程数=1/4*并行</li></ul><h4 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a><strong>最佳实践</strong></h4><p><strong><em>年轻代大小</em></strong>：避免使用-Xmn、-XX:NewRatio等显示设置Young区大小，会覆盖暂停时间目标（常用参数3）<br><strong><em>暂停时间目标</em></strong>：暂停时间不要太严苛，其吞吐量目标是90%的应用程序时间和10%的垃圾回收时间，太严苛会直接影响到吞吐量</p><p>是否需要切换到G1</p><ul><li>50%以上的堆被存活对象占用</li><li>对象分配和晋升的速度变化非常大</li><li>垃圾回收时间特别长，超过1秒</li></ul><p>G1调优目标</p><ul><li>6GB以上内存</li><li>停顿时间是500ms以内</li><li>吞吐量是90%以上</li></ul><h3 id="GC常用参数"><a href="#GC常用参数" class="headerlink" title="GC常用参数"></a>GC常用参数</h3><h4 id="堆栈设置"><a href="#堆栈设置" class="headerlink" title="堆栈设置"></a><strong>堆栈设置</strong></h4><ul><li><code>-Xss</code>:每个线程的栈大小</li><li><code>-Xms</code>:初始堆大小，默认物理内存的1/64</li><li><code>-Xmx</code>:最大堆大小，默认物理内存的1/4</li><li><code>-Xmn</code>:新生代大小</li><li><code>-XX:NewSize</code>:设置新生代初始大小</li><li><code>-XX:NewRatio</code>:默认2表示新生代占年老代的1/2，占整个堆内存的1/3。</li><li><code>-XX:SurvivorRatio</code>:默认8表示一个survivor区占用1/8的Eden内存，即1/10的新生代内存。</li><li><code>-XX:MetaspaceSize</code>:设置元空间大小</li><li><code>-XX:MaxMetaspaceSize</code>:设置元空间最大允许大小，默认不受限制，JVM Metaspace会进行动态扩展。</li></ul><h4 id="收集器设置"><a href="#收集器设置" class="headerlink" title="收集器设置"></a><strong>收集器设置</strong></h4><ul><li><code>-XX:+UseSerialGC</code>:设置串行收集器</li><li><code>-XX:+UseParallelGC</code>:设置并行收集器</li><li><code>-XX:+UseParallelOldGC</code>:老年代使用并行回收收集器</li><li><code>-XX:+UseParNewGC</code>:在新生代使用并行收集器</li><li><code>-XX:+UseParalledlOldGC</code>:设置并行老年代收集器</li><li><code>-XX:+UseConcMarkSweepGC</code>:设置CMS并发收集器</li><li><code>-XX:+UseG1GC</code>:设置G1收集器</li><li><code>-XX:ParallelGCThreads</code>:设置用于垃圾回收的线程数</li></ul><h4 id="并行收集器设置"><a href="#并行收集器设置" class="headerlink" title="并行收集器设置"></a><strong>并行收集器设置</strong></h4><ul><li><code>-XX:ParallelGCThreads</code>:设置并行收集器收集时使用的CPU数。并行收集线程数。</li><li><code>-XX:MaxGCPauseMillis</code>:设置并行收集最大暂停时间</li><li><code>-XX:GCTimeRatio</code>:设置垃圾回收时间占程序运行时间的百分比。公式为1/(1+n)</li></ul><h4 id="CMS-并发收集器设置"><a href="#CMS-并发收集器设置" class="headerlink" title="CMS 并发收集器设置"></a><strong>CMS 并发收集器设置</strong></h4><ul><li><code>-XX:+UseConcMarkSweepGC</code>:设置CMS并发收集器</li><li><code>-XX:+CMSIncrementalMode</code>:设置为增量模式。适用于单CPU情况。</li><li><code>-XX:ParallelGCThreads</code>:设置并发收集器新生代收集方式为并行收集时，并发的GC线程数（并非STW时间，而是和服务一起执行的线程数）</li><li><code>-XX:CMSFullGCsBeforeCompaction</code>:设定进行多少次CMS垃圾回收后，进行一次内存压缩（因压缩非常的消耗时间，所以不能每次FullGC都做）</li><li><code>-XX:+CMSClassUnloadingEnabled</code>:允许对类元数据进行回收。启用回收Perm区（jdk1.7及以前）</li><li><code>-XX:UseCMSInitiatingOccupancyOnly</code>:表示只在到达阀值的时候，才进行CMS回收</li><li><code>-XX:+CMSIncrementalMode</code>:设置为增量模式。适用于单CPU情况</li><li><code>-XX:ParallelCMSThreads</code>:设定CMS的线程数量</li><li><code>-XX:CMSInitiatingOccupancyFraction</code>:设置CMS收集器在老年代空间被使用多少后触发（默认是92）</li><li><code>-XX:+UseCMSCompactAtFullCollection</code>:设置CMS收集器在完成垃圾收集后是否要进行一次内存碎片的整理    </li><li><code>-XX:+CMSScavengeBeforeRemark</code>:FullGC之前先做YGC（一般这个参数是打开的）</li></ul><h4 id="G1收集器设置"><a href="#G1收集器设置" class="headerlink" title="G1收集器设置"></a><strong>G1收集器设置</strong></h4><ul><li><code>-XX:+UseG1GC</code>:使用G1收集器</li><li><code>-XX:ParallelGCThreads</code>:指定GC工作的线程数量</li><li><code>-XX:G1HeapRegionSize</code>:指定分区大小(1MB~32MB，且必须是2的幂)，默认将整堆划分为2048个分区</li><li><code>-XX:GCTimeRatio</code>:吞吐量大小，0-100的整数(默认9)，值为n则系统将花费不超过1/(1+n)的时间用于垃圾收集</li><li><code>-XX:MaxGCPauseMillis</code>:目标暂停时间(默认200ms)</li><li><code>-XX:G1NewSizePercent</code>:新生代内存初始空间(默认整堆5%)</li><li><code>-XX:G1MaxNewSizePercent</code>:新生代内存最大空间</li><li><code>-XX:TargetSurvivorRatio</code>:<code>Survivor</code>填充容量(默认50%)</li><li><code>-XX:MaxTenuringThreshold</code>:最大任期阈值(默认15)</li><li><code>-XX:InitiatingHeapOccupancyPercen</code>:老年代占用空间超过整堆比IHOP阈值(默认45%),超过则执行混合收集</li><li><code>-XX:G1HeapWastePercent</code>:堆废物百分比(默认5%)</li><li><code>-XX:G1MixedGCCountTarget</code>:参数混合周期的最大总次数(默认8)</li></ul><h2 id="调优总结"><a href="#调优总结" class="headerlink" title="调优总结"></a>调优总结</h2><h3 id="年轻代大小选择"><a href="#年轻代大小选择" class="headerlink" title="年轻代大小选择"></a><strong>年轻代大小选择</strong></h3><p><strong><em>响应时间优先的应用</em></strong>：尽可能设大，直到接近系统的最低响应时间限制（根据实际情况选择）。在此种情况下，年轻代收集发生的频率也是最小的。同时，减少到达年老代的对象。<br><strong><em>吞吐量优先的应用</em></strong>：尽可能的设置大，可能到达Gbit的程度。因为对响应时间没有要求，垃圾收集可以并行进行，一般适合8CPU以上的应用。</p><h3 id="年老代大小选择"><a href="#年老代大小选择" class="headerlink" title="年老代大小选择"></a><strong>年老代大小选择</strong></h3><p><strong><em>响应时间优先的应用</em></strong>：年老代使用并发收集器，所以其大小需要小心设置，一般要考虑并发会话率和会话持续时间等一些参数。如果堆设置小了，可以会造成内存碎片、高回收频率以及应用暂停而使用传统的标记清除方式；<br>如果堆大了，则需要较长的收集时间。最优化的方案，一般需要参考以下数据获得：</p><ul><li>并发垃圾收集信息</li><li>持久代并发收集次数</li><li>传统GC信息</li><li>花在年轻代和年老代回收上的时间比例<br>减少年轻代和年老代花费的时间，一般会提高应用的效率</li></ul><h3 id="吞吐量优先的应用"><a href="#吞吐量优先的应用" class="headerlink" title="吞吐量优先的应用"></a><strong>吞吐量优先的应用</strong></h3><p>一般吞吐量优先的应用都有一个很大的年轻代和一个较小的年老代。原因是，这样可以尽可能回收掉大部分短期对象，减少中期的对象，而年老代尽存放长期存活对象。</p><h3 id="较小堆引起的碎片问题"><a href="#较小堆引起的碎片问题" class="headerlink" title="较小堆引起的碎片问题"></a><strong>较小堆引起的碎片问题</strong></h3><p>因为年老代的并发收集器使用标记、清除算法，所以不会对堆进行压缩。当收集器回收时，他会把相邻的空间进行合并，这样可以分配给较大的对象。<br>但是，当堆空间较小时，运行一段时间以后，就会出现“碎片”，<br>如果并发收集器找不到足够的空间，那么并发收集器将会停止，然后使用传统的标记、清除方式进行回收。<br>如果出现“碎片”，可能需要进行如下配置：</p><ul><li>-XX:+UseCMSCompactAtFullCollection：使用并发收集器时，开启对年老代的压缩。</li><li>-XX:CMSFullGCsBeforeCompaction=0：上面配置开启的情况下，这里设置多少次Full GC后，对年老代进行压缩</li></ul><h2 id="JVM调优工具"><a href="#JVM调优工具" class="headerlink" title="JVM调优工具"></a>JVM调优工具</h2><h3 id="Jconsole"><a href="#Jconsole" class="headerlink" title="Jconsole"></a><strong>Jconsole</strong></h3><p>jdk自带，功能简单，但是可以在系统有一定负荷的情况下使用。对垃圾回收算法有很详细的跟踪。</p><h3 id="JProfiler"><a href="#JProfiler" class="headerlink" title="JProfiler"></a><strong>JProfiler</strong></h3><p>商业软件，需要付费。功能强大。</p><h3 id="VisualVM"><a href="#VisualVM" class="headerlink" title="VisualVM"></a><strong>VisualVM</strong></h3><p>DK自带，功能强大，与JProfiler类似。推荐。</p><h2 id="如何调优"><a href="#如何调优" class="headerlink" title="如何调优"></a>如何调优</h2><p>观察内存释放情况、集合类检查、对象树<br>上面这些调优工具都提供了强大的功能，但是总的来说一般分为以下几类功能</p><h3 id="堆信息查看"><a href="#堆信息查看" class="headerlink" title="堆信息查看"></a><strong>堆信息查看</strong></h3><p><img src="/img/jvm/25.png" alt=""><br>可查看堆空间大小分配（年轻代、年老代、持久代分配）<br>提供即时的垃圾回收功能<br>垃圾监控（长时间监控回收情况）<br><img src="/img/jvm/26.png" alt=""><br>查看堆内类、对象信息查看：数量、类型等<br><img src="/img/jvm/27.png" alt=""><br>对象引用情况查看<br>有了堆信息查看方面的功能，我们一般可以顺利解决以下问题：<br>年老代年轻代大小划分是否合理<br>内存泄漏<br>垃圾回收算法设置是否合理</p><h3 id="线程监控"><a href="#线程监控" class="headerlink" title="线程监控"></a><strong>线程监控</strong></h3><p><img src="/img/jvm/28.png" alt=""><br><strong><em>线程信息监控</em></strong>：系统线程数量。<br><strong><em>线程状态监控</em></strong>：各个线程都处在什么样的状态下</p><p><img src="/img/jvm/29.png" alt=""><br><strong><em>Dump线程详细信息</em></strong>：查看线程内部运行情况<br>死锁检查</p><h3 id="热点分析"><a href="#热点分析" class="headerlink" title="热点分析"></a><strong>热点分析</strong></h3><p><img src="/img/jvm/30.png" alt=""><br><strong><em>CPU热点</em></strong>：检查系统哪些方法占用的大量CPU时间<br><strong><em>内存热点</em></strong>：检查哪些对象在系统中数量最大（一定时间内存活对象和销毁对象一起统计）<br>这两个东西对于系统优化很有帮助。我们可以根据找到的热点，有针对性的进行系统的瓶颈查找和进行系统优化，而不是漫无目的的进行所有代码的优化。</p><h3 id="快照"><a href="#快照" class="headerlink" title="快照"></a><strong>快照</strong></h3><p>快照是系统运行到某一时刻的一个定格。<br>在我们进行调优的时候，不可能用眼睛去跟踪所有系统变化，依赖快照功能，我们就可以进行系统两个不同运行时刻，对象（或类、线程等）的不同，以便快速找到问题<br>举例说，我要检查系统进行垃圾回收以后，是否还有该收回的对象被遗漏下来的了。那么，我可以在进行垃圾回收前后，分别进行一次堆情况的快照，然后对比两次快照的对象情况。</p><h2 id="内存泄漏检查"><a href="#内存泄漏检查" class="headerlink" title="内存泄漏检查"></a>内存泄漏检查</h2><p>内存泄漏是比较常见的问题，而且解决方法也比较通用，这里可以重点说一下，而线程、热点方面的问题则是具体问题具体分析了。<br>内存泄漏一般可以理解为系统资源（各方面的资源，堆、栈、线程等）在错误使用的情况下，导致使用完毕的资源无法回收（或没有回收），从而导致新的资源分配请求无法完成，引起系统错误。<br>内存泄漏对系统危害比较大，因为他可以直接导致系统的崩溃。<br>需要区别一下，内存泄漏和系统超负荷两者是有区别的，虽然可能导致的最终结果是一样的。内存泄漏是用完的资源没有回收引起错误，而系统超负荷则是系统确实没有那么多资源可以分配了（其他的资源都在使用）。</p><h3 id="年老代堆空间被占满"><a href="#年老代堆空间被占满" class="headerlink" title="年老代堆空间被占满"></a><strong>年老代堆空间被占满</strong></h3><p><img src="/img/jvm/31.png" alt=""><br><strong><em>异常</em></strong>： java.lang.OutOfMemoryError: Java heap space<br><strong><em>说明</em></strong>：<br>这是最典型的内存泄漏方式，简单说就是所有堆空间都被无法回收的垃圾对象占满，虚拟机无法再在分配新空间。<br>如上图所示，这是非常典型的内存泄漏的垃圾回收情况图。所有峰值部分都是一次垃圾回收点，所有谷底部分表示是一次垃圾回收后剩余的内存。连接所有谷底的点，可以发现一条由底到高的线，这说明，随时间的推移，系统的堆空间被不断占满，最终会占满整个堆空间。因此可以初步认为系统内部可能有内存泄漏。（上面的图仅供示例，在实际情况下收集数据的时间需要更长，比如几个小时或者几天）<br>解决：<br>这种方式解决起来也比较容易，一般就是根据垃圾回收前后情况对比，同时根据对象引用情况（常见的集合对象引用）分析，基本都可以找到泄漏点。</p><h3 id="持久代被占满"><a href="#持久代被占满" class="headerlink" title="持久代被占满"></a><strong>持久代被占满</strong></h3><p><strong><em>异常</em></strong>：java.lang.OutOfMemoryError: PermGen space<br><strong><em>说明</em></strong>：<br>Perm空间被占满。无法为新的class分配存储空间而引发的异常。这个异常以前是没有的，但是在Java反射大量使用的今天这个异常比较常见了。主要原因就是大量动态反射生成的类不断被加载，最终导致Perm区被占满。<br>更可怕的是，不同的classLoader即便使用了相同的类，但是都会对其进行加载，相当于同一个东西，如果有N个classLoader那么他将会被加载N次。因此，某些情况下，这个问题基本视为无解。当然，存在大量classLoader和大量反射类的情况其实也不多。<br>解决：<br>-XX:MaxPermSize=16m<br>换用JDK。比如JRocket。</p><h3 id="堆栈溢出"><a href="#堆栈溢出" class="headerlink" title="堆栈溢出"></a><strong>堆栈溢出</strong></h3><p><strong><em>异常</em></strong>：java.lang.StackOverflowError<br><strong><em>说明</em></strong>：这个就不多说了，一般就是递归没返回，或者循环调用造成</p><h3 id="线程堆栈满"><a href="#线程堆栈满" class="headerlink" title="线程堆栈满"></a><strong>线程堆栈满</strong></h3><p><strong><em>异常</em></strong>：Fatal: Stack size too small<br><strong><em>说明</em></strong>：java中一个线程的空间大小是有限制的。JDK5.0以后这个值是1M。与这个线程相关的数据将会保存在其中。但是当线程空间满了以后，将会出现上面异常。<br><strong><em>解决</em></strong>：增加线程栈大小。-Xss2m。但这个配置无法解决根本问题，还要看代码部分是否有造成泄漏的部分。</p><h3 id="系统内存被占满"><a href="#系统内存被占满" class="headerlink" title="系统内存被占满"></a><strong>系统内存被占满</strong></h3><p><strong><em>异常</em></strong>：java.lang.OutOfMemoryError: unable to create new native thread<br><strong><em>说明</em></strong>：<br>这个异常是由于操作系统没有足够的资源来产生这个线程造成的。系统创建线程时，除了要在Java堆中分配内存外，操作系统本身也需要分配资源来创建线程。因此，当线程数量大到一定程度以后，堆中或许还有空间，但是操作系统分配不出资源来了，就出现这个异常了。<br>分配给Java虚拟机的内存愈多，系统剩余的资源就越少，因此，当系统内存固定时，分配给Java虚拟机的内存越多，那么，系统总共能够产生的线程也就越少，两者成反比的关系。同时，可以通过修改-Xss来减少分配给单个线程的空间，也可以增加系统总共内生产的线程数。<br><strong><em>解决</em></strong>：<br>1.重新设计系统减少线程数量。<br>2.线程数量不能减少的情况下，通过-Xss减小单个线程大小。以便能生产更多的线程。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bootstrap相关整理</title>
      <link href="/2020/01/19/bootstrap/"/>
      <url>/2020/01/19/bootstrap/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h3 id="相关网站"><a href="#相关网站" class="headerlink" title="相关网站"></a>相关网站</h3><p><a href="http://getbootstrap.com/" target="_blank" rel="noopener">Bootstrap 官网</a><br><a href="https://www.bootcss.com/" target="_blank" rel="noopener">Bootstrap 中文网</a><br><a href="https://www.runoob.com/bootstrap/bootstrap-tables.html" target="_blank" rel="noopener">Bootstrap API</a><br><a href="https://bootsnipp.com/" target="_blank" rel="noopener">Bootstrap 示例</a><br><a href="https://v3.bootcss.com/components/" target="_blank" rel="noopener">Bootstrap v3 官网 中文</a><br><a href="https://v4.bootcss.com/docs/utilities/clearfix/" target="_blank" rel="noopener">Bootstrap v4 官网 中文</a><br><a href="https://www.bootcdn.cn/bootstrap-datetimepicker/" target="_blank" rel="noopener">Bootstrap-datetimepicker 英文</a><br><a href="https://www.bootstrap-table.com.cn/" target="_blank" rel="noopener">Bootstrap 数据表格中文官网</a><br><a href="http://bootstrap-table.wenzhixin.net.cn/" target="_blank" rel="noopener">Bootstrap 数据表格英文官网</a><br><a href="http://www.taufanaditya.com/bootstrap-markdown/" target="_blank" rel="noopener">Bootstrap-Markdown 英文</a><br><a href="http://bootstrap-tagsinput.github.io/bootstrap-tagsinput/examples/" target="_blank" rel="noopener">Bootstrap-tagsinput</a><br><a href="https://www.cnblogs.com/landeanfen/p/4976838.html" target="_blank" rel="noopener">Bootstrap 相关博客</a><br><a href="http://www.bootstrapmb.com/" target="_blank" rel="noopener">Bootstrap 网站模板</a><br><a href="http://www.zi-han.net/theme/hplus/" target="_blank" rel="noopener">H+ 后台主题UI框架 </a> 基于Bootstrap3.3.6最新版本开发的扁平化主题后台管理模板<br><a href="https://v3.bootcss.com/customize/" target="_blank" rel="noopener">V3 定制并下载 Bootstrap</a><br><a href="https://v3.bootcss.com/components/#glyphicons" target="_blank" rel="noopener">V3 使用示例</a><br><a href="https://v4.bootcss.com/docs/getting-started/introduction/" target="_blank" rel="noopener">V4 中文文档</a></p><h3 id="相关方法"><a href="#相关方法" class="headerlink" title="相关方法"></a><strong><em>相关方法</em></strong></h3><p>这些方法的调用方法主要是$(‘#bsTableTest’).bootstrap(‘&lt;方法名&gt;’,&lt;一个object形式的参数&gt;)。<br>常用的方法有：</p><h4 id="getOptions"><a href="#getOptions" class="headerlink" title="getOptions　　"></a><code>getOptions</code>　　</h4><p>获取表格的一些基本属性，返回一个object，key有像conlumns，data，sortOrder，class这些。</p><h4 id="getSelections"><a href="#getSelections" class="headerlink" title="getSelections　　"></a><code>getSelections</code>　　</h4><p>获取被选中的（包括radio或者checkbox）各行对象组成的列表。</p><h4 id="load-append-prepend"><a href="#load-append-prepend" class="headerlink" title="load,append,prepend　　"></a><code>load,append,prepend</code>　　</h4><p>这三个方法的参数都是data，即[{…},{…}…]形式的数据，load是清空当前表中所有数据，append是在表尾加，prepend是在第一行前面插入数据。</p><h4 id="remove"><a href="#remove" class="headerlink" title="remove　　"></a><code>remove</code>　　</h4><p>参数是一个object，含有两个字段，field和values。通过两个字段的值可以定位一个或多个单元格，把这些单元格所在的行删除。<br>例如bootstrapTable(‘remove’,{field:’id’,values:[3]})。需要注意的是即便是只定位一个单元格，即values后列表中只有一个值，那也要写出是个列表，否则会识别失败</p><h4 id="insertRow-updateRow"><a href="#insertRow-updateRow" class="headerlink" title="insertRow,updateRow　　"></a><code>insertRow,updateRow</code>　　</h4><p>这两个方法分别用于在指定位置插入一个新行或者更新指定行的信息。<br>参数有index和row，如bootstrapTable(‘insertRow’,{index:2,row:{id:99,name:’New Row’,desc:’Test’}})，<br>需注意，如果某些字段没有在params中给出值的话，那么insert时默认这些字段为undefined，update时默认这些字段没有改变。</p><h4 id="getRowByUniqueId"><a href="#getRowByUniqueId" class="headerlink" title="getRowByUniqueId　　"></a><code>getRowByUniqueId</code>　　</h4><p>这个方法要配合初始化时的uniqueId参数指定的字段，参数为此字段的某个值，返回值等于参数中给出值的那一行的行对象。</p><h4 id="showRow-hideRow"><a href="#showRow-hideRow" class="headerlink" title="showRow,hideRow　　"></a><code>showRow,hideRow</code>　　</h4><p>显示隐藏行，参数可用index，也可用uniqueId，如bootstrapTable(‘showRow’,{index:2})。</p><h4 id="showLoading-hideLoading"><a href="#showLoading-hideLoading" class="headerlink" title="showLoading,hideLoading　　"></a><code>showLoading,hideLoading</code>　　</h4><p>显示/隐藏加载状态</p><h4 id="mergeCells"><a href="#mergeCells" class="headerlink" title="mergeCells　　"></a><code>mergeCells</code>　　</h4><p>用于合并单元格，参数有四个，如果把合并后最左上角的那个单元格称为初始单元格的话，那么index是初始单元格的行的index，field是初始单元格所在列字段名。<br>这两个参数确定了一个起始单元格，然后还有两个参数rowspan和colspan都是int型，指出了从初始单元格开始向下并几行向右并几列。</p><h4 id="updateCell"><a href="#updateCell" class="headerlink" title="updateCell　　"></a><code>updateCell</code>　　</h4><p>index，field和value三个参数用来更新单个单元格内的值。</p><h4 id="refresh"><a href="#refresh" class="headerlink" title="refresh　　"></a><code>refresh</code>　　</h4><p>刷新表格数据，可以加入参数url指定请求发向的url（可以是一个新的），silent:true时静默更新，query:{} 可以指出一些新的ajax请求时的参数。　　</p><h4 id="resetSearch"><a href="#resetSearch" class="headerlink" title="resetSearch　　"></a><code>resetSearch</code>　　</h4><p>可以设置搜索框中文字，这个方法比较特殊的是参数不是一个object而是单纯的string。例如bootstrapTable(‘resetSearch’,’Hello’)。</p><h4 id="resetView-Width"><a href="#resetView-Width" class="headerlink" title="resetView/Width　　"></a><code>resetView/Width</code>　　</h4><p>可以重设样式（如宽度高度等），常用在页面大小、宽度等发生变化时。<br>比如侧边栏收放引起表格所在容器宽度发生变化，容易导致表头和表内容列错位。在宽度变化时调用这个函数便可以自动修正。</p><h4 id="checkAll-uncheckAll"><a href="#checkAll-uncheckAll" class="headerlink" title="checkAll,uncheckAll　　"></a><code>checkAll,uncheckAll</code>　　</h4><p>全选/全不选当前页面中的行</p><h4 id="check-uncheck"><a href="#check-uncheck" class="headerlink" title="check/uncheck　　"></a><code>check/uncheck</code>　　</h4><p>选中/不选一行，同resetSearch一样，不用传递object，直接写int型的index数据即可例如 bootstrapTable(‘check’,2)。</p><h4 id="checkBy-uncheckBy"><a href="#checkBy-uncheckBy" class="headerlink" title="checkBy/uncheckBy　　"></a><code>checkBy/uncheckBy</code>　　</h4><p>bootstrapTable(‘checkBy’,{field:’id’,values:[1,3,5]})，选中部分，条件由参数给出。</p><h4 id="getHiddenRows-getHiddenColumns"><a href="#getHiddenRows-getHiddenColumns" class="headerlink" title="getHiddenRows/getHiddenColumns　　"></a><code>getHiddenRows/getHiddenColumns</code>　　</h4><p>获取隐藏着的行和列们</p><h4 id="getScrollPosition-scrollTo"><a href="#getScrollPosition-scrollTo" class="headerlink" title="getScrollPosition/scrollTo　　"></a><code>getScrollPosition/scrollTo</code>　　</h4><p>当表格有滚动条时，前者返回滚动条滚动位置，后者设置。单位是px，scrollTo可以是’bottom’来拉到底。</p><h4 id="filterBy"><a href="#filterBy" class="headerlink" title="filterBy　　"></a><code>filterBy</code>　　</h4><p>在客户端进行数据过滤，参数是field和values。</p><h4 id="prevPage-nextPage-selectPage"><a href="#prevPage-nextPage-selectPage" class="headerlink" title="prevPage/nextPage/selectPage　　"></a><code>prevPage/nextPage/selectPage</code>　　</h4><p>跳往前一页/后一页/指定页。</p><h3 id="相关事件"><a href="#相关事件" class="headerlink" title="相关事件"></a><strong><em>相关事件</em></strong></h3><p>事件会关联一个函数，而不同的事件，关联的函数有哪些参数也都是不一样的。</p><p>下面列出主要可能用到的事件：</p><h4 id="onClickRow"><a href="#onClickRow" class="headerlink" title="onClickRow　　"></a><code>onClickRow</code>　　</h4><p>点击一行时触发的事件，参数有row , element , field三个，分别代表点击行的行对象，点击行的jquery<tr>对象，点击的列的title</p><h4 id="onDblClickRow"><a href="#onDblClickRow" class="headerlink" title="onDblClickRow　　"></a><code>onDblClickRow</code>　　</h4><p>双击行事件，参数和onDblClickRow一样</p><h4 id="onClickCell"><a href="#onClickCell" class="headerlink" title="onClickCell　　"></a><code>onClickCell</code>　　</h4><p>点击单元格触发的事件，参数包括field , value , row , element，分别表示点击单元格所在列title,单元格的值，单元格所在行行对象，单元格的jquery<td>对象</p><h4 id="onDblClickCell"><a href="#onDblClickCell" class="headerlink" title="onDblClickCell　　"></a><code>onDblClickCell</code>　　</h4><p>双击单元格事件，参数和onClickCell一样</p><h4 id="onSort"><a href="#onSort" class="headerlink" title="onSort　　"></a><code>onSort</code>　　</h4><p>点击排序按钮进行数据排序时触发的事件，包括参数name和order分别代表排序字段名和排序方式（asc和desc）</p><h4 id="onCheck-onUncheck"><a href="#onCheck-onUncheck" class="headerlink" title="onCheck/onUncheck　　"></a><code>onCheck/onUncheck</code>　　</h4><p>当某一行被选中/取消选中时触发事件，参数有row和element</p><h4 id="onCheckAll-onUncheckAll"><a href="#onCheckAll-onUncheckAll" class="headerlink" title="onCheckAll/onUncheckAll　　"></a><code>onCheckAll/onUncheckAll</code>　　</h4><p>参数是rows，一个被选中所有行对象的数组。需要注意，手动一个一个选择时不会触发这个事件，只有按表头的那个全选，全选行时才会触发。</p><h4 id="onLoadSuccess-onLoadError"><a href="#onLoadSuccess-onLoadError" class="headerlink" title="onLoadSuccess/onLoadError　　"></a><code>onLoadSuccess/onLoadError</code>　　</h4><p>当加载数据成功/失败时触发的事件，前者参数data，后者参数status（HTTP返回码，如500,404之类的）</p><h4 id="onColumnSwitch"><a href="#onColumnSwitch" class="headerlink" title="onColumnSwitch　　"></a><code>onColumnSwitch</code>　　</h4><p>当设置某一列可见/不可见时触发，参数是field和checked，field是被操作的字段title名，而checked是boolean值，表示操作后该字段是否是显示状态。</p><h4 id="onPageChange"><a href="#onPageChange" class="headerlink" title="onPageChange　　"></a><code>onPageChange</code>　　</h4><p>换页时触发事件，参数有number和size，分别代表跳转后位于第几页且页面内有多少条记录</p><h4 id="onSearch"><a href="#onSearch" class="headerlink" title="onSearch　　"></a><code>onSearch</code>　　</h4><p>使用bs-table自带搜索框进行搜索时触发事件，参数是text即搜索关键文</p><h4 id="onRefresh"><a href="#onRefresh" class="headerlink" title="onRefresh　　"></a><code>onRefresh</code>　　</h4><p>刷新表格数据是触发的事件，参数params是一个挺复杂的对象，包含了此次刷新的一些信息。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> Bootstrap </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bootstrap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL相关命令及SQL语句整理</title>
      <link href="/2020/01/19/mysql-konwledge/"/>
      <url>/2020/01/19/mysql-konwledge/</url>
      
        <content type="html"><![CDATA[<p>MySQL相关命令及SQL语句整理。内容过多，请使用目录功能查看。</p><a id="more"></a><h1 id="命令相关"><a href="#命令相关" class="headerlink" title="命令相关"></a>命令相关</h1><h2 id="linux命令"><a href="#linux命令" class="headerlink" title="linux命令"></a>linux命令</h2><h3 id="启动MySQL"><a href="#启动MySQL" class="headerlink" title="启动MySQL"></a>启动MySQL</h3><pre><code class="sql">net start mysql</code></pre><h3 id="创建Windows服务"><a href="#创建Windows服务" class="headerlink" title="创建Windows服务"></a>创建Windows服务</h3><pre><code class="sql"> sc create mysql binPath= mysqld_bin_path(注意：等号与值之间有空格)</code></pre><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><pre><code class="sql">mysql -h 地址 -P 端口 -u 用户名 -p 密码</code></pre><h3 id="显示哪些线程正在运行"><a href="#显示哪些线程正在运行" class="headerlink" title="显示哪些线程正在运行"></a>显示哪些线程正在运行</h3><pre><code class="sql">SHOW PROCESSLIST</code></pre><h3 id="显示系统变量信息"><a href="#显示系统变量信息" class="headerlink" title="显示系统变量信息"></a>显示系统变量信息</h3><pre><code class="sql">SHOW VARIABLES</code></pre><h3 id="root密码重置"><a href="#root密码重置" class="headerlink" title="root密码重置"></a>root密码重置</h3><p>停止MySQL服务<br>[Linux] <code>/usr/local/mysql/bin/safe_mysqld --skip-grant-tables &amp;</code><br>[Windows] <code>mysqld --skip-grant-tables</code></p><pre><code class="sql">use mysql;UPDATE `user` SET PASSWORD=PASSWORD(&quot;密码&quot;) WHERE `user` = &quot;root&quot;;FLUSH PRIVILEGES;</code></pre><h1 id="SQL相关"><a href="#SQL相关" class="headerlink" title="SQL相关"></a>SQL相关</h1><h2 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h2><h3 id="查看当前数据库"><a href="#查看当前数据库" class="headerlink" title="查看当前数据库"></a>查看当前数据库</h3><pre><code class="sql"> SELECT DATABASE();</code></pre><h3 id="显示当前时间、用户名、数据库版本"><a href="#显示当前时间、用户名、数据库版本" class="headerlink" title="显示当前时间、用户名、数据库版本"></a>显示当前时间、用户名、数据库版本</h3><pre><code class="sql">SELECT now(), user(), version();</code></pre><h3 id="创建库"><a href="#创建库" class="headerlink" title="创建库"></a>创建库</h3><pre><code class="sql">CREATE DATABASE[ IF NOT EXISTS] 数据库名 数据库选项</code></pre><p>数据库选项：</p><ul><li>CHARACTER SET charset_name</li><li>COLLATE collation_name</li></ul><h3 id="查看已有库"><a href="#查看已有库" class="headerlink" title="查看已有库"></a>查看已有库</h3><pre><code class="sql">SHOW DATABASES[ LIKE &#39;PATTERN&#39;]</code></pre><h3 id="查看当前库信息"><a href="#查看当前库信息" class="headerlink" title="查看当前库信息"></a>查看当前库信息</h3><pre><code class="sql">SHOW CREATE DATABASE 数据库名</code></pre><h3 id="修改库的选项信息"><a href="#修改库的选项信息" class="headerlink" title="修改库的选项信息"></a>修改库的选项信息</h3><pre><code class="sql">ALTER DATABASE 库名 选项信息</code></pre><h3 id="删除库"><a href="#删除库" class="headerlink" title="删除库"></a>删除库</h3><p>同时删除该数据库相关的目录及其目录内容</p><pre><code class="sql">DROP DATABASE[ IF EXISTS] 数据库名</code></pre><h2 id="表的操作"><a href="#表的操作" class="headerlink" title="表的操作"></a>表的操作</h2><h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><pre><code class="sql">CREATE [TEMPORARY] TABLE[ IF NOT EXISTS] [库名.]表名 ( 表的结构定义 )[ 表选项]</code></pre><ul><li>每个字段必须有数据类型</li><li>最后一个字段后不能有逗号</li><li><code>TEMPORARY</code> 临时表，会话结束时表自动消失</li></ul><p>对于字段的定义：</p><ul><li>字段名 数据类型 </li><li>[NOT NULL | NULL] </li><li>[DEFAULT default_value] </li><li>[AUTO_INCREMENT] </li><li>[UNIQUE [KEY] | [PRIMARY] KEY] </li><li>[COMMENT ‘string’]</li></ul><h4 id="表选项"><a href="#表选项" class="headerlink" title="表选项"></a>表选项</h4><ul><li>字符集<code>CHARSET = charset_name</code>如果表没有设定，则使用数据库字符集</li><li>存储引擎<ul><li><code>ENGINE = engine_name</code></li><li>表在管理数据时采用的不同的数据结构，结构不同会导致处理方式、提供的特性操作等不同</li><li>常见的引擎：<code>InnoDB MyISAM Memory</code>/<code>Heap BDB Merge Example CSV MaxDB Archive</code></li><li>不同的引擎在保存表的结构和数据时采用不同的方式</li><li><code>MyISAM</code>表文件含义：<code>.frm</code>表定义，<code>.MYD</code>表数据，<code>.MYI</code>表索引</li><li><code>InnoDB</code>表文件含义：<code>.frm</code>表定义，表空间数据和日志文件</li><li><code>SHOW ENGINES</code>： 显示存储引擎的状态信息</li><li><code>SHOW ENGINE</code>：引擎名 </li><li><code>{LOGS|STATUS}</code>：显示存储引擎的日志或状态信息</li></ul></li><li>自增起始数  <code>AUTO_INCREMENT</code> = 行数</li><li>数据文件目录  <code>DATA DIRECTORY</code> = ‘目录’</li><li>索引文件目录  <code>INDEX DIRECTORY</code>= ‘目录’</li><li>表注释  <code>COMMENT</code> = ‘string’</li><li>分区选项  <code>PARTITION BY</code> … (详细见手册)</li></ul><h3 id="查看所有表"><a href="#查看所有表" class="headerlink" title="查看所有表"></a>查看所有表</h3><pre><code class="sql">SHOW TABLES[ LIKE &#39;pattern&#39;]SHOW TABLES FROM 表名</code></pre><h3 id="查看表机构"><a href="#查看表机构" class="headerlink" title="查看表机构"></a>查看表机构</h3><pre><code class="sql">SHOW CREATE TABLE 表名 （信息更详细）DESC 表名 / DESCRIBE 表名 / EXPLAIN 表名 / SHOW COLUMNS FROM 表名 [LIKE &#39;PATTERN&#39;]SHOW TABLE STATUS [FROM db_name] [LIKE &#39;pattern&#39;]</code></pre><h3 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h3><h4 id="修改表本身的选项"><a href="#修改表本身的选项" class="headerlink" title="修改表本身的选项"></a>修改表本身的选项</h4><pre><code class="sql">ALTER TABLE 表名 表的选项eg: ALTER TABLE 表名 ENGINE=MYISAM;</code></pre><h4 id="对表进行重命名"><a href="#对表进行重命名" class="headerlink" title="对表进行重命名"></a>对表进行重命名</h4><pre><code class="sql">RENAME TABLE 原表名 TO 新表名        RENAME TABLE 原表名 TO 库名.表名 （可将表移动到另一个数据库）</code></pre><p><code>RENAME</code>可以交换两个表名</p><h4 id="修改表的字段机构（13-1-2-ALTER-TABLE语法）"><a href="#修改表的字段机构（13-1-2-ALTER-TABLE语法）" class="headerlink" title="修改表的字段机构（13.1.2. ALTER TABLE语法）"></a>修改表的字段机构（13.1.2. ALTER TABLE语法）</h4><pre><code class="sql">ALTER TABLE 表名 操作名</code></pre><p>操作名</p><ul><li><code>ADD[ COLUMN]</code> 字段定义:增加字段</li><li><code>AFTER</code> 字段名:表示增加在该字段名后面</li><li><code>FIRST</code>:表示增加在第一个</li><li><code>ADD PRIMARY KEY(字段名)</code>:创建主键</li><li><code>ADD UNIQUE [索引名] (字段名)</code>:创建唯一索引</li><li><code>ADD INDEX [索引名] (字段名)</code>:创建普通索引</li><li><code>DROP[ COLUMN] 字段名</code>:删除字段</li><li><code>MODIFY[ COLUMN] 字段名 字段属性</code>:支持对字段属性进行修改，不能修改字段名(所有原有属性也需写上)</li><li><code>CHANGE[ COLUMN] 原字段名 新字段名 字段属性</code>:支持对字段名修改</li><li><code>DROP PRIMARY KEY</code>:删除主键(删除主键前需删除其AUTO_INCREMENT属性)</li><li><code>DROP INDEX 索引名</code>:删除索引</li><li><code>DROP FOREIGN KEY 外键</code>:删除外键</li></ul><h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h3><pre><code class="sql">DROP TABLE[ IF EXISTS] 表名 ...</code></pre><h3 id="清空表数据"><a href="#清空表数据" class="headerlink" title="清空表数据"></a>清空表数据</h3><pre><code class="sql">TRUNCATE [TABLE] 表名</code></pre><h3 id="复制表结构"><a href="#复制表结构" class="headerlink" title="复制表结构"></a>复制表结构</h3><pre><code class="sql">CREATE TABLE 表名 LIKE 要复制的表名</code></pre><h3 id="复制表结构和数据"><a href="#复制表结构和数据" class="headerlink" title="复制表结构和数据"></a>复制表结构和数据</h3><pre><code class="sql">CREATE TABLE 表名 [AS] SELECT * FROM 要复制的表名</code></pre><h3 id="检查表是否有错误"><a href="#检查表是否有错误" class="headerlink" title="检查表是否有错误"></a>检查表是否有错误</h3><pre><code class="sql">CHECK TABLE tbl_name [, tbl_name] ... [option] ...</code></pre><h3 id="优化表"><a href="#优化表" class="headerlink" title="优化表"></a>优化表</h3><pre><code class="sql">OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...</code></pre><h3 id="修复表"><a href="#修复表" class="headerlink" title="修复表"></a>修复表</h3><pre><code class="sql">REPAIR [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ... [QUICK] [EXTENDED] [USE_FRM]</code></pre><h3 id="分析表"><a href="#分析表" class="headerlink" title="分析表"></a>分析表</h3><pre><code class="sql">ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...</code></pre><h2 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h2><h3 id="增"><a href="#增" class="headerlink" title="增"></a>增</h3><pre><code class="sql"> INSERT [INTO] 表名 [(字段列表)] VALUES (值列表)[, (值列表), ...] INSERT [INTO] 表名 SET 字段名=值[, 字段名=值, ...]</code></pre><ul><li>如果要插入的值列表包含所有字段并且顺序一致，则可以省略字段列表。</li><li>可同时插入多条数据记录！</li><li><code>REPLACE</code> 与 <code>INSERT</code> 完全一样，可互换。</li></ul><h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><p>没有条件子句，则会删除全部</p><pre><code class="sql">DELETE FROM 表名[ 删除条件子句]</code></pre><h3 id="改"><a href="#改" class="headerlink" title="改"></a>改</h3><pre><code class="sql">UPDATE 表名 SET 字段名=新值[, 字段名=新值] [更新条件]</code></pre><h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><pre><code class="sql">SELECT 字段列表 FROM 表名[ 其他子句]</code></pre><ul><li>可来自多个表的多个字段</li><li>其他子句可以不使用</li><li>字段列表可以用*代替，表示所有字段</li></ul><h2 id="字符集编码"><a href="#字符集编码" class="headerlink" title="字符集编码"></a>字符集编码</h2><p>MySQL、数据库、表、字段均可设置编码。数据编码与客户端编码不需一致。</p><h3 id="查看所有字符集编码项"><a href="#查看所有字符集编码项" class="headerlink" title="查看所有字符集编码项"></a>查看所有字符集编码项</h3><pre><code class="sql">SHOW VARIABLES LIKE &#39;character_set_%&#39;</code></pre><ul><li><code>character_set_client</code> ：客户端向服务器发送数据时使用的编码</li><li><code>character_set_results</code>：服务器端将结果返回给客户端所使用的编码</li><li><code>character_set_connection</code>：连接层编码</li></ul><pre><code class="sql">SET 变量名 = 变量值SET character_set_client = gbk;SET character_set_results = gbk;SET character_set_connection = gbk;SET NAMES GBK;  -- 相当于完成以上三个设置</code></pre><h3 id="字符集编码-1"><a href="#字符集编码-1" class="headerlink" title="字符集编码"></a>字符集编码</h3><h4 id="校对集"><a href="#校对集" class="headerlink" title="校对集"></a>校对集</h4><p>校对集用以排序</p><pre><code class="sql">SHOW CHARACTER SET [LIKE &#39;pattern&#39;]/SHOW CHARSET [LIKE &#39;pattern&#39;]   查看所有字符集SHOW COLLATION [LIKE &#39;pattern&#39;]     查看所有校对集</code></pre><ul><li><code>CHARSET 字符集编码</code>：设置字符集编码</li><li><code>COLLATE 校对集编码</code>：设置校对集编码</li></ul><h2 id="数据类型（列类型）"><a href="#数据类型（列类型）" class="headerlink" title="数据类型（列类型）"></a>数据类型（列类型）</h2><h3 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h3><h4 id="a-整型"><a href="#a-整型" class="headerlink" title="a. 整型"></a>a. 整型</h4><table><thead><tr><th align="center">-</th><th align="center">类型</th><th align="center">字节</th><th align="center">范围（有符号位）</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">tinyint</td><td align="center">1字节</td><td align="center">-128 ~ 127 无符号位：0 ~ 255</td></tr><tr><td align="center">2</td><td align="center">smallint</td><td align="center">2字节</td><td align="center">-32768 ~ 32767</td></tr><tr><td align="center">3</td><td align="center">mediumint</td><td align="center">3字节</td><td align="center">-8388608 ~ 8388607</td></tr><tr><td align="center">4</td><td align="center">int</td><td align="center">4字节</td><td align="center"></td></tr><tr><td align="center">5</td><td align="center">bigint</td><td align="center">8字节</td><td align="center"></td></tr></tbody></table><p><code>int(M)</code>M表示总位数</p><ul><li>默认存在符号位，unsigned 属性修改</li><li>显示宽度，如果某个数不够定义字段时设置的位数，则前面以0补填，zerofill 属性修改。例：int(5)   插入一个数’123’，补填后为’00123’</li><li>在满足要求的情况下，越小越好。</li><li>1：表示bool值真，0：表示bool值假。MySQL没有布尔类型，通过整型0和1表示。常用<code>tinyint(1)</code>表示布尔型。</li></ul><h4 id="b-浮点型"><a href="#b-浮点型" class="headerlink" title="b. 浮点型"></a>b. 浮点型</h4><table><thead><tr><th align="center">-</th><th align="center">类型</th><th align="center">字节</th><th align="center">范围</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">float(单精度)</td><td align="center">4字节</td><td align="center"></td></tr><tr><td align="center">2</td><td align="center">double(双精度)</td><td align="center">8字节</td><td align="center"></td></tr></tbody></table><ul><li>浮点型既支持符号位 unsigned 属性，也支持显示宽度 zerofill 属性。不同于整型，前后均会补填0.</li><li>定义浮点型时，需指定总位数和小数位数。</li></ul><p>float(M, D)，double(M, D)</p><ul><li><code>M</code>表示总位数，<code>D</code>表示小数位数。</li><li><code>M</code>和<code>D</code>的大小会决定浮点数的范围。不同于整型的固定范围。</li><li><code>M</code>既表示总位数（不包括小数点和正负号），也表示显示宽度（所有显示符号均包括）。</li><li>支持科学计数法表示。</li><li>浮点数表示近似值。</li></ul><h4 id="c-定点数"><a href="#c-定点数" class="headerlink" title="c. 定点数"></a>c. 定点数</h4><ul><li><code>decimal</code>：可变长度</li><li><code>decimal(M, D)</code>：<code>M</code>也表示总位数，<code>D</code>表示小数位数。</li><li>保存一个精确的数值，不会发生数据的改变，不同于浮点数的四舍五入。</li><li>将浮点数转换为字符串来保存，每9位数字保存为4个字节。</li></ul><h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h3><h4 id="a-char-varchar"><a href="#a-char-varchar" class="headerlink" title="a. char, varchar"></a>a. char, varchar</h4><ul><li><code>char</code>定长字符串，速度快，但浪费空间</li><li><code>varchar</code>变长字符串，速度慢，但节省空间</li><li><code>M</code>表示能存储的最大长度，此长度是字符数，非字节数。不同的编码，所占用的空间不同。</li><li><code>char</code>最多255个字符，与编码无关。</li><li><code>varchar</code>最多65535字符，与编码有关。一条有效记录最大不能超过65535个字节。</li><li><code>utf8</code> 最大为21844个字符，<code>gbk</code> 最大为32766个字符，<code>latin1</code> 最大为65532个字符</li><li><code>varchar</code> 是变长的，需要利用存储空间保存 varchar 的长度，如果数据小于255个字节，则采用一个字节来保存长度，反之需要两个字节来保存。</li><li><code>varchar</code> 的最大有效长度由最大行大小和使用的字符集确定。</li><li>最大有效长度是65532字节，因为在<code>varchar</code>存字符串时，第一个字节是空的，不存在任何数据，然后还需两个字节来存放字符串的长度，所以有效长度是64432-1-2=65532字节。</li></ul><p>例：若一个表定义为 CREATE TABLE tb(c1 int, c2 char(30), c3 varchar(N)) charset=utf8; 问N的最大值是多少？ 答：(65535-1-2-4-30*3)/3</p><h4 id="b-blob-text"><a href="#b-blob-text" class="headerlink" title="b. blob, text"></a>b. blob, text</h4><ul><li><code>blob</code>二进制字符串（字节字符串）： <code>tinyblob</code>, <code>blob</code>, <code>mediumblob</code>, <code>longblob</code></li><li><code>text</code>非二进制字符串（字符字符串）： <code>tinytext</code>, <code>text</code>, <code>mediumtext</code>, <code>longtext</code><ul><li><code>text</code>在定义时，不需要定义长度，也不会计算总长度。</li><li><code>text</code>类型在定义时，不可给<code>default</code>值</li></ul></li></ul><h4 id="c-binary-varbinary"><a href="#c-binary-varbinary" class="headerlink" title="c. binary, varbinary"></a>c. binary, varbinary</h4><p>类似于<code>char</code>和<code>varchar</code>，用于保存二进制字符串，也就是保存字节字符串而非字符字符串。<br><code>char</code>,<code>varchar</code>, <code>text</code> 对应 <code>binary</code>, <code>varbinary</code>, <code>blob</code>.</p><h3 id="日期时间类型"><a href="#日期时间类型" class="headerlink" title="日期时间类型"></a>日期时间类型</h3><p>一般用整型保存时间戳，因为PHP可以很方便的将时间戳进行格式化。</p><table><thead><tr><th align="center">-</th><th align="center">类型</th><th align="center">字节</th><th align="center">日期格式</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">datetime</td><td align="center">8字节</td><td align="center">日期及时间</td><td align="center">1000-01-01 00:00:00 到 9999-12-31 23:59:59</td></tr><tr><td align="center">2</td><td align="center">date</td><td align="center">3字节</td><td align="center">日期</td><td align="center">1000-01-01 到 9999-12-31</td></tr><tr><td align="center">3</td><td align="center">timestamp</td><td align="center">4字节</td><td align="center">时间戳</td><td align="center">19700101000000 到 2038-01-19 03:14:07</td></tr><tr><td align="center">4</td><td align="center">time</td><td align="center">3字节</td><td align="center">时间</td><td align="center">-838:59:59 到 838:59:59</td></tr><tr><td align="center">5</td><td align="center">year</td><td align="center">1字节</td><td align="center">年份</td><td align="center">1901 - 2155</td></tr></tbody></table><p>datetime</p><ul><li>YYYY-MM-DD hh:mm:ss</li></ul><p>timestamp   </p><ul><li>YY-MM-DD hh:mm:ss</li><li>YYYYMMDDhhmmss</li><li>YYMMDDhhmmss</li><li>YYYYMMDDhhmmss</li><li>YYMMDDhhmmss</li></ul><p>date        </p><ul><li>YYYY-MM-DD</li><li>YY-MM-DD</li><li>YYYYMMDD</li><li>YYMMDD</li><li>YYYYMMDD</li><li>YYMMDD</li></ul><p>time        </p><ul><li>hh:mm:ss</li><li>hhmmss</li><li>hhmmss</li></ul><p>year        </p><ul><li>YYYY</li><li>YY</li><li>YYYY</li><li>YY<h3 id="枚举和集合"><a href="#枚举和集合" class="headerlink" title="枚举和集合"></a>枚举和集合</h3><pre><code class="sql"></code></pre></li></ul><pre><code>### 枚举和集合``` sqlenum(val1, val2, val3...)</code></pre><ul><li>在已知的值中进行单选。最大数量为65535.</li><li>枚举值在保存时，以2个字节的整型(smallint)保存。每个枚举值，按保存的位置顺序，从1开始逐一递增。</li><li>表现为字符串类型，存储却是整型。</li><li>NULL值的索引是NULL。</li><li>空字符串错误值的索引值是0。</li></ul><h3 id="集合（set）"><a href="#集合（set）" class="headerlink" title="集合（set）"></a>集合（set）</h3><pre><code class="sql">set(val1, val2, val3...) create table tab ( gender set(&#39;男&#39;, &#39;女&#39;, &#39;无&#39;) );    insert into tab values (&#39;男, 女&#39;);</code></pre><ul><li>最多可以有64个不同的成员。以bigint存储，共8个字节。采取位运算的形式。</li><li>当创建表时，SET成员值的尾部空格将自动被删除。</li></ul><h3 id="选择类型"><a href="#选择类型" class="headerlink" title="选择类型"></a>选择类型</h3><h4 id="PHP角度"><a href="#PHP角度" class="headerlink" title="PHP角度"></a>PHP角度</h4><ul><li>功能满足</li><li>存储空间尽量小，处理效率更高</li><li>考虑兼容问题</li></ul><h4 id="IP存储"><a href="#IP存储" class="headerlink" title="IP存储"></a>IP存储</h4><ul><li>只需存储，可用字符串</li><li>如果需计算，查找等，可存储为4个字节的无符号int，即unsigned<ul><li>PHP函数转换<ul><li>ip2long可转换为整型，但会出现携带符号问题。需格式化为无符号的整型。</li><li>利用sprintf函数格式化字符串</li><li>sprintf(“%u”, ip2long(‘192.168.3.134’));</li><li>然后用long2ip将整型转回IP字符串</li></ul></li><li>MySQL函数转换(无符号整型，UNSIGNED)<ul><li>INET_ATON(‘127.0.0.1’) 将IP转为整型</li><li>INET_NTOA(2130706433) 将整型转为IP</li></ul></li></ul></li></ul><p>/* 列属性（列约束） */ ——————</p><ol><li><p>PRIMARY 主键</p><ul><li>能唯一标识记录的字段，可以作为主键。</li><li>一个表只能有一个主键。</li><li>主键具有唯一性。</li><li>声明字段时，用 primary key 标识。<br>  也可以在字段列表之后声明<pre><code>  例：create table tab ( id int, stu varchar(10), primary key (id));</code></pre></li><li>主键字段的值不能为null。</li><li>主键可以由多个字段共同组成。此时需要在字段列表后声明的方法。<br>  例：create table tab ( id int, stu varchar(10), age int, primary key (stu, age));</li></ul></li><li><p>UNIQUE 唯一索引（唯一约束）<br> 使得某字段的值也不能重复。</p></li><li><p>NULL 约束<br> null不是数据类型，是列的一个属性。<br> 表示当前列是否可以为null，表示什么都没有。<br> null, 允许为空。默认。<br> not null, 不允许为空。<br> insert into tab values (null, ‘val’);</p><pre><code> -- 此时表示将第一个字段的值设为null, 取决于该字段是否允许为null</code></pre></li><li><p>DEFAULT 默认值属性<br> 当前字段的默认值。<br> insert into tab values (default, ‘val’);    – 此时表示强制使用默认值。<br> create table tab ( add_time timestamp default current_timestamp );</p><pre><code> -- 表示将当前时间的时间戳设为默认值。 current_date, current_time</code></pre></li><li><p>AUTO_INCREMENT 自动增长约束<br> 自动增长必须为索引（主键或unique）<br> 只能存在一个字段为自动增长。<br> 默认为1开始自动增长。可以通过表属性 auto_increment = x进行设置，或 alter table tbl auto_increment = x;</p></li><li><p>COMMENT 注释<br> 例：create table tab ( id int ) comment ‘注释内容’;</p></li><li><p>FOREIGN KEY 外键约束<br> 用于限制主表与从表数据完整性。<br> alter table t1 add constraint <code>t1_t2_fk</code> foreign key (t1_id) references t2(id);</p><pre><code> -- 将表t1的t1_id外键关联到表t2的id字段。 -- 每个外键都有一个名字，可以通过 constraint 指定</code></pre><p> 存在外键的表，称之为从表（子表），外键指向的表，称之为主表（父表）。</p><p> 作用：保持数据一致性，完整性，主要目的是控制存储在外键表（从表）中的数据。</p><p> MySQL中，可以对InnoDB引擎使用外键约束：<br> 语法：<br> foreign key (外键字段） references 主表名 (关联字段) [主表记录删除时的动作] [主表记录更新时的动作]<br> 此时需要检测一个从表的外键需要约束为主表的已存在的值。外键在没有关联的情况下，可以设置为null.前提是该外键列，没有not null。</p><p> 可以不指定主表记录更改或更新时的动作，那么此时主表的操作被拒绝。<br> 如果指定了 on update 或 on delete：在删除或更新时，有如下几个操作可以选择：</p><ol><li><p>cascade，级联操作。主表数据被更新（主键值更新），从表也被更新（外键值更新）。主表记录被删除，从表相关记录也被删除。</p></li><li><p>set null，设置为null。主表数据被更新（主键值更新），从表的外键被设置为null。主表记录被删除，从表相关记录外键被设置成null。但注意，要求该外键列，没有not null属性约束。</p></li><li><p>restrict，拒绝父表删除和更新。</p><p>注意，外键只被InnoDB存储引擎所支持。其他引擎是不支持的。</p></li></ol></li></ol><p>/* 建表规范 */ ——————<br>    – Normal Format, NF<br>        - 每个表保存一个实体信息<br>        - 每个具有一个ID字段作为主键<br>        - ID主键 + 原子表<br>    – 1NF, 第一范式<br>        字段不能再分，就满足第一范式。<br>    – 2NF, 第二范式<br>        满足第一范式的前提下，不能出现部分依赖。<br>        消除符合主键就可以避免部分依赖。增加单列关键字。<br>    – 3NF, 第三范式<br>        满足第二范式的前提下，不能出现传递依赖。<br>        某个字段依赖于主键，而有其他字段依赖于该字段。这就是传递依赖。<br>        将一个实体信息的数据放在一个表内实现。</p><p>/* SELECT */ ——————</p><pre><code class="sql"></code></pre><p>SELECT [ALL|DISTINCT] select_expr FROM -&gt; WHERE -&gt; GROUP BY [合计函数] -&gt; HAVING -&gt; ORDER BY -&gt; LIMIT</p><p>a. select_expr<br>    – 可以用 * 表示所有字段。<br>        select * from tb;<br>    – 可以使用表达式（计算公式、函数调用、字段也是个表达式）<br>        select stu, 29+25, now() from tb;<br>    – 可以为每个列使用别名。适用于简化列标识，避免多个列标识符重复。<br>        - 使用 as 关键字，也可省略 as.<br>        select stu+10 as add10 from tb;</p><p>b. FROM 子句<br>    用于标识查询来源。<br>    – 可以为表起别名。使用as关键字。<br>        SELECT * FROM tb1 AS tt, tb2 AS bb;<br>    – from子句后，可以同时出现多个表。<br>        – 多个表会横向叠加到一起，而数据会形成一个笛卡尔积。<br>        SELECT * FROM tb1, tb2;<br>    – 向优化符提示如何选择索引<br>        USE INDEX、IGNORE INDEX、FORCE INDEX<br>        SELECT * FROM table1 USE INDEX (key1,key2) WHERE key1=1 AND key2=2 AND key3=3;<br>        SELECT * FROM table1 IGNORE INDEX (key3) WHERE key1=1 AND key2=2 AND key3=3;</p><p>c. WHERE 子句<br>    – 从from获得的数据源中进行筛选。<br>    – 整型1表示真，0表示假。<br>    – 表达式由运算符和运算数组成。<br>        – 运算数：变量（字段）、值、函数返回值<br>        – 运算符：<br>            =, &lt;=&gt;, &lt;&gt;, !=, &lt;=, &lt;, &gt;=, &gt;, !, &amp;&amp;, ||,<br>            in (not) null, (not) like, (not) in, (not) between and, is (not), and, or, not, xor<br>            is/is not 加上ture/false/unknown，检验某个值的真假<br>            &lt;=&gt;与&lt;&gt;功能相同，&lt;=&gt;可用于null比较</p><p>d. GROUP BY 子句, 分组子句<br>    GROUP BY 字段/别名 [排序方式]<br>    分组后会进行排序。升序：ASC，降序：DESC</p><pre><code>以下[合计函数]需配合 GROUP BY 使用：count 返回不同的非NULL值数目  count(*)、count(字段)sum 求和max 求最大值min 求最小值avg 求平均值group_concat 返回带有来自一个组的连接的非NULL值的字符串结果。组内字符串连接。</code></pre><p>e. HAVING 子句，条件子句<br>    与 where 功能、用法相同，执行时机不同。<br>    where 在开始时执行检测数据，对原数据进行过滤。<br>    having 对筛选出的结果再次进行过滤。<br>    having 字段必须是查询出来的，where 字段必须是数据表存在的。<br>    where 不可以使用字段的别名，having 可以。因为执行WHERE代码时，可能尚未确定列值。<br>    where 不可以使用合计函数。一般需用合计函数才会用 having<br>    SQL标准要求HAVING必须引用GROUP BY子句中的列或用于合计函数中的列。</p><p>f. ORDER BY 子句，排序子句<br>    order by 排序字段/别名 排序方式 [,排序字段/别名 排序方式]…<br>    升序：ASC，降序：DESC<br>    支持多个字段的排序。</p><p>g. LIMIT 子句，限制结果数量子句<br>    仅对处理好的结果进行数量限制。将处理好的结果的看作是一个集合，按照记录出现的顺序，索引从0开始。<br>    limit 起始位置, 获取条数<br>    省略第一个参数，表示从索引0开始。limit 获取条数</p><p>h. DISTINCT, ALL 选项<br>    distinct 去除重复记录<br>    默认为 all, 全部记录</p><p>/* UNION */ ——————<br>    将多个select查询的结果组合成一个结果集合。<br>    SELECT … UNION [ALL|DISTINCT] SELECT …<br>    默认 DISTINCT 方式，即所有返回的行都是唯一的<br>    建议，对每个SELECT查询加上小括号包裹。<br>    ORDER BY 排序时，需加上 LIMIT 进行结合。<br>    需要各select查询的字段数量一样。<br>    每个select查询的字段列表(数量、类型)应一致，因为结果中的字段名以第一条select语句为准。</p><p>/* 子查询 */ ——————<br>    - 子查询需用括号包裹。<br>– from型<br>    from后要求是一个表，必须给子查询结果取个别名。<br>    - 简化每个查询内的条件。<br>    - from型需将结果生成一个临时表格，可用以原表的锁定的释放。<br>    - 子查询返回一个表，表型子查询。<br>    select * from (select * from tb where id&gt;0) as subfrom where id&gt;1;<br>– where型<br>    - 子查询返回一个值，标量子查询。<br>    - 不需要给子查询取别名。<br>    - where子查询内的表，不能直接用以更新。<br>    select * from tb where money = (select max(money) from tb);<br>    – 列子查询<br>        如果子查询结果返回的是一列。<br>        使用 in 或 not in 完成查询<br>        exists 和 not exists 条件<br>            如果子查询返回数据，则返回1或0。常用于判断条件。<br>            select column1 from t1 where exists (select * from t2);<br>    – 行子查询<br>        查询条件是一个行。<br>        select * from t1 where (id, gender) in (select id, gender from t2);<br>        行构造符：(col1, col2, …) 或 ROW(col1, col2, …)<br>        行构造符通常用于与对能返回两个或两个以上列的子查询进行比较。</p><pre><code>-- 特殊运算符!= all()    相当于 not in= some()    相当于 in。any 是 some 的别名!= some()   不等同于 not in，不等于其中某一个。all, some 可以配合其他运算符一起使用。</code></pre><p>/* 连接查询(join) */ ——————<br>    将多个表的字段进行连接，可以指定连接条件。<br>– 内连接(inner join)<br>    - 默认就是内连接，可省略inner。<br>    - 只有数据存在时才能发送连接。即连接结果不能出现空行。<br>    on 表示连接条件。其条件表达式与where类似。也可以省略条件（表示条件永远为真）<br>    也可用where表示连接条件。<br>    还有 using, 但需字段名相同。 using(字段名)</p><pre><code>-- 交叉连接 cross join    即，没有条件的内连接。    select * from tb1 cross join tb2;</code></pre><p>– 外连接(outer join)<br>    - 如果数据不存在，也会出现在连接结果中。<br>    – 左外连接 left join<br>        如果数据不存在，左表记录会出现，而右表为null填充<br>    – 右外连接 right join<br>        如果数据不存在，右表记录会出现，而左表为null填充<br>– 自然连接(natural join)<br>    自动判断连接条件完成连接。<br>    相当于省略了using，会自动查找相同字段名。<br>    natural join<br>    natural left join<br>    natural right join</p><pre><code class="sql"></code></pre><p>select info.id, info.name, info.stu_num, extra_info.hobby, extra_info.sex from info, extra_info where info.stu_num = extra_info.stu_id;</p><h2 id="导入导出"><a href="#导入导出" class="headerlink" title="导入导出"></a>导入导出</h2><p>/* 导入导出 */ ——————</p><pre><code class="sql"></code></pre><p>select * into outfile 文件地址 [控制格式] from 表名;   – 导出表数据<br>load data [local] infile 文件地址 [replace|ignore] into table 表名 [控制格式]; – 导入数据<br>    生成的数据默认的分隔符是制表符<br>    local未指定，则数据文件必须在服务器上<br>    replace 和 ignore 关键词控制对现有的唯一键记录的重复的处理<br>– 控制格式<br>fields  控制字段格式<br>默认：fields terminated by ‘\t’ enclosed by ‘’ escaped by ‘\‘<br>    terminated by ‘string’  – 终止<br>    enclosed by ‘char’      – 包裹<br>    escaped by ‘char’       – 转义<br>    – 示例：<br>        SELECT a,b,a+b INTO OUTFILE ‘/tmp/result.text’<br>        FIELDS TERMINATED BY ‘,’ OPTIONALLY ENCLOSED BY ‘“‘<br>        LINES TERMINATED BY ‘\n’<br>        FROM test_table;<br>lines   控制行格式<br>默认：lines terminated by ‘\n’<br>    terminated by ‘string’  – 终止</p><p>/* INSERT */ ——————</p><pre><code class="sql"></code></pre><p>select语句获得的数据可以用insert插入。</p><p>可以省略对列的指定，要求 values () 括号内，提供给了按照列顺序出现的所有字段的值。<br>    或者使用set语法。<br>    INSERT INTO tbl_name SET field=value,…；</p><p>可以一次性使用多个值，采用(), (), ();的形式。<br>    INSERT INTO tbl_name VALUES (), (), ();</p><p>可以在列值指定时，使用表达式。<br>    INSERT INTO tbl_name VALUES (field_value, 10+10, now());<br>可以使用一个特殊值 DEFAULT，表示该列使用默认值。<br>    INSERT INTO tbl_name VALUES (field_value, DEFAULT);</p><p>可以通过一个查询的结果，作为需要插入的值。<br>    INSERT INTO tbl_name SELECT …;</p><p>可以指定在插入的值出现主键（或唯一索引）冲突时，更新其他非主键列的信息。<br>    INSERT INTO tbl_name VALUES/SET/SELECT ON DUPLICATE KEY UPDATE 字段=值, …;</p><p>/* DELETE */ ——————</p><pre><code class="sql"></code></pre><p>DELETE FROM tbl_name [WHERE where_definition] [ORDER BY …] [LIMIT row_count]</p><p>按照条件删除。where</p><p>指定删除的最多记录数。limit</p><p>可以通过排序条件删除。order by + limit</p><p>支持多表删除，使用类似连接语法。<br>delete from 需要删除数据多表1，表2 using 表连接操作 条件。</p><p>/* TRUNCATE */ ——————</p><pre><code class="sql"></code></pre><p>TRUNCATE [TABLE] tbl_name<br>清空数据<br>删除重建表</p><p>区别：<br>1，truncate 是删除表再创建，delete 是逐条删除<br>2，truncate 重置auto_increment的值。而delete不会<br>3，truncate 不知道删除了几条，而delete知道。<br>4，当被用于带分区的表时，truncate 会保留分区</p><p>/* 备份与还原 */ ——————</p><pre><code class="sql"></code></pre><p>备份，将数据的结构与表内数据保存起来。<br>利用 mysqldump 指令完成。</p><p>– 导出<br>mysqldump [options] db_name [tables]<br>mysqldump [options] —database DB1 [DB2 DB3…]<br>mysqldump [options] –all–database</p><ol><li>导出一张表<br>　　mysqldump -u用户名 -p密码 库名 表名 &gt; 文件名(D:/a.sql)</li><li>导出多张表<br>　　mysqldump -u用户名 -p密码 库名 表1 表2 表3 &gt; 文件名(D:/a.sql)</li><li>导出所有表<br>　　mysqldump -u用户名 -p密码 库名 &gt; 文件名(D:/a.sql)</li><li>导出一个库<br>　　mysqldump -u用户名 -p密码 –lock-all-tables –database 库名 &gt; 文件名(D:/a.sql)</li></ol><p>可以-w携带WHERE条件</p><p>– 导入</p><ol><li>在登录mysql的情况下：<br>　　source  备份文件</li><li>在不登录的情况下<br>　　mysql -u用户名 -p密码 库名 &lt; 备份文件</li></ol><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>/* 视图 */ ——————<br>什么是视图：<br>    视图是一个虚拟表，其内容由查询定义。同真实的表一样，视图包含一系列带有名称的列和行数据。但是，视图并不在数据库中以存储的数据值集形式存在。行和列数据来自由定义视图的查询所引用的表，并且在引用视图时动态生成。<br>    视图具有表结构文件，但不存在数据文件。<br>    对其中所引用的基础表来说，视图的作用类似于筛选。定义视图的筛选可以来自当前或其它数据库的一个或多个表，或者其它视图。通过视图进行查询没有任何限制，通过它们进行数据修改时的限制也很少。<br>    视图是存储在数据库中的查询的sql语句，它主要出于两种原因：安全原因，视图可以隐藏一些数据，如：社会保险基金表，可以用视图只显示姓名，地址，而不显示社会保险号和工资数等，另一原因是可使复杂的查询易于理解和使用。</p><pre><code class="sql"></code></pre><p>– 创建视图<br>CREATE [OR REPLACE] [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}] VIEW view_name [(column_list)] AS select_statement<br>    - 视图名必须唯一，同时不能与表重名。<br>    - 视图可以使用select语句查询到的列名，也可以自己指定相应的列名。<br>    - 可以指定视图执行的算法，通过ALGORITHM指定。<br>    - column_list如果存在，则数目必须等于SELECT语句检索的列数</p><p>– 查看结构<br>    SHOW CREATE VIEW view_name</p><p>– 删除视图<br>    - 删除视图后，数据依然存在。<br>    - 可同时删除多个视图。<br>    DROP VIEW [IF EXISTS] view_name …</p><p>– 修改视图结构<br>    - 一般不修改视图，因为不是所有的更新视图都会映射到表上。<br>    ALTER VIEW view_name [(column_list)] AS select_statement</p><p>– 视图作用<br>    1. 简化业务逻辑<br>    2. 对客户端隐藏真实的表结构</p><p>– 视图算法(ALGORITHM)<br>    MERGE       合并<br>        将视图的查询语句，与外部查询需要先合并再执行！<br>    TEMPTABLE   临时表<br>        将视图执行完毕后，形成临时表，再做外层查询！<br>    UNDEFINED   未定义(默认)，指的是MySQL自主去选择相应的算法。</p><h2 id="事务-transaction"><a href="#事务-transaction" class="headerlink" title="事务(transaction)"></a>事务(transaction)</h2><p>/* 事务(transaction) */ ——————<br>事务是指逻辑上的一组操作，组成这组操作的各个单元，要不全成功要不全失败。<br>    - 支持连续SQL的集体成功或集体撤销。<br>    - 事务是数据库在数据晚自习方面的一个功能。<br>    - 需要利用 InnoDB 或 BDB 存储引擎，对自动提交的特性支持完成。<br>    - InnoDB被称为事务安全型引擎。</p><p>– 事务开启<br>    START TRANSACTION; 或者 BEGIN;<br>    开启事务后，所有被执行的SQL语句均被认作当前事务内的SQL语句。<br>– 事务提交<br>    COMMIT;<br>– 事务回滚<br>    ROLLBACK;<br>    如果部分操作发生问题，映射到事务开启前。</p><p>– 事务的特性<br>    1. 原子性（Atomicity）<br>        事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。<br>    2. 一致性（Consistency）<br>        事务前后数据的完整性必须保持一致。<br>        - 事务开始和结束时，外部数据一致<br>        - 在整个事务过程中，操作是连续的<br>    3. 隔离性（Isolation）<br>        多个用户并发访问数据库时，一个用户的事务不能被其它用户的事物所干扰，多个并发事务之间的数据要相互隔离。<br>    4. 持久性（Durability）<br>        一个事务一旦被提交，它对数据库中的数据改变就是永久性的。</p><p>– 事务的实现<br>    1. 要求是事务支持的表类型<br>    2. 执行一组相关的操作前开启事务<br>    3. 整组操作完成后，都成功，则提交；如果存在失败，选择回滚，则会回到事务开始的备份点。</p><p>– 事务的原理<br>    利用InnoDB的自动提交(autocommit)特性完成。<br>    普通的MySQL执行语句后，当前的数据提交操作均可被其他客户端可见。<br>    而事务是暂时关闭“自动提交”机制，需要commit提交持久化数据操作。</p><p>– 注意<br>    1. 数据定义语言（DDL）语句不能被回滚，比如创建或取消数据库的语句，和创建、取消或更改表或存储的子程序的语句。<br>    2. 事务不能被嵌套</p><p>– 保存点<br>    SAVEPOINT 保存点名称 – 设置一个事务保存点<br>    ROLLBACK TO SAVEPOINT 保存点名称 – 回滚到保存点<br>    RELEASE SAVEPOINT 保存点名称 – 删除保存点</p><p>– InnoDB自动提交特性设置<br>    SET autocommit = 0|1;   0表示关闭自动提交，1表示开启自动提交。<br>    - 如果关闭了，那普通操作的结果对其他客户端也不可见，需要commit提交后才能持久化数据操作。<br>    - 也可以关闭自动提交来开启事务。但与START TRANSACTION不同的是，<br>        SET autocommit是永久改变服务器的设置，直到下次再次修改该设置。(针对当前连接)<br>        而START TRANSACTION记录开启前的状态，而一旦事务提交或回滚后就需要再次开启事务。(针对当前事务)</p><p>/* 锁表 */</p><pre><code class="sql"></code></pre><p>表锁定只用于防止其它客户端进行不正当地读取和写入<br>MyISAM 支持表锁，InnoDB 支持行锁<br>– 锁定<br>    LOCK TABLES tbl_name [AS alias]<br>– 解锁<br>    UNLOCK TABLES</p><p>/* 触发器 */ ——————<br>    触发程序是与表有关的命名数据库对象，当该表出现特定事件时，将激活该对象<br>    监听：记录的增加、修改、删除。</p><p>– 创建触发器<br>CREATE TRIGGER trigger_name trigger_time trigger_event ON tbl_name FOR EACH ROW trigger_stmt<br>    参数：<br>    trigger_time是触发程序的动作时间。它可以是 before 或 after，以指明触发程序是在激活它的语句之前或之后触发。<br>    trigger_event指明了激活触发程序的语句的类型<br>        INSERT：将新行插入表时激活触发程序<br>        UPDATE：更改某一行时激活触发程序<br>        DELETE：从表中删除某一行时激活触发程序<br>    tbl_name：监听的表，必须是永久性的表，不能将触发程序与TEMPORARY表或视图关联起来。<br>    trigger_stmt：当触发程序激活时执行的语句。执行多个语句，可使用BEGIN…END复合语句结构</p><p>– 删除</p><pre><code class="sql"></code></pre><p>DROP TRIGGER [schema_name.]trigger_name</p><p>可以使用old和new代替旧的和新的数据<br>    更新操作，更新前是old，更新后是new.<br>    删除操作，只有old.<br>    增加操作，只有new.</p><p>– 注意<br>    1. 对于具有相同触发程序动作时间和事件的给定表，不能有两个触发程序。</p><p>– 字符连接函数</p><pre><code class="sql"></code></pre><p>concat(str1,str2,…])<br>concat_ws(separator,str1,str2,…)</p><p>– 分支语句<br>if 条件 then<br>    执行语句<br>elseif 条件 then<br>    执行语句<br>else<br>    执行语句<br>end if;</p><p>– 修改最外层语句结束符<br>delimiter 自定义结束符号<br>    SQL语句<br>自定义结束符号</p><p>delimiter ;     – 修改回原来的分号</p><p>– 语句块包裹<br>begin<br>    语句块<br>end</p><p>– 特殊的执行</p><ol><li>只要添加记录，就会触发程序。</li><li>Insert into on duplicate key update 语法会触发：<br> 如果没有重复记录，会触发 before insert, after insert;<br> 如果有重复记录并更新，会触发 before insert, before update, after update;<br> 如果有重复记录但是没有发生更新，则触发 before insert, before update</li><li>Replace 语法 如果有记录，则执行 before insert, before delete, after delete, after insert</li></ol><p>/* SQL编程 */ ——————</p><p>–// 局部变量 ———-<br>– 变量声明<br>    declare var_name[,…] type [default value]<br>    这个语句被用来声明局部变量。要给变量提供一个默认值，请包含一个default子句。值可以被指定为一个表达式，不需要为一个常数。如果没有default子句，初始值为null。</p><p>– 赋值<br>    使用 set 和 select into 语句为变量赋值。</p><pre><code>- 注意：在函数内是可以使用全局变量（用户自定义的变量）</code></pre><p>–// 全局变量 ———-</p><pre><code class="sql"></code></pre><p>– 定义、赋值<br>set 语句可以定义并为变量赋值。<br>set @var = value;<br>也可以使用select into语句为变量初始化并赋值。这样要求select语句只能返回一行，但是可以是多个字段，就意味着同时为多个变量进行赋值，变量的数量需要与查询的列数一致。<br>还可以把赋值语句看作一个表达式，通过select执行完成。此时为了避免=被当作关系运算符看待，使用:=代替。（set语句可以使用= 和 :=）。<br>select @var:=20;<br>select @v1:=id, @v2=name from t1 limit 1;<br>select * from tbl_name where @var:=30;</p><p>select into 可以将表中查询获得的数据赋给变量。<br>    -| select max(height) into @max_height from tb;</p><p>– 自定义变量名<br>为了避免select语句中，用户自定义的变量与系统标识符（通常是字段名）冲突，用户自定义变量在变量名前使用@作为开始符号。<br>@var=10;</p><pre><code>- 变量被定义后，在整个会话周期都有效（登录到退出）</code></pre><p>–// 控制结构 ———-</p><pre><code class="sql"></code></pre><p>– if语句<br>if search_condition then<br>    statement_list<br>[elseif search_condition then<br>    statement_list]<br>…<br>[else<br>    statement_list]<br>end if;</p><p>– case语句<br>CASE value WHEN [compare-value] THEN result<br>[WHEN [compare-value] THEN result …]<br>[ELSE result]<br>END</p><pre><code class="sql"></code></pre><p>– while循环<br>[begin_label:] while search_condition do<br>    statement_list<br>end while [end_label];</p><ul><li><p>如果需要在循环内提前终止 while循环，则需要使用标签；标签需要成对出现。</p><p>  – 退出循环</p><pre><code>  退出整个循环 leave  退出当前循环 iterate  通过退出的标签决定退出哪个循环</code></pre></li></ul><p>–// 内置函数 ———-<br>– 数值函数<br>abs(x)          – 绝对值 abs(-10.9) = 10<br>format(x, d)    – 格式化千分位数值 format(1234567.456, 2) = 1,234,567.46<br>ceil(x)         – 向上取整 ceil(10.1) = 11<br>floor(x)        – 向下取整 floor (10.1) = 10<br>round(x)        – 四舍五入去整<br>mod(m, n)       – m%n m mod n 求余 10%3=1<br>pi()            – 获得圆周率<br>pow(m, n)       – m^n<br>sqrt(x)         – 算术平方根<br>rand()          – 随机数<br>truncate(x, d)  – 截取d位小数</p><p>– 时间日期函数<br>now(), current_timestamp();     – 当前日期时间<br>current_date();                 – 当前日期<br>current_time();                 – 当前时间<br>date(‘yyyy-mm-dd hh:ii:ss’);    – 获取日期部分<br>time(‘yyyy-mm-dd hh:ii:ss’);    – 获取时间部分<br>date_format(‘yyyy-mm-dd hh:ii:ss’, ‘%d %y %a %d %m %b %j’); – 格式化时间<br>unix_timestamp();               – 获得unix时间戳<br>from_unixtime();                – 从时间戳获得时间</p><p>– 字符串函数<br>length(string)          – string长度，字节<br>char_length(string)     – string的字符个数<br>substring(str, position [,length])      – 从str的position开始,取length个字符<br>replace(str ,search_str ,replace_str)   – 在str中用replace_str替换search_str<br>instr(string ,substring)    – 返回substring首次在string中出现的位置<br>concat(string [,…])   – 连接字串<br>charset(str)            – 返回字串字符集<br>lcase(string)           – 转换成小写<br>left(string, length)    – 从string2中的左边起取length个字符<br>load_file(file_name)    – 从文件读取内容<br>locate(substring, string [,start_position]) – 同instr,但可指定开始位置<br>lpad(string, length, pad)   – 重复用pad加在string开头,直到字串长度为length<br>ltrim(string)           – 去除前端空格<br>repeat(string, count)   – 重复count次<br>rpad(string, length, pad)   –在str后用pad补充,直到长度为length<br>rtrim(string)           – 去除后端空格<br>strcmp(string1 ,string2)    – 逐字符比较两字串大小</p><p>– 流程函数<br>case when [condition] then result [when [condition] then result …] [else result] end   多分支<br>if(expr1,expr2,expr3)  双分支。</p><p>– 聚合函数<br>count()<br>sum();<br>max();<br>min();<br>avg();<br>group_concat()</p><p>– 其他常用函数<br>md5();<br>default();</p><p>–// 存储函数，自定义函数 ———-</p><pre><code class="sql"></code></pre><p>– 新建<br>    CREATE FUNCTION function_name (参数列表) RETURNS 返回值类型<br>        函数体</p><pre><code>- 函数名，应该合法的标识符，并且不应该与已有的关键字冲突。- 一个函数应该属于某个数据库，可以使用db_name.funciton_name的形式执行当前函数所属数据库，否则为当前数据库。- 参数部分，由&quot;参数名&quot;和&quot;参数类型&quot;组成。多个参数用逗号隔开。- 函数体由多条可用的mysql语句，流程控制，变量声明等语句构成。- 多条语句应该使用 begin...end 语句块包含。- 一定要有 return 返回值语句。</code></pre><p>– 删除<br>    DROP FUNCTION [IF EXISTS] function_name;</p><p>– 查看<br>    SHOW FUNCTION STATUS LIKE ‘partten’<br>    SHOW CREATE FUNCTION function_name;</p><p>– 修改<br>    ALTER FUNCTION function_name 函数选项</p><p>–// 存储过程，自定义功能 ———-<br>– 定义<br>存储存储过程 是一段代码（过程），存储在数据库中的sql组成。<br>一个存储过程通常用于完成一段业务逻辑，例如报名，交班费，订单入库等。<br>而一个函数通常专注与某个功能，视为其他程序服务的，需要在其他语句中调用函数才可以，而存储过程不能被其他调用，是自己执行 通过call执行。</p><p>– 创建<br>CREATE PROCEDURE sp_name (参数列表)<br>    过程体</p><p>参数列表：不同于函数的参数列表，需要指明参数类型<br>IN，表示输入型<br>OUT，表示输出型<br>INOUT，表示混合型</p><p>注意，没有返回值。</p><p>/* 存储过程 */ ——————<br>存储过程是一段可执行性代码的集合。相比函数，更偏向于业务逻辑。<br>调用：CALL 过程名<br>– 注意</p><ul><li>没有返回值。</li><li>只能单独调用，不可夹杂在其他语句中</li></ul><p>– 参数<br>IN|OUT|INOUT 参数名 数据类型<br>IN      输入：在调用过程中，将数据输入到过程体内部的参数<br>OUT     输出：在调用过程中，将过程体处理完的结果返回到客户端<br>INOUT   输入输出：既可输入，也可输出</p><pre><code class="sql"></code></pre><p>– 语法<br>CREATE PROCEDURE 过程名 (参数列表)<br>BEGIN<br>    过程体<br>END</p><p>/* 用户和权限管理 */ ——————</p><pre><code class="sql"></code></pre><p>用户信息表：mysql.user<br>– 刷新权限<br>FLUSH PRIVILEGES;<br>– 增加用户<br>CREATE USER 用户名 IDENTIFIED BY [PASSWORD] 密码(字符串)<br>    - 必须拥有mysql数据库的全局CREATE USER权限，或拥有INSERT权限。<br>    - 只能创建用户，不能赋予权限。<br>    - 用户名，注意引号：如 ‘user_name’@’192.168.1.1’<br>    - 密码也需引号，纯数字密码也要加引号<br>    - 要在纯文本中指定密码，需忽略PASSWORD关键词。要把密码指定为由PASSWORD()函数返回的混编值，需包含关键字PASSWORD<br>– 重命名用户<br>RENAME USER old_user TO new_user<br>– 设置密码<br>SET PASSWORD = PASSWORD(‘密码’)  – 为当前用户设置密码<br>SET PASSWORD FOR 用户名 = PASSWORD(‘密码’) – 为指定用户设置密码<br>– 删除用户<br>DROP USER 用户名<br>– 分配权限/添加用户<br>GRANT 权限列表 ON 表名 TO 用户名 [IDENTIFIED BY [PASSWORD] ‘password’]<br>    - all privileges 表示所有权限<br>    - <em>.</em> 表示所有库的所有表<br>    - 库名.表名 表示某库下面的某表<br>    GRANT ALL PRIVILEGES ON <code>pms</code>.* TO ‘pms’@’%’ IDENTIFIED BY ‘pms0817’;<br>– 查看权限<br>SHOW GRANTS FOR 用户名<br>    – 查看当前用户权限<br>    SHOW GRANTS; 或 SHOW GRANTS FOR CURRENT_USER; 或 SHOW GRANTS FOR CURRENT_USER();<br>– 撤消权限<br>REVOKE 权限列表 ON 表名 FROM 用户名<br>REVOKE ALL PRIVILEGES, GRANT OPTION FROM 用户名   – 撤销所有权限<br>– 权限层级<br>– 要使用GRANT或REVOKE，您必须拥有GRANT OPTION权限，并且您必须用于您正在授予或撤销的权限。<br>全局层级：全局权限适用于一个给定服务器中的所有数据库，mysql.user<br>    GRANT ALL ON <em>.</em>和 REVOKE ALL ON <em>.</em>只授予和撤销全局权限。<br>数据库层级：数据库权限适用于一个给定数据库中的所有目标，mysql.db, mysql.host<br>    GRANT ALL ON db_name.<em>和REVOKE ALL ON db_name.</em>只授予和撤销数据库权限。<br>表层级：表权限适用于一个给定表中的所有列，mysql.talbes_priv<br>    GRANT ALL ON db_name.tbl_name和REVOKE ALL ON db_name.tbl_name只授予和撤销表权限。<br>列层级：列权限适用于一个给定表中的单一列，mysql.columns_priv<br>    当使用REVOKE时，您必须指定与被授权列相同的列。<br>– 权限列表<br>ALL [PRIVILEGES]    – 设置除GRANT OPTION之外的所有简单权限<br>ALTER   – 允许使用ALTER TABLE<br>ALTER ROUTINE   – 更改或取消已存储的子程序<br>CREATE  – 允许使用CREATE TABLE<br>CREATE ROUTINE  – 创建已存储的子程序<br>CREATE TEMPORARY TABLES     – 允许使用CREATE TEMPORARY TABLE<br>CREATE USER     – 允许使用CREATE USER, DROP USER, RENAME USER和REVOKE ALL PRIVILEGES。<br>CREATE VIEW     – 允许使用CREATE VIEW<br>DELETE  – 允许使用DELETE<br>DROP    – 允许使用DROP TABLE<br>EXECUTE     – 允许用户运行已存储的子程序<br>FILE    – 允许使用SELECT…INTO OUTFILE和LOAD DATA INFILE<br>INDEX   – 允许使用CREATE INDEX和DROP INDEX<br>INSERT  – 允许使用INSERT<br>LOCK TABLES     – 允许对您拥有SELECT权限的表使用LOCK TABLES<br>PROCESS     – 允许使用SHOW FULL PROCESSLIST<br>REFERENCES  – 未被实施<br>RELOAD  – 允许使用FLUSH<br>REPLICATION CLIENT  – 允许用户询问从属服务器或主服务器的地址<br>REPLICATION SLAVE   – 用于复制型从属服务器（从主服务器中读取二进制日志事件）<br>SELECT  – 允许使用SELECT<br>SHOW DATABASES  – 显示所有数据库<br>SHOW VIEW   – 允许使用SHOW CREATE VIEW<br>SHUTDOWN    – 允许使用mysqladmin shutdown<br>SUPER   – 允许使用CHANGE MASTER, KILL, PURGE MASTER LOGS和SET GLOBAL语句，mysqladmin debug命令；允许您连接（一次），即使已达到max_connections。<br>UPDATE  – 允许使用UPDATE<br>USAGE   – “无权限”的同义词<br>GRANT OPTION    – 允许授予权限</p><p>/* 表维护 */</p><pre><code class="sql"></code></pre><p>– 分析和存储表的关键字分布<br>ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE 表名 …<br>– 检查一个或多个表是否有错误<br>CHECK TABLE tbl_name [, tbl_name] … [option] …<br>option = {QUICK | FAST | MEDIUM | EXTENDED | CHANGED}<br>– 整理数据文件的碎片<br>OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] …</p><p>/* 杂项 */ ——————</p><ol><li>可用反引号（`）为标识符（库名、表名、字段名、索引、别名）包裹，以避免与关键字重名！中文也可以作为标识符！</li><li>每个库目录存在一个保存当前数据库的选项文件db.opt。</li><li>注释：<br> 单行注释 # 注释内容<br> 多行注释 /* 注释内容 */<br> 单行注释 – 注释内容     (标准SQL注释风格，要求双破折号后加一空格符（空格、TAB、换行等）)</li><li>模式通配符：<br> _   任意单个字符<br> %   任意多个字符，甚至包括零字符<br> 单引号需要进行转义 &#39;</li><li>CMD命令行内的语句结束符可以为 “;”, “\G”, “\g”，仅影响显示结果。其他地方还是用分号结束。delimiter 可修改当前对话的语句结束符。</li><li>SQL对大小写不敏感</li><li>清除已有语句：\c</li></ol><p>本片文章参考该文章整理：<a href="https://shockerli.net/post/1000-line-mysql-note/" target="_blank" rel="noopener">https://shockerli.net/post/1000-line-mysql-note/</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lombok常用注解</title>
      <link href="/2020/01/18/lombok-annotation/"/>
      <url>/2020/01/18/lombok-annotation/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h3 id="Data"><a href="#Data" class="headerlink" title="@Data"></a>@Data</h3><p>相当于@Getter @Setter @RequiredArgsConstructor @ToString @EqualsAndHashCode这5个注解的合集。</p><p>当使用@Data注解时，则有了@EqualsAndHashCode注解，那么就会在此类中存在equals(Object other) 和 hashCode()方法，且不会使用父类的属性，这就导致了可能的问题。<br>比如，有多个类有相同的部分属性，把它们定义到父类中，恰好id（数据库主键）也在父类中，那么就会存在部分对象在比较时，它们并不相等，却因为lombok自动生成的equals(Object other) 和 hashCode()方法判定为相等，从而导致出错。</p><p>修复此问题： </p><ol><li>使用@Getter @Setter @ToString代替@Data并且自定义equals(Object other) 和 hashCode()方法，比如有些类只需要判断主键id是否相等即足矣。 </li><li>或者使用在使用@Data时同时加上@EqualsAndHashCode(callSuper=true)注解。</li></ol><h3 id="Getter-and-Setter"><a href="#Getter-and-Setter" class="headerlink" title="@Getter and @Setter"></a>@Getter and @Setter</h3><p>可以用@Getter / @Setter注释字段（也可以注释到类上的—(在实体类中常用且推荐)），lombok会自动生成默认的Getter/Setter方法。</p><h3 id="ToString"><a href="#ToString" class="headerlink" title="@ToString"></a>@ToString</h3><p>自动生成toString()方法，默认情况，按顺序（以“,”分隔）打印你的类名称以及每个字段。也可以设置不包含哪些字段/@ToString(exclude = {“id”,”name”})</p><h3 id="Synchronized"><a href="#Synchronized" class="headerlink" title="@Synchronized"></a>@Synchronized</h3><p>给方法加上同步锁，建议直接写在代码中Synchronized</p><h3 id="NoArgsConstructor"><a href="#NoArgsConstructor" class="headerlink" title="@NoArgsConstructor"></a>@NoArgsConstructor</h3><p>生成一个无参数的构造方法</p><h3 id="AllArgsConstructor"><a href="#AllArgsConstructor" class="headerlink" title="@AllArgsConstructor"></a>@AllArgsConstructor</h3><p>生成一个包含所有变量的构造方法</p><h3 id="RequiredArgsConstructor"><a href="#RequiredArgsConstructor" class="headerlink" title="@RequiredArgsConstructor"></a>@RequiredArgsConstructor</h3><p>生成一个包含常量，和标识了NotNull的变量的构造方法。生成的构造方法是私有的private。</p><h3 id="NonNull"><a href="#NonNull" class="headerlink" title="@NonNull"></a>@NonNull</h3><p>可以避免空指针</p><h3 id="Cleanup"><a href="#Cleanup" class="headerlink" title="@Cleanup"></a>@Cleanup</h3><p>自动调用close()方法</p><h3 id="EqualsAndHashCode"><a href="#EqualsAndHashCode" class="headerlink" title="@EqualsAndHashCode"></a>@EqualsAndHashCode</h3><p>此注解会生成equals(Object other) 和 hashCode()方法</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> lombok </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lombok </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot 2.2 集成mybatis-plus</title>
      <link href="/2020/01/18/springboot-mybatis-plus/"/>
      <url>/2020/01/18/springboot-mybatis-plus/</url>
      
        <content type="html"><![CDATA[<p>项目搭建及个人开发遇到相关问题<br><strong><em>源码 简单版</em></strong>：<a href="https://github.com/kylin-lawliet/blackcat-blog-web/tree/master/demo-mybatis-plus" target="_blank" rel="noopener">https://github.com/kylin-lawliet/blackcat-blog-web/tree/master/demo-mybatis-plus</a><br><strong><em>源码 基础版</em></strong>：<a href="https://github.com/kylin-lawliet/blackcat-blog-web/tree/master/demo-mybatis-plus-level2" target="_blank" rel="noopener">https://github.com/kylin-lawliet/blackcat-blog-web/tree/master/demo-mybatis-plus-level2</a></p><a id="more"></a><h2 id="项目搭建"><a href="#项目搭建" class="headerlink" title="项目搭建"></a>项目搭建</h2><h3 id="创建springboot项目"><a href="#创建springboot项目" class="headerlink" title="创建springboot项目"></a>创建springboot项目</h3><blockquote><p>可查看这篇文章 : <a href="/2020/01/07/SpringBoot-Create/" title="创建SpringBoot项目">创建SpringBoot项目</a></p></blockquote><h3 id="添加maven依赖"><a href="#添加maven依赖" class="headerlink" title="添加maven依赖"></a>添加maven依赖</h3><pre><code class="java">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;mysql&lt;/groupId&gt;    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;    &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;    &lt;version&gt;3.1.0&lt;/version&gt;&lt;/dependency&gt;&lt;!--分页--&gt;&lt;dependency&gt;    &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;    &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;1.2.12&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;druid&lt;/artifactId&gt;    &lt;version&gt;1.1.10&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;    &lt;artifactId&gt;lombok&lt;/artifactId&gt;    &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;    &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;</code></pre><h3 id="添加业务代码"><a href="#添加业务代码" class="headerlink" title="添加业务代码"></a>添加业务代码</h3><p>User</p><pre><code class="java">package com.blackcat.mybatis.entity;import com.baomidou.mybatisplus.annotation.*;import com.baomidou.mybatisplus.extension.activerecord.Model;import lombok.*;/** * &lt;p&gt; ：测试用户 * @author : blackcat * @date : 2020/1/18 12:58 */@Data@NoArgsConstructor// 生成一个无参数的构造方法@AllArgsConstructor// 会生成一个包含所有变量的构造方法@TableName(&quot;TB_USER&quot;)public class User extends Model&lt;User&gt; {    @TableId(value = &quot;USER_ID&quot;, type = IdType.AUTO)    private Integer userId;    @TableField(&quot;USER_NAME&quot;)    private String userName;}</code></pre><p>添加UserMapper</p><pre><code class="java">package com.blackcat.mybatis.mapper;import com.baomidou.mybatisplus.core.mapper.BaseMapper;import com.blackcat.mybatis.entity.User;import java.util.List;/** * &lt;p&gt; ：Mapper * @author : blackcat * @date : 2020/1/18 12:57 */public interface UserMapper  extends BaseMapper&lt;User&gt; {    /**     * 获取用户信息     */    List&lt;User&gt; findAllUser();}</code></pre><p>添加IUserService</p><pre><code class="java">package com.blackcat.mybatis.service;import com.baomidou.mybatisplus.extension.service.IService;import com.blackcat.mybatis.entity.User;/** * &lt;p&gt; ： * @author : blackcat * @date : 2020/1/18 12:59 */public interface IUserService extends IService&lt;User&gt; {    /**     * 添加新用户     */    Object addUser(String userName);    /**     * 查询用户列表     */    Object findUserList(Integer pageNo, Integer pageSize);}</code></pre><p>添加UserServiceImpl</p><pre><code class="java">package com.blackcat.mybatis.service.impl;import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;import com.baomidou.mybatisplus.core.metadata.IPage;import com.baomidou.mybatisplus.extension.plugins.pagination.Page;import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;import com.blackcat.mybatis.entity.User;import com.blackcat.mybatis.mapper.UserMapper;import com.blackcat.mybatis.service.IUserService;import lombok.Data;import org.springframework.stereotype.Service;/** * &lt;p&gt; ： * @author : blackcat * @date : 2020/1/18 13:01 */@Service(&quot;userService&quot;)@Datapublic class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements IUserService {    @Override    public Object addUser(String userName) {        User user = new User(null, userName);        int ret = baseMapper.insert(user);        return ret;    }    @Override    public Object findUserList(Integer pageNo, Integer pageSize) {        IPage&lt;User&gt; page = new Page&lt;&gt;(pageNo, pageSize);        QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;();        wrapper.orderByAsc(&quot;USER_ID&quot;);        IPage&lt;User&gt; userIPage = baseMapper.selectPage(page, wrapper);        return userIPage;    }}</code></pre><p>添加MybatisPlusConfig</p><pre><code class="java">package com.blackcat.mybatis;import com.baomidou.mybatisplus.core.injector.ISqlInjector;import com.baomidou.mybatisplus.extension.injector.LogicSqlInjector;import com.baomidou.mybatisplus.extension.plugins.*;import com.github.pagehelper.PageHelper;import org.mybatis.spring.annotation.MapperScan;import org.springframework.context.annotation.*;import java.util.Properties;/** * &lt;p&gt; ：Mybatis-Plus配置类 * @author : blackcat * @date : 2020/1/18 12:44 */@Configuration@MapperScan(&quot;com.blackcat.mybatis.mapper&quot;)//这个注解，作用相当于下面的@Bean MapperScannerConfigurer，2者配置1份即可public class MybatisPlusConfig {    /**     * 分页插件     */    @Bean    public PaginationInterceptor paginationInterceptor() {        PaginationInterceptor paginationInterceptor = new PaginationInterceptor();        paginationInterceptor.setDialectType(&quot;mysql&quot;);        return paginationInterceptor;    }    /**     * sql注入器  逻辑删除插件     *     * @return     */    @Bean    public ISqlInjector iSqlInjector() {        return new LogicSqlInjector();    }    /**     * sql性能分析插件，输出sql语句及所需时间     *     * @return     */    @Bean    @Profile({&quot;dev&quot;, &quot;test&quot;})// 设置 dev test 环境开启    public PerformanceInterceptor performanceInterceptor() {        PerformanceInterceptor performanceInterceptor = new PerformanceInterceptor();        performanceInterceptor.setFormat(true);        return performanceInterceptor;    }    /**     * 配置mybatis的分页插件pageHelper     * @return     */    @Bean    public PageHelper pageHelper() {        PageHelper pageHelper = new PageHelper();        Properties properties = new Properties();        properties.setProperty(&quot;offsetAsPageNum&quot;, &quot;true&quot;);        properties.setProperty(&quot;rowBoundsWithCount&quot;, &quot;true&quot;);        properties.setProperty(&quot;reasonable&quot;, &quot;true&quot;);        properties.setProperty(&quot;dialect&quot;, &quot;mysql&quot;);        pageHelper.setProperties(properties);        return pageHelper;    }    /**     * 乐观锁插件     *     * @return     */    public OptimisticLockerInterceptor optimisticLockerInterceptor() {        return new OptimisticLockerInterceptor();    }}</code></pre><p>添加UserController</p><pre><code class="java">package com.blackcat.mybatis.controller;import com.blackcat.mybatis.service.IUserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;/** * &lt;p&gt; ：Controller * @author : blackcat * @date : 2020/1/18 13:20 */@RestControllerpublic class UserController {    @Autowired    private IUserService userService;    /**     * 新增测试     */    @RequestMapping(&quot;/addUser&quot;)    public Object addUser(String userName) {        return userService.addUser(userName);    }    /**     * 查询测试     */    @RequestMapping(&quot;/findUserList&quot;)    public Object findUserList(Integer pageNo, Integer pageSize) {        return userService.findUserList(pageNo, pageSize);    }}</code></pre><p>添加UserMapper.xml</p><pre><code class="java">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.blackcat.mybatis.mapper.UserMapper&quot;&gt;    &lt;!-- 通用查询映射结果 --&gt;    &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.blackcat.mybatis.entity.User&quot;&gt;        &lt;id column=&quot;USER_ID&quot; property=&quot;userId&quot;/&gt;        &lt;result column=&quot;USER_NAME&quot; property=&quot;userName&quot;/&gt;    &lt;/resultMap&gt;&lt;/mapper&gt;</code></pre><h3 id="配置文件application-yml"><a href="#配置文件application-yml" class="headerlink" title="配置文件application.yml"></a>配置文件application.yml</h3><pre><code class="java">server:  port: 8090  #dataSource setspring:  datasource:    name: hejrDataSource    url: jdbc:mysql://192.168.31.77:4306/testdata?serverTimezone=GMT%2B8&amp;useUnicode=true&amp;characterEncoding=utf8&amp;characterSetResults=utf8&amp;useSSL=false    username: root    password: 111111    type: com.alibaba.druid.pool.DruidDataSource    driver-class-name: com.mysql.jdbc.Driver    filters: stat    maxActive: 20    initialSize: 1    maxWait: 60000    minIdle: 1    timeBetweenEvictionRunsMillis: 60000    minEvictableIdleTimeMillis: 300000    validationQuery: select &#39;x&#39;    testWhileIdle: true    testOnBorrow: false    testOnReturn: false    poolPreparedStatements: true    maxOpenPreparedStatements: 20#mybatis plusmybatis-plus:  mapper-locations: classpath:mapper/*Mapper.xml  #实体扫描，多个package用逗号或者分号分隔  typeAliasesPackage: com.blackcat.mybatis.entiry  #typeEnumsPackage: com.baomidou.springboot.entity.enums  global-config:    #刷新mapper 调试神器    db-config:      #主键类型  0:&quot;数据库ID自增&quot;, 1:&quot;用户输入ID&quot;,2:&quot;全局唯一ID (数字类型唯一ID)&quot;, 3:&quot;全局唯一ID UUID&quot;;      #idtype: 0      #字段策略 0:&quot;忽略判断&quot;,1:&quot;非 NULL 判断&quot;),2:&quot;非空判断&quot;      field-strategy: not_empty      #驼峰下划线转换      column-underline: true      #数据库大写下划线转换      #capitalmode: true      #逻辑删除配置      logic-delete-value: 1      logic-not-delete-value: 0      db-type: mysql    refresh: true      #自定义填充策略接口实现      #metaobjecthandler: com.baomidou.springboot.xxx    #自定义SQL注入器  #sqlinjector: com.baomidou.mybatisplus.extension.injector.LogicSqlInjector  configuration:    # 这个配置会将执行的sql打印出来，在开发或测试的时候可以用    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl    map-underscore-to-camel-case: true    cache-enabled: falselogging.level.com.blackcat.mybaits.mapper: debug</code></pre><h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><p><img src="/img/ssm/mybatis/1.png" alt=""><br><img src="/img/ssm/mybatis/2.png" alt=""></p><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><h3 id="TableName：数据库表相关"><a href="#TableName：数据库表相关" class="headerlink" title="@TableName：数据库表相关"></a>@TableName：数据库表相关</h3><h3 id="TableId：表主键标识"><a href="#TableId：表主键标识" class="headerlink" title="@TableId：表主键标识"></a>@TableId：表主键标识</h3><h3 id="TableField：表字段标识"><a href="#TableField：表字段标识" class="headerlink" title="@TableField：表字段标识"></a>@TableField：表字段标识</h3><ul><li><code>@TableField(exist = false)</code>：表示该属性不为数据库表字段，但又是必须使用的。</li><li><code>@TableField(exist = true)</code>：表示该属性为数据库表字段。</li></ul><h3 id="TableLogic：表字段逻辑处理注解（逻辑删除）"><a href="#TableLogic：表字段逻辑处理注解（逻辑删除）" class="headerlink" title="@TableLogic：表字段逻辑处理注解（逻辑删除）"></a>@TableLogic：表字段逻辑处理注解（逻辑删除）</h3><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="Unknown-column-‘xxx’-in-‘field-list’"><a href="#Unknown-column-‘xxx’-in-‘field-list’" class="headerlink" title="Unknown column ‘xxx’ in ‘field list’"></a>Unknown column ‘xxx’ in ‘field list’</h3><p>该错误一般情况下是实体类与数据库字段不匹配导致。例如：名称有下划线之类的，与实体类不一致。<br>也还有其他情况出现：<br><strong>例如：</strong><br>实体类中使用<code>@Transient</code>注解，数据库中并不会存在该字段，但是又是必须使用字段。<br>这时当时用当使用mybatis-plus自带的查询时，如<code>selectById(key)</code>之类的就会报标题标注错误。<br><strong>解决方式：</strong><br>在字段上方加入<code>@TableField(exist = false)</code>注解(表示该属性不为数据库表字段，但又是必须使用的。)</p><h3 id="关于’getBaseMapper-’-in-‘com-baomidou-mybatisplus-extension-service-impl-ServiceImpl’-clashes-with…"><a href="#关于’getBaseMapper-’-in-‘com-baomidou-mybatisplus-extension-service-impl-ServiceImpl’-clashes-with…" class="headerlink" title="关于’getBaseMapper()’ in ‘com.baomidou.mybatisplus.extension.service.impl.ServiceImpl’ clashes with…"></a>关于’getBaseMapper()’ in ‘com.baomidou.mybatisplus.extension.service.impl.ServiceImpl’ clashes with…</h3><p>问题原因：mapper类没有继承BaseMapper<br>示例：</p><pre><code class="java">// Mapper类public interface UserMapper{// 没有继承extends BaseMapper&lt;User&gt; }// Service类public interface IUserService extends IService&lt;User&gt; {}// ServiceImpl类public class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements IUserService {// 此处会报错}</code></pre><p>解决：UserMapper类继承BaseMapper</p><h3 id="ClassNotFoundException-org-mybatis-logging-LoggerFactory"><a href="#ClassNotFoundException-org-mybatis-logging-LoggerFactory" class="headerlink" title="ClassNotFoundException: org.mybatis.logging.LoggerFactory"></a>ClassNotFoundException: org.mybatis.logging.LoggerFactory</h3><p>依赖冲突，查看自己依赖是否错误</p><ul><li>spring boot整合mybatis  maven 依赖<pre><code class="java">&lt;dependency&gt;  &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;  &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;  &lt;version&gt;2.1.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;  &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;  &lt;artifactId&gt;pagehelper&lt;/artifactId&gt;  &lt;version&gt;5.1.4&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;  &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;  &lt;artifactId&gt;pagehelper-spring-boot-autoconfigure&lt;/artifactId&gt;  &lt;version&gt;1.2.5&lt;/version&gt;&lt;/dependency&gt;</code></pre></li><li>spring boot整合mybatis-plus  maven 依赖<pre><code class="java">&lt;!-- mybatisPlus 核心库 --&gt;&lt;dependency&gt;  &lt;groupId&gt;com.baomidou&lt;/groupId&gt;  &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;  &lt;version&gt;3.1.0&lt;/version&gt;&lt;/dependency&gt;&lt;!--分页--&gt;&lt;dependency&gt;  &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;  &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt;  &lt;version&gt;1.2.12&lt;/version&gt;&lt;/dependency&gt;</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven pom.xml常用</title>
      <link href="/2020/01/16/maven-common/"/>
      <url>/2020/01/16/maven-common/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="dependencies"><a href="#dependencies" class="headerlink" title="dependencies"></a>dependencies</h1><h2 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h2><h3 id="父工程"><a href="#父工程" class="headerlink" title="父工程"></a>父工程</h3><pre><code class="xml">&lt;!-- 父工程 --&gt;&lt;parent&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;    &lt;version&gt;2.2.2.RELEASE&lt;/version&gt;&lt;/parent&gt;</code></pre><h3 id="web"><a href="#web" class="headerlink" title="web"></a>web</h3><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><h3 id="druid"><a href="#druid" class="headerlink" title="druid"></a>druid</h3><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;druid&lt;/artifactId&gt;    &lt;version&gt;1.1.6&lt;/version&gt;&lt;/dependency&gt;</code></pre><h2 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h2><h3 id="StringUtilS工具"><a href="#StringUtilS工具" class="headerlink" title="StringUtilS工具"></a>StringUtilS工具</h3><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;    &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt;    &lt;version&gt;3.5&lt;/version&gt;&lt;/dependency&gt;</code></pre><h3 id="junit"><a href="#junit" class="headerlink" title="junit"></a>junit</h3><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;    &lt;scope&gt;test&lt;/scope&gt;    &lt;exclusions&gt;        &lt;exclusion&gt;            &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;            &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;        &lt;/exclusion&gt;    &lt;/exclusions&gt;&lt;/dependency&gt;</code></pre><h3 id="test"><a href="#test" class="headerlink" title="test"></a>test</h3><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-test&lt;/artifactId&gt;    &lt;version&gt;1.4.2.RELEASE&lt;/version&gt;    &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;</code></pre><h3 id="json"><a href="#json" class="headerlink" title="json"></a>json</h3><pre><code class="xml">&lt;!--json--&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;    &lt;version&gt;1.2.32&lt;/version&gt;&lt;/dependency&gt;</code></pre><h2 id="mybatis"><a href="#mybatis" class="headerlink" title="mybatis"></a>mybatis</h2><h3 id="mybatis-1"><a href="#mybatis-1" class="headerlink" title="mybatis"></a>mybatis</h3><pre><code class="xml">&lt;!-- mybatis 核心库 --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;2.1.1&lt;/version&gt;&lt;/dependency&gt;&lt;!--分页--&gt;&lt;dependency&gt;    &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;    &lt;artifactId&gt;pagehelper&lt;/artifactId&gt;    &lt;version&gt;5.1.4&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;    &lt;artifactId&gt;pagehelper-spring-boot-autoconfigure&lt;/artifactId&gt;    &lt;version&gt;1.2.5&lt;/version&gt;&lt;/dependency&gt;</code></pre><h3 id="mybatisPlus"><a href="#mybatisPlus" class="headerlink" title="mybatisPlus"></a>mybatisPlus</h3><h3 id="mybatisPlus-核心库"><a href="#mybatisPlus-核心库" class="headerlink" title="mybatisPlus 核心库"></a>mybatisPlus 核心库</h3><pre><code class="xml">&lt;!-- mybatisPlus 核心库 --&gt;&lt;dependency&gt;    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-plus&lt;/artifactId&gt;    &lt;version&gt;3.1.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-plus-core&lt;/artifactId&gt;    &lt;version&gt;3.2.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;    &lt;version&gt;3.3.0&lt;/version&gt;&lt;/dependency&gt;</code></pre><h3 id="mybatisPlus-分页"><a href="#mybatisPlus-分页" class="headerlink" title="mybatisPlus 分页"></a>mybatisPlus 分页</h3><pre><code class="xml">&lt;!--分页--&gt;&lt;dependency&gt;    &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;    &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;1.2.12&lt;/version&gt;&lt;/dependency&gt;</code></pre><h3 id="mybatisPlus-代码生成器插件"><a href="#mybatisPlus-代码生成器插件" class="headerlink" title="mybatisPlus 代码生成器插件"></a>mybatisPlus 代码生成器插件</h3><pre><code class="xml">&lt;!-- mybatisPlus 代码生成器插件--&gt;&lt;dependency&gt;    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt;    &lt;version&gt;3.1.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 代码生成器模板--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.freemarker&lt;/groupId&gt;    &lt;artifactId&gt;freemarker&lt;/artifactId&gt;    &lt;version&gt;2.3.28&lt;/version&gt;&lt;/dependency&gt;</code></pre><h2 id="spring-boot"><a href="#spring-boot" class="headerlink" title="spring-boot"></a>spring-boot</h2><h3 id="spring-boot配置文件注解"><a href="#spring-boot配置文件注解" class="headerlink" title="spring-boot配置文件注解"></a>spring-boot配置文件注解</h3><pre><code class="xml">&lt;!--spring-boot配置文件注解--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;    &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;</code></pre><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h3 id="spring-boot-starter-data-redis-reactive"><a href="#spring-boot-starter-data-redis-reactive" class="headerlink" title="spring-boot-starter-data-redis-reactive"></a>spring-boot-starter-data-redis-reactive</h3><pre><code class="xml">&lt;!-- Redis --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-redis-reactive&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><h2 id="Shiro"><a href="#Shiro" class="headerlink" title="Shiro"></a>Shiro</h2><h3 id="Shiro-核心依赖"><a href="#Shiro-核心依赖" class="headerlink" title="Shiro 核心依赖"></a>Shiro 核心依赖</h3><pre><code class="xml">&lt;!-- Shiro 核心依赖 --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;    &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt;    &lt;version&gt;1.4.0&lt;/version&gt;&lt;/dependency&gt;</code></pre><h3 id="Shiro-redis插件"><a href="#Shiro-redis插件" class="headerlink" title="Shiro-redis插件"></a>Shiro-redis插件</h3><pre><code class="xml">&lt;!-- Shiro-redis插件 --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.crazycake&lt;/groupId&gt;    &lt;artifactId&gt;shiro-redis&lt;/artifactId&gt;    &lt;version&gt;3.1.0&lt;/version&gt;&lt;/dependency&gt;</code></pre><h3 id="Shiro缓存"><a href="#Shiro缓存" class="headerlink" title="Shiro缓存"></a>Shiro缓存</h3><pre><code class="xml">&lt;!-- Shiro缓存 --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;    &lt;artifactId&gt;shiro-ehcache&lt;/artifactId&gt;    &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt;</code></pre><h3 id="shiro-freemarker页面标签"><a href="#shiro-freemarker页面标签" class="headerlink" title="shiro freemarker页面标签"></a>shiro freemarker页面标签</h3><pre><code class="xml">&lt;!--shiro freemarker页面标签--&gt;&lt;dependency&gt;    &lt;groupId&gt;net.mingsoft&lt;/groupId&gt;    &lt;artifactId&gt;shiro-freemarker-tags&lt;/artifactId&gt;    &lt;version&gt;0.1&lt;/version&gt;&lt;/dependency&gt;</code></pre><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h3><pre><code class="xml">&lt;!-- mysql --&gt;&lt;dependency&gt;    &lt;groupId&gt;mysql&lt;/groupId&gt;    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;    &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;</code></pre><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><h3 id="freemarker"><a href="#freemarker" class="headerlink" title="freemarker"></a>freemarker</h3><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><h3 id="lombok插件"><a href="#lombok插件" class="headerlink" title="lombok插件"></a>lombok插件</h3><pre><code class="xml">&lt;!-- lombok插件 --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;    &lt;artifactId&gt;lombok&lt;/artifactId&gt;    &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;</code></pre><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="java持久化API"><a href="#java持久化API" class="headerlink" title="java持久化API"></a>java持久化API</h3><p>java持久化API，就是类似与ORM的东西，主要用于和数据库交互的，比如Java bean和数据库表的对应关系，这个是JPA的核心包，属于Java EE 标准。<br>如：@Entity和@Table，@Transient注解</p><pre><code class="xml">&lt;!--java持久化API--&gt;&lt;dependency&gt;    &lt;groupId&gt;javax.persistence&lt;/groupId&gt;    &lt;artifactId&gt;persistence-api&lt;/artifactId&gt;    &lt;version&gt;1.0&lt;/version&gt;&lt;/dependency&gt;</code></pre><h3 id="AOP依赖"><a href="#AOP依赖" class="headerlink" title="AOP依赖"></a>AOP依赖</h3><pre><code class="xml">&lt;!-- AOP依赖,一定要加,否则权限拦截验证不生效 --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><h1 id="build"><a href="#build" class="headerlink" title="build-"></a>build-</h1><h2 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h2><h3 id="maven打包"><a href="#maven打包" class="headerlink" title="maven打包"></a>maven打包</h3><pre><code class="xml">&lt;plugin&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;    &lt;!-- 当所依赖的其他模块，有启动类的时候，需要以下配置，指定唯一启动类，            本次事例未涉及其他模块有启动类，可自行测试 --&gt;    &lt;configuration&gt;        &lt;!-- 指定该Main Class为全局的唯一入口 --&gt;        &lt;mainClass&gt;com.blackcat.blog.BlogBaseApplication&lt;/mainClass&gt;        &lt;layout&gt;ZIP&lt;/layout&gt;    &lt;/configuration&gt;    &lt;executions&gt;        &lt;execution&gt;            &lt;goals&gt;                &lt;goal&gt;repackage&lt;/goal&gt;&lt;!--可以把依赖的包都打包到生成的Jar包中--&gt;            &lt;/goals&gt;        &lt;/execution&gt;    &lt;/executions&gt;&lt;/plugin&gt;</code></pre><h3 id="11"><a href="#11" class="headerlink" title="11"></a>11</h3><pre><code class="xml"></code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot问题记录</title>
      <link href="/2020/01/16/springboot-error/"/>
      <url>/2020/01/16/springboot-error/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h3 id="Unable-to-start-embedded-Tomcat"><a href="#Unable-to-start-embedded-Tomcat" class="headerlink" title="Unable to start embedded Tomcat"></a>Unable to start embedded Tomcat</h3><p>出现这个错误的原因有很多，不要光看这一个错误信息，继续看下嘛的错误信息。<br>百度上有的说是jdk的问题，换成jdk1.8。我的不是这个问题。<br>我的错误下方还有其他的错误提示：<br>Unable to set initialisation parameters for filter due to null name and/or value. Name [loginUsername], Value [null]</p><h3 id="Unable-to-set-initialisation-parameters-for-filter-due-to-null-name-and-or-value-Name-loginUsername-Value-null"><a href="#Unable-to-set-initialisation-parameters-for-filter-due-to-null-name-and-or-value-Name-loginUsername-Value-null" class="headerlink" title="Unable to set initialisation parameters for filter due to null name and/or value. Name [loginUsername], Value [null]"></a>Unable to set initialisation parameters for filter due to null name and/or value. Name [loginUsername], Value [null]</h3><p>我的造成这个错误主要原因就是druid 的这个loginUsername 参数值没有读到。<br>没读到的原因是我的读取配置文件类的<strong><em>文件地址值</em></strong>写错了，造成无法读取值。<br>错误示例：@ConfigurationProperties(prefix = “blog.druid”) 其中值写错。</p><h3 id="Spring-Boot-Configuration-Annotation-Processor-not"><a href="#Spring-Boot-Configuration-Annotation-Processor-not" class="headerlink" title="Spring Boot Configuration Annotation Processor not.."></a><strong>Spring Boot Configuration Annotation Processor not..</strong></h3><p>Springboot1.5以上版本，在使用 @ConfigurationProperties注解的时候会提示“Spring Boot Configuration Annotation Processor not found in classpath”。<br><strong><em>解决</em></strong>：</p><pre><code class="linux">加入依赖&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;    &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;注解写法@Component@PropertySource(&quot;classpath:application.yml&quot;)@ConfigurationProperties(prefix = &quot;spring.redis&quot;)</code></pre><h3 id="Error-attempting-to-get-column-‘create-time’-from-result-set"><a href="#Error-attempting-to-get-column-‘create-time’-from-result-set" class="headerlink" title="*Error attempting to get column ‘create_time’ from result set. *"></a>*<em>Error attempting to get column ‘create_time’ from result set. *</em></h3><p>Druid版本：1.1.6  Mybatis版本：3.3.1<br>数据库字段：create_time  实体类：createTime<br>xml中：<br><result column="create_time" property="createTime" /><br><result column="update_time" property="updateTime" /></p><p><strong><em>原因</em></strong>：Druid版本过低无法匹配上Mybatis版本<br><strong><em>解决</em></strong>：升Druid版本或降Mybatis版本。我的是将Druid版本提到1.1.18，问题解决。</p><h3 id="java-lang-NoClassDefFoundError-com-github-pagehelper-PageInterceptor"><a href="#java-lang-NoClassDefFoundError-com-github-pagehelper-PageInterceptor" class="headerlink" title="java.lang.NoClassDefFoundError: com/github/pagehelper/PageInterceptor"></a><strong>java.lang.NoClassDefFoundError: com/github/pagehelper/PageInterceptor</strong></h3><p>springboot版本：2.2.0  pagehelper版本：4.1.4<br><strong><em>原因</em></strong>：pagehelper版本过低<br><strong><em>解决</em></strong>：我将pagehelper版本改为5.1.2</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>postman相关</title>
      <link href="/2020/01/13/postman/"/>
      <url>/2020/01/13/postman/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p><a href="https://www.getpostman.com/downloads/" target="_blank" rel="noopener">postman官网下载</a><br><a href="http://www.cnplugins.com/tool/postman-specificate-lession.html" target="_blank" rel="noopener">postman使用手册</a><br><a href="https://blog.csdn.net/fxbin123/article/details/80428216" target="_blank" rel="noopener">Postman 使用方法详解</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> postman </category>
          
      </categories>
      
      
        <tags>
            
            <tag> postman </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker安装MySql及相关命令</title>
      <link href="/2020/01/13/docker-mysql/"/>
      <url>/2020/01/13/docker-mysql/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h3><pre><code class="linux">docker pull mysql:5.7</code></pre><h3 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h3><p>看个人喜好选择命令一或命令二，修改命令内容</p><ul><li>命令一<pre><code class="linux">sudo docker run --name mysql5.7 --restart always --privileged=true -p 3306:3306 -v /opt/mysql/config/mysqld.cnf:/etc/mysql/mysql.conf.d/mysqld.cnf -v /opt/mysql/data:/var/lib/mysql -e MYSQL_USER=&quot;admin&quot; -e MYSQL_PASSWORD=&quot;pwd123&quot; -e MYSQL_ROOT_PASSWORD=&quot;rootpwd123&quot; -d mysql:5.7</code></pre></li><li>命令二<pre><code class="linux">sudo docker run -p 3306:3306 --restart=always --privileged=true --name mysql5.7 -v $PWD/conf:/etc/mysql/conf.d -v $PWD/logs:/logs -v $PWD/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7</code></pre></li></ul><h3 id="配置说明"><a href="#配置说明" class="headerlink" title="配置说明"></a>配置说明</h3><ul><li><code>--name mysql5.7</code>：容器命名</li><li><code>-–restart always</code>：开机启动</li><li><code>-–privileged=true</code>：提升容器内权限</li><li><code>-p 3306:3306</code>： 将容器的 3306 端口映射到主机的 3306 端口。</li><li><code>-v /opt/mysql/config/mysqld.cnf:/etc/mysql/mysql.conf.d/mysqld.cnf</code>：映射配置文件</li><li><code>-v $PWD/conf:/etc/mysql/conf.d</code>： 将主机当前目录下的 conf/my.cnf 挂载到容器的 /etc/mysql/my.cnf。</li><li><code>-v /opt/mysql/data:/var/lib/mysql</code>：映射数据目录</li><li><code>-v $PWD/data:/var/lib/mysql</code>： 将主机当前目录下的data目录挂载到容器的 /var/lib/mysql</li><li><code>-e MYSQL_USER=”admin”</code>：添加用户admin</li><li><code>-e MYSQL_PASSWORD=”123456”</code>：设置admin的密码为123456</li><li><code>-e MYSQL_ROOT_PASSWORD=”rootpwd123456”</code>：设置root的密码为rootpwd123456</li><li><code>-d mysql:5.7</code>：使用的镜像没有找到对应版本自动下载</li><li><code>-v $PWD/logs:/logs</code>： 将主机当前目录下的 logs 目录挂载到容器的 /logs。</li></ul><h2 id="相关命名"><a href="#相关命名" class="headerlink" title="相关命名"></a>相关命名</h2><h3 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h3><pre><code class="linux">docker exec -it b9cfe7a3f15e /bin/bashdocker exec -it mysql /bin/bash</code></pre><h3 id="连接mysql"><a href="#连接mysql" class="headerlink" title="连接mysql"></a>连接mysql</h3><pre><code class="linux">mysql -uroot -p</code></pre><h3 id="查看mysql配置文件my-cnf"><a href="#查看mysql配置文件my-cnf" class="headerlink" title="查看mysql配置文件my.cnf"></a>查看mysql配置文件my.cnf</h3><pre><code class="linux">cat /etc/mysql/my.cnf</code></pre><h3 id="打印日志"><a href="#打印日志" class="headerlink" title="打印日志"></a>打印日志</h3><pre><code class="linux">docker logs mysql</code></pre><h2 id="连接失败"><a href="#连接失败" class="headerlink" title="连接失败"></a>连接失败</h2><h3 id="1-2003-Can’t-connect-to-MySql-server-on-‘XXX’-10038"><a href="#1-2003-Can’t-connect-to-MySql-server-on-‘XXX’-10038" class="headerlink" title="1.2003-Can’t connect to MySql server on ‘XXX’ (10038)"></a>1.2003-Can’t connect to MySql server on ‘XXX’ (10038)</h3><p><img src="/img/docker/error5.png" alt=""></p><ul><li>检查mysql是否启动</li><li>防火墙可能阻止访问(及端口是否正确)</li><li>是否有权限</li></ul><h3 id="2-虚拟机ping得通物理主机，但物理主机ping不通docker容器"><a href="#2-虚拟机ping得通物理主机，但物理主机ping不通docker容器" class="headerlink" title="2.虚拟机ping得通物理主机，但物理主机ping不通docker容器"></a>2.虚拟机ping得通物理主机，但物理主机ping不通docker容器</h3><p>ip信息</p><ul><li>docker:172.17.0.2</li><li>虚拟机centos7: 192.168.0.103</li><li>宿主机（windows）:192.168.0.108</li><li>如果此时在宿主机中ping Docker容器是ping不同的，因为在宿主机上没有通往192.168.1.0/24网络的路由，宿主机会将发往192.168.1.0/24网络的数据发往默认路由，这样就无法到达容器。</li></ul><p>解决方案:  </p><ul><li>1、首先要保证在虚拟机中能够连接到Docker容器中，用ping测试是否通畅</li><li>2、关闭虚拟中的防火墙：<pre><code class="linux">systemctl stop firewalld.service</code></pre></li><li>3、打开宿主机（windows）的cmd,在其中添加通往192.168.1.0/24网络的路由。<pre><code class="linux">ROUTE -p add 172.17.0.0 mask 255.255.0.0 192.168.0.103</code></pre>打印路由信息命令： <code>route print</code></li></ul><p>如果win10执行上述命令出现:<strong>请求的操作需要提升</strong><br><img src="/img/docker/error1.png" alt="请求的操作需要提升"><br>右击开始菜单按钮，Windows Powershell（管理员）即为有管理员权限的cmd，点击进入。再执行该命令即可。<br><img src="/img/docker/error2.png" alt="管理员权限的cmd"></p><h3 id="3-特殊情况"><a href="#3-特殊情况" class="headerlink" title="3.特殊情况"></a>3.特殊情况</h3><p>开发中使用网络发现改变，依循<code>问题二</code>尝试解决宿主机不能访问容器问题，未解决问题。导致访问MySQL出现<code>问题一</code>的状况。<br>解决办法：<br>访问MySQL使用容器ip,直接使用虚拟机ip跟创建容器时使用的映射端口。如：4306<br>后续尝试解决该问题。</p><h3 id="4-client-does-not-support"><a href="#4-client-does-not-support" class="headerlink" title="4.client does not support .."></a>4.client does not support ..</h3><ul><li>出现问题：<br><img src="/img/docker/error3.png" alt=""></li><li>解决方法：<pre><code class="linux">select host,user,plugin,authentication_string from mysql.user;</code></pre><img src="/img/docker/error4.png" alt="查询结果"></li><li><code>host</code>为 <code>%</code> 表示不限制ip，<code>localhost</code>表示本机使用 plugin非<code>mysql_native_password</code>则需要修改密码</li><li>mysql8.* 的新特性 <code>caching_sha2_password</code> 密码加密方式</li><li>以前版本的mysql密码加密使用的是 <code>mysql_native_password</code></li><li>新添加的用户密码默认使用的 <code>caching_sha2_password</code><pre><code class="linux">ALTER USER &#39;root&#39;@&#39;%&#39; IDENTIFIED WITH mysql_native_password BY &#39;123456&#39;;-- 任何远程主机都可以访问数据库  flush privileges; -- 输入次命令使修改生效</code></pre></li></ul><h3 id="Can’t-connect-to-MySQL-server-on-111-“Connection-refused”"><a href="#Can’t-connect-to-MySQL-server-on-111-“Connection-refused”" class="headerlink" title="Can’t connect to MySQL server on (111 “Connection refused”)"></a>Can’t connect to MySQL server on (111 “Connection refused”)</h3><p>解决方法：</p><ul><li>找到MySQL的mysql.conf.d文件夹路径</li><li>vi mysqld.cnf</li><li>将 bind_address 127.0.0.1 注释掉</li></ul><h3 id="navicat可以使用localhost登陆不能使用IP"><a href="#navicat可以使用localhost登陆不能使用IP" class="headerlink" title="navicat可以使用localhost登陆不能使用IP"></a>navicat可以使用localhost登陆不能使用IP</h3><p>Host ‘host.docker.internal’ is not allowed to connect to this MySQL server<br>问题：<br>可能是你的帐号不允许从远程登陆，只能在localhost。这个时候只要在localhost的那台电脑，登入mysql后，更改 “mysql” 数据库里的 “user” 表里的 “host” 项，从”localhost”改称”%”<br>解决：</p><pre><code class="linux">select host, user from user;-- 查询update user set host = &#39;%&#39; where user = &#39;root&#39;;--修改flush privileges;-- 输入次命令使修改生效</code></pre><h3 id="08001-Could-not-create-connection-to-database-server-Attempted-reconnect-3-times-Giving-up"><a href="#08001-Could-not-create-connection-to-database-server-Attempted-reconnect-3-times-Giving-up" class="headerlink" title="[08001] Could not create connection to database server. Attempted reconnect 3 times. Giving up."></a>[08001] Could not create connection to database server. Attempted reconnect 3 times. Giving up.</h3><p>在连接字符串后面加上?serverTimezone=UTC。其中UTC是统一标准世界时间。<br>完整的连接字符串示例：jdbc:mysql://localhost:3306/test?serverTimezone=UTC<br>jdbc:mysql://127.0.0.1:3306/test?useUnicode=true&amp;characterEncoding=UTF-8，这个是解决中文乱码输入问题，可以和上面的一起结合。</p><h2 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h2><h3 id="Err-1055-Expression"><a href="#Err-1055-Expression" class="headerlink" title="[Err] 1055 - Expression"></a>[Err] 1055 - Expression</h3><ul><li>查看下SQL的模式<pre><code class="linux">SHOW VARIABLES LIKE &#39;%sql_mode%&#39;;  </code></pre></li><li>修改sql_mode的值：<pre><code class="linux">set sql_mode = &#39;NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES&#39;;//只是当前会话的，重新进入MySQL后问题依然存在SET GLOBAL sql_mode=(SELECT REPLACE(@@sql_mode,&#39;ONLY_FULL_GROUP_BY&#39;,&#39;&#39;)); </code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> MySql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker命令</title>
      <link href="/2020/01/07/docker-command/"/>
      <url>/2020/01/07/docker-command/</url>
      
        <content type="html"><![CDATA[<p>docker命令搜集</p><a id="more"></a><h3 id="搜索镜像"><a href="#搜索镜像" class="headerlink" title="搜索镜像"></a>搜索镜像</h3><blockquote><p>网页搜索</p></blockquote><ul><li><a href="https://cr.console.aliyun.com/cn-hangzhou/instances/images" target="_blank" rel="noopener">阿里云容器镜像服务</a></li><li><a href="https://hub.docker.com" target="_blank" rel="noopener">docker官网</a></li></ul><blockquote><p>命令搜索</p></blockquote><pre><code class="linux">docker search xx</code></pre><p>输出列含义如下：</p><ul><li>NAME:镜像仓库名称。</li><li>DESCRIPTION:镜像仓库描述。- STARS：镜像仓库收藏数，表示该镜像仓库的受欢迎程度，类似于 GitHub的 stars0</li><li>OFFICAL:表示是否为官方仓库，该列标记为[0K]的镜像均由各软件的官方项目组创建和维<br>护。</li><li>AUTOMATED：表示是否是自动构建的镜像仓库。</li></ul><h3 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h3><pre><code class="linux">docker pull &lt;镜像名:tag&gt;docker pull centos 下载centos镜像docker pull &lt;镜像名:tag&gt;:latest 下载最新版本docker pull &lt;镜像名:tag&gt;:5.7 下载指定版本</code></pre><h3 id="查看已下载镜像"><a href="#查看已下载镜像" class="headerlink" title="查看已下载镜像"></a>查看已下载镜像</h3><pre><code class="linux">docker images</code></pre><p>说明：</p><ul><li>-a :列出本地所有的镜像（含中间映像层，默认情况下，过滤掉中间映像层）；</li><li>–digests :显示镜像的摘要信息；</li><li>-f :显示满足条件的镜像；</li><li>–format :指定返回值的模板文件；</li><li>–no-trunc :显示完整的镜像信息；</li><li>-q :只显示镜像ID。</li></ul><p>输出列含义如下</p><ul><li>REPOSITORY：镜像所属仓库名称。</li><li>TAG:镜像标签。默认是 latest,表示最新。</li><li>IMAGE ID：镜像 ID，表示镜像唯一标识。</li><li>CREATED：镜像创建时间。</li><li>SIZE: 镜像大小。</li></ul><h3 id="docker-exec-ti-percona-mysql-u-root-p"><a href="#docker-exec-ti-percona-mysql-u-root-p" class="headerlink" title="docker exec -ti  percona mysql -u root -p"></a>docker exec -ti  percona mysql -u root -p</h3><p>OPTIONS说明：<br>-d :分离模式: 在后台运行<br>-i :即使没有附加也保持STDIN 打开<br>-t :分配一个伪终端</p><h3 id="查看容器日志"><a href="#查看容器日志" class="headerlink" title="查看容器日志"></a>查看容器日志</h3><pre><code class="linux">docker logs -f &lt;容器名 or ID&gt;docker container &lt;容器名 or ID&gt;</code></pre><h3 id="查看容器所有信息"><a href="#查看容器所有信息" class="headerlink" title="查看容器所有信息"></a>查看容器所有信息</h3><pre><code class="linux">docker inspect &lt;容器名 or ID&gt;</code></pre><h3 id="查看容器里的进程"><a href="#查看容器里的进程" class="headerlink" title="查看容器里的进程"></a>查看容器里的进程</h3><pre><code class="linux">docker top  &lt;容器名 or ID&gt;</code></pre><h3 id="查看正在运行的容器"><a href="#查看正在运行的容器" class="headerlink" title="查看正在运行的容器"></a>查看正在运行的容器</h3><pre><code class="linux">docker ps</code></pre><p>说明：<br>-a :显示所有的容器，包括未运行的。<br>-f :根据条件过滤显示的内容。<br>–format :指定返回值的模板文件。<br>-l :显示最近创建的容器。<br>-n :列出最近创建的n个容器。<br>–no-trunc :不截断输出。<br>-q :静默模式，只显示容器编号。<br>-s :显示总的文件大小。</p><p>如需列出所有容器（包括已停止的容器），可使用-a参数。该列表包含了7列，含义如下</p><ul><li>CONTAINER_ID：表示容器 ID。</li><li>IMAGE:表示镜像名称。</li><li>COMMAND：表示启动容器时运行的命令。</li><li>CREATED：表示容器的创建时间。</li><li>STATUS：表示容器运行的状态。UP表示运行中， Exited表示已停止。</li><li>PORTS:表示容器对外的端口号。- NAMES:表示容器名称。该名称默认由 Docker自动生成，也可使用 docker run命令的–name选项自行指定。</li></ul><h3 id="查看所有的容器，包括已经停止的。"><a href="#查看所有的容器，包括已经停止的。" class="headerlink" title="查看所有的容器，包括已经停止的。"></a>查看所有的容器，包括已经停止的。</h3><p>具体参数参考上一个命令解释</p><pre><code class="linux">docker ps -a</code></pre><h3 id="查看容器ip"><a href="#查看容器ip" class="headerlink" title="查看容器ip"></a>查看容器ip</h3><pre><code class="linux">docker inspect 容器ID | grep IPAddress</code></pre><h3 id="查看所有容器ip"><a href="#查看所有容器ip" class="headerlink" title="查看所有容器ip"></a>查看所有容器ip</h3><pre><code class="linux">docker inspect -f=&#39;{{.NetworkSettings.IPAddress}}&#39; $(sudo docker ps -a -q)</code></pre><h3 id="列出所有容器对应的名称，端口，及ip"><a href="#列出所有容器对应的名称，端口，及ip" class="headerlink" title="列出所有容器对应的名称，端口，及ip"></a>列出所有容器对应的名称，端口，及ip</h3><pre><code class="linux">docker inspect -f=&#39;{{.Name}} {{.NetworkSettings.IPAddress}} {{.HostConfig.PortBindings}}&#39; $(docker ps -aq)</code></pre><h3 id="查看docker-name"><a href="#查看docker-name" class="headerlink" title="查看docker name"></a>查看docker name</h3><pre><code class="linux">sudo docker inspect -f=&#39;{{.Name}}&#39; $(sudo docker ps -a -q)</code></pre><h3 id="新建并启动一个容器"><a href="#新建并启动一个容器" class="headerlink" title="新建并启动一个容器"></a>新建并启动一个容器</h3><pre><code class="linux">docker run -d &lt;Other Parameters&gt;docker run -d -p 127.0.0.1:33301:22 centos6-ssh</code></pre><p>说明： </p><ul><li>-a stdin: 指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项；</li><li>-d: 后台运行容器，并返回容器ID；</li><li>-i: 以交互模式运行容器，通常与 -t 同时使用；</li><li>–p: 端口映射，格式为：主机(宿主)端口:容器端口</li><li>t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用；</li><li>–name=”nginx-lb”: 为容器指定一个名称；</li><li>–dns 8.8.8.8: 指定容器使用的DNS服务器，默认和宿主一致；</li><li>–dns-search example.com: 指定容器DNS搜索域名，默认和宿主一致；</li><li>-h “mars”: 指定容器的hostname；</li><li>-e username=”ritchie”: 设置环境变量；</li><li>–env-file=[]: 从指定文件读入环境变量；</li><li>–cpuset=”0-2” or –cpuset=”0,1,2”: 绑定容器到指定CPU运行；</li><li>-m :设置容器使用内存最大值；</li><li>–net=”bridge”: 指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型；</li><li>–link=[]: 添加链接到另一个容器；</li><li>–expose=[]: 开放一个端口或一组端口；</li></ul><h3 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h3><p>使用docker exec命令用于进入一个正在运行的docker容器。如果docker run命令运行容器的时候，没有使用-it参数，就要用这个命令进入容器。一旦进入了容器，就可以在容器的 Shell执行命令了</p><pre><code class="linux">docker exec -it &lt;ID&gt; /bin/bash</code></pre><h3 id="删除本地一个或多少镜像"><a href="#删除本地一个或多少镜像" class="headerlink" title="删除本地一个或多少镜像"></a>删除本地一个或多少镜像</h3><pre><code class="linux">docker rmi [OPTIONS] IMAGE [IMAGE...]</code></pre><p>OPTIONS说明：<br>-f :强制删除；<br>–no-prune :不移除该镜像的过程镜像，默认移除；</p><h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><p>该命令只能删除已停止的容器，如需删除正在运行的容器，可使用-f参数</p><pre><code class="linux">docker rm &lt;容器名 or ID&gt;</code></pre><p>说明：</p><ul><li>-f :通过SIGKILL信号强制删除一个运行中的容器</li><li>-l :移除容器间的网络连接，而非容器本身</li><li>-v :-v 删除与容器关联的卷</li></ul><h3 id="删除所有容器"><a href="#删除所有容器" class="headerlink" title="删除所有容器"></a>删除所有容器</h3><pre><code class="linux">docker rm $(docker ps -a -q)</code></pre><h3 id="停止、启动、杀死指定容器"><a href="#停止、启动、杀死指定容器" class="headerlink" title="停止、启动、杀死指定容器"></a>停止、启动、杀死指定容器</h3><p>使用docker run命令，即可新建并启动一个容器。对于已停止的容器，可使用 docker start命令来启动</p><pre><code class="linux">docker start &lt;容器名 or ID&gt; # 启动容器 docker stop &lt;容器名 or ID&gt; # 启动容器docker kill &lt;容器名 or ID&gt; # 杀死容器</code></pre><h3 id="重启docker服务"><a href="#重启docker服务" class="headerlink" title="重启docker服务"></a>重启docker服务</h3><pre><code class="linux">service docker restart</code></pre><h3 id="在运行的容器中执行命令"><a href="#在运行的容器中执行命令" class="headerlink" title="在运行的容器中执行命令"></a>在运行的容器中执行命令</h3><pre><code class="linux">docker exec [OPTIONS] CONTAINER COMMAND [ARG...]</code></pre><p>说明：</p><ul><li>-d :分离模式: 在后台运行</li><li>-i :即使没有附加也保持STDIN 打开</li><li>-t :分配一个伪终端</li></ul><h3 id="暴露端口：-一共有三种形式进行端口映射"><a href="#暴露端口：-一共有三种形式进行端口映射" class="headerlink" title="暴露端口： 一共有三种形式进行端口映射"></a>暴露端口： 一共有三种形式进行端口映射</h3><ul><li>映射本机3306端口到容器的3306端口 docker -p 127.0.0.1:3306:3306<pre><code class="linux">docker -p ip:hostPort:containerPort # 映射指定地址的主机端口到容器端口</code></pre></li><li>映射本机的随机可用端口到容器3306端口 docker -p 127.0.0.1::3306 <pre><code class="linux">docker -p ip::containerPort # 映射指定地址的任意可用端口到容器端口</code></pre></li><li>映射本机的3306端口到容器的3306端口 docker -p 3306:3306<pre><code class="linux">docer -p hostPort:containerPort # 映射本机的指定端口到容器的指定端口</code></pre></li></ul><h3 id="映射数据卷"><a href="#映射数据卷" class="headerlink" title="映射数据卷"></a>映射数据卷</h3><pre><code class="linux">docker -v /home/data:/opt/data # 这里/home/data 指的是宿主机的目录地址，后者则是容器的目录地址</code></pre><h3 id="build-命令用于使用-Dockerfile-创建镜像"><a href="#build-命令用于使用-Dockerfile-创建镜像" class="headerlink" title="build 命令用于使用 Dockerfile 创建镜像"></a>build 命令用于使用 Dockerfile 创建镜像</h3><pre><code class="linux">docker build [OPTIONS] PATH | URL | -</code></pre><p>OPTIONS说明：<br>–build-arg=[] :设置镜像创建时的变量；<br>–cpu-shares :设置 cpu 使用权重；<br>–cpu-period :限制 CPU CFS周期；<br>–cpu-quota :限制 CPU CFS配额；<br>–cpuset-cpus :指定使用的CPU id；<br>–cpuset-mems :指定使用的内存 id；<br>–disable-content-trust :忽略校验，默认开启；<br>-f :指定要使用的Dockerfile路径；<br>–force-rm :设置镜像过程中删除中间容器；<br>–isolation :使用容器隔离技术；<br>–label=[] :设置镜像使用的元数据；<br>-m :设置内存最大值；<br>–memory-swap :设置Swap的最大值为内存+swap，”-1”表示不限swap；<br>–no-cache :创建镜像的过程不使用缓存；<br>–pull :尝试去更新镜像的新版本；<br>–quiet, -q :安静模式，成功后只输出镜像 ID；<br>–rm :设置镜像成功后删除中间容器；<br>–shm-size :设置/dev/shm的大小，默认值是64M；<br>–ulimit :Ulimit配置。<br>–tag, -t: 镜像的名字及标签，通常 name:tag 或者 name 格式；可以在一次构建中为一个镜像设置多个标签。<br>–network: 默认 default。在构建期间设置RUN指令的网络模式</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>创建SpringBoot项目</title>
      <link href="/2020/01/07/SpringBoot-Create/"/>
      <url>/2020/01/07/SpringBoot-Create/</url>
      
        <content type="html"><![CDATA[<h3 id="项目搭建"><a href="#项目搭建" class="headerlink" title="项目搭建"></a>项目搭建</h3><p>创建一个简单的springboot项目</p><a id="more"></a><blockquote><p>在界面左上角选择File-&gt;New-&gt;Project后，选择Spring Initializr，默认使用的Java版本是1.8。(创建根项目) </p></blockquote><p>如果添加完成是出现<code>连接超时</code>可查看下方解决方法</p><p><img src="/img/ssm/create01.png" alt=""></p><ul><li>groupId是项目组织唯一的标识符，实际对应JAVA的包的结构</li><li>artifactId是项目的唯一的标识符，实际对应项目的名称，就是项目根目录的名称。<br>举个apache公司的tomcat项目例子：这个项目的groupId是org.apache，它的域是org，公司名称是apache，artifactId是tomcat。包结构package最好是以groupId.artifactId打头的。</li></ul><blockquote><p>选择文件夹地址 </p></blockquote><p>点击Next，进入选择dependency的界面，作用是在pom中自动添加一些依赖，作用是在项目开始时就下载。这里不勾选任何依赖。</p><p><img src="/img/ssm/create04.png" alt=""></p><blockquote><p>建立子模块</p></blockquote><p><img src="/img/ssm/create05.png" alt=""><br><img src="/img/ssm/create06.png" alt=""></p><blockquote><p>选择依赖，这里项目是web项目用的freemarker模板这里就直接选了</p></blockquote><p><img src="/img/ssm/create07.png" alt=""><br><img src="/img/ssm/create08.png" alt=""></p><blockquote><p>选择文件夹地址</p></blockquote><p><img src="/img/ssm/create09.png" alt=""></p><blockquote><p>把下图选中的无用的文件及文件夹删掉，包括两个模块的mvnw、mvnw.cmd文件及.mvn文件夹，还有父模块的src目录，因为此处的父模块只做依赖管理，不需要编写代码。 </p></blockquote><p><img src="/img/ssm/create011.png" alt=""></p><blockquote><p>配置依赖项目的依赖关系<br><strong>注意根项目<code>modules</code>及子项目的<code>parent</code></strong></p></blockquote><p>根项目pom.xml配置文件</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;modules&gt;        &lt;module&gt;blog-base&lt;/module&gt;    &lt;/modules&gt;    &lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;        &lt;version&gt;2.2.2.RELEASE&lt;/version&gt;        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;    &lt;/parent&gt;    &lt;groupId&gt;com.blackcat&lt;/groupId&gt;    &lt;artifactId&gt;blackcat-blog&lt;/artifactId&gt;    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;    &lt;name&gt;blackcat-blog&lt;/name&gt;    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;    &lt;properties&gt;        &lt;java.version&gt;1.8&lt;/java.version&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;            &lt;scope&gt;test&lt;/scope&gt;            &lt;exclusions&gt;                &lt;exclusion&gt;                    &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;                    &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;                &lt;/exclusion&gt;            &lt;/exclusions&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;</code></pre><p>blog-base项目pom.xml配置文件</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;parent&gt;        &lt;artifactId&gt;blackcat-blog&lt;/artifactId&gt;        &lt;groupId&gt;com.blackcat&lt;/groupId&gt;        &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;    &lt;/parent&gt;    &lt;groupId&gt;com.blackcat&lt;/groupId&gt;    &lt;artifactId&gt;blog-base&lt;/artifactId&gt;    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;    &lt;name&gt;blog-base&lt;/name&gt;    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;    &lt;properties&gt;        &lt;java.version&gt;1.8&lt;/java.version&gt;    &lt;/properties&gt;&lt;/project&gt;</code></pre><ul><li>项目测试<br><img src="/img/ssm/create012.png" alt=""></li><li>运行结果<br><img src="/img/ssm/creat18.png" alt=""></li><li>写个测试controller<br><img src="/img/ssm/create013.png" alt=""></li><li>返回结果<br><img src="/img/ssm/create014.png" alt=""></li></ul><h3 id="连接超时"><a href="#连接超时" class="headerlink" title="连接超时"></a>连接超时</h3><ul><li>1、IDEA设置问题(我使用该方法解决)<br>点击IDEA setting之后，找到Http Proxy 选择Atuo-detect proxy settings 之后点击check connection<br>输入<code>http://start.spring.io</code>或者是<code>https://start.spring.io</code> 点击ok，直到弹出connection successful。这时就可以再次回到创建项目的步骤了。</li><li>2、网络问题，换个网络试试(百度有说此方法未尝试)</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mybatis plus mysql 代码生成器</title>
      <link href="/2020/01/07/mybatis-plus-generator/"/>
      <url>/2020/01/07/mybatis-plus-generator/</url>
      
        <content type="html"><![CDATA[<p>mybatis plus mysql 代码生成器 简单示例<br>文章结束附源码。</p><a id="more"></a><blockquote><p>添加依赖</p></blockquote><pre><code class="xml">        &lt;!-- mysql 代码生成器必须引入--&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;            &lt;version&gt;5.1.46&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- druid 代码生成器必须引入--&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;            &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;            &lt;version&gt;1.1.10&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- mybatis plus 代码生成器必须引入--&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;            &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;            &lt;version&gt;3.1.0&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- mybatis plus 代码生成器依赖 代码生成器必须引入--&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;            &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt;            &lt;version&gt;3.1.0&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- 代码生成器模板 代码生成器必须引入--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.freemarker&lt;/groupId&gt;            &lt;artifactId&gt;freemarker&lt;/artifactId&gt;            &lt;version&gt;2.3.28&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- lombok 代码生成器必须引入--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;            &lt;artifactId&gt;lombok&lt;/artifactId&gt;            &lt;optional&gt;true&lt;/optional&gt;            &lt;version&gt;1.16.22&lt;/version&gt;        &lt;/dependency&gt;</code></pre><blockquote><p>java代码</p></blockquote><pre><code class="java">package com.blackcat.blog.util;import com.baomidou.mybatisplus.annotation.FieldFill;import com.baomidou.mybatisplus.core.toolkit.StringPool;import com.baomidou.mybatisplus.core.toolkit.StringUtils;import com.baomidou.mybatisplus.generator.AutoGenerator;import com.baomidou.mybatisplus.generator.InjectionConfig;import com.baomidou.mybatisplus.generator.config.*;import com.baomidou.mybatisplus.generator.config.po.TableFill;import com.baomidou.mybatisplus.generator.config.po.TableInfo;import com.baomidou.mybatisplus.generator.config.rules.NamingStrategy;import com.baomidou.mybatisplus.generator.engine.FreemarkerTemplateEngine;import java.util.*;/** * mybatis plus mysql 代码生成器 * @author: blackcat * @date: 2020/1/6 17:22 * @Param*/public class MysqlGenerator {    public static void main(String[] args) {        Map&lt;String, String&gt; param = new HashMap&lt;&gt;();        param.put(&quot;projectPath&quot;,&quot;D:\\project\\blackcat-blog\\blog-base&quot;);// 代码输出项目地址        param.put(&quot;author&quot;,&quot;blackcat&quot;);// 作者        param.put(&quot;url&quot;,&quot;172.17.0.3:3306/blackcat_blog&quot;);// ip/数据库        param.put(&quot;driverName&quot;,&quot;com.mysql.jdbc.Driver&quot;);        param.put(&quot;username&quot;,&quot;root&quot;);// 数据库用户        param.put(&quot;password&quot;,&quot;111111&quot;);// 数据库密码        param.put(&quot;parent&quot;,&quot;com.blackcat.blog&quot;);// 顶层包结构        param.put(&quot;mapper&quot;,&quot;mapper&quot;);// 生成的mapper包名        param.put(&quot;entity&quot;,&quot;entity&quot;);// 生成的entity包名        param.put(&quot;service&quot;,&quot;service&quot;);// 生成的service包名        param.put(&quot;serviceImpl&quot;,&quot;service.impl&quot;);// 生成的serviceImpl包名        param.put(&quot;xml&quot;,&quot;mappers&quot;);// 生成的mapper.xml包名        param.put(&quot;model&quot;,&quot;&quot;);// 生成的mapper.xml包名下的模块名称 空则无 如:mappers.shiro        param.put(&quot;xmlName&quot;,&quot;Mapper&quot;);// 生成的mapper.xml的文件结尾名称如UserMapper.xml        // 设置模板 freemarker模板:/templates/mapper.xml.ftl  velocity模板:/templates/mapper.xml.vm        param.put(&quot;templatePath&quot;,&quot;/templates/mapper.xml.ftl&quot;);//        param.put(&quot;table&quot;,&quot;&quot;);//数据库表名 一张表时使用        // 多表时使用,当数组大于0时使用数组        // 示例:String[] tablse={&quot;sys_menu&quot;,&quot;sys_role&quot;,&quot;sys_role_menu&quot;,&quot;sys_user_role&quot;,&quot;sys_user_role&quot;};// shiro所需表        // shiro所需表        String[] tablse={&quot;sys_menu&quot;,&quot;sys_role&quot;,&quot;sys_role_menu&quot;,&quot;sys_user&quot;,&quot;sys_user_role&quot;};        generator(param,tablse);    }    /* *     * 代码生成     * @author: blackcat     * @date: 2020/1/7 13:44     * @Param [param]    */    public static void generator(Map&lt;String, String&gt; param,String[] tablse){        // 代码生成器        AutoGenerator mpg = new AutoGenerator();        // 全局配置        GlobalConfig gc = new GlobalConfig();        gc.setOutputDir(param.get(&quot;projectPath&quot;) + &quot;/src/main/java&quot;);        gc.setAuthor(param.get(&quot;author&quot;));        gc.setOpen(false);// 是否打开输出目录        gc.setServiceName(&quot;%sService&quot;);// service 命名方式        gc.setServiceImplName(&quot;%sServiceImpl&quot;);// service impl 命名方式        gc.setMapperName(&quot;%sMapper&quot;);// 自定义文件命名，注意 %s 会自动填充表实体属性！        gc.setXmlName(&quot;%sMapper&quot;);// 自定义文件命名，注意 %s 会自动填充表实体属性！        gc.setFileOverride(true);// 是否覆盖已有文件        gc.setActiveRecord(true);// 开启 ActiveRecord(活动记录) 模式        gc.setEnableCache(false);// XML 二级缓存        gc.setBaseResultMap(true);// XML 开启 BaseResultMap        gc.setBaseColumnList(false);// XML columList        mpg.setGlobalConfig(gc);        // 数据源配置        DataSourceConfig dsc = new DataSourceConfig();        dsc.setUrl(&quot;jdbc:mysql://&quot;+param.get(&quot;url&quot;)+&quot;?useUnicode=true&amp;useSSL=false&amp;characterEncoding=utf8&amp;serverTimezone=UTC&quot;);        dsc.setDriverName(param.get(&quot;driverName&quot;));        dsc.setUsername(param.get(&quot;username&quot;));        dsc.setPassword(param.get(&quot;password&quot;));        mpg.setDataSource(dsc);        // 包配置        PackageConfig pc = new PackageConfig();        if(!StringUtils.isEmpty(param.get(&quot;model&quot;))){            pc.setModuleName(param.get(&quot;model&quot;));        }        pc.setParent(param.get(&quot;parent&quot;));        pc.setMapper(param.get(&quot;mapper&quot;));        pc.setEntity(param.get(&quot;entity&quot;));        pc.setService(param.get(&quot;service&quot;));        pc.setServiceImpl(param.get(&quot;serviceImpl&quot;));        pc.setXml(param.get(&quot;xml&quot;));        mpg.setPackageInfo(pc);        // 自定义需要填充的字段        List&lt;TableFill&gt; tableFillList = new ArrayList();        //如 每张表都有一个创建时间、修改时间如下是配置        TableFill createField = new TableFill(&quot;gmt_create&quot;, FieldFill.INSERT);        TableFill modifiedField = new TableFill(&quot;gmt_modified&quot;, FieldFill.INSERT_UPDATE);        tableFillList.add(createField);        tableFillList.add(modifiedField);        // 自定义配置        InjectionConfig cfg = new InjectionConfig() {            @Override            public void initMap() {                // to do nothing            }        };        // 模板引擎        String templatePath = param.get(&quot;templatePath&quot;);        // 自定义输出配置        List&lt;FileOutConfig&gt; focList = new ArrayList&lt;&gt;();        // 自定义配置会被优先输出 这里设置xml的存放路径        focList.add(new FileOutConfig(templatePath) {            @Override            public String outputFile(TableInfo tableInfo) {                // 自定义输出文件名                StringBuilder customPath = new StringBuilder();                customPath.append(param.get(&quot;projectPath&quot;));                customPath.append(&quot;/src/main/resources/&quot;);                customPath.append(param.get(&quot;xml&quot;));                customPath.append(&quot;/&quot;);                if(!StringUtils.isEmpty(pc.getModuleName())){                    customPath.append(pc.getModuleName());                }                customPath.append(&quot;/&quot;);                customPath.append(tableInfo.getEntityName());                customPath.append(param.get(&quot;xmlName&quot;));                customPath.append(StringPool.DOT_XML);               /* return param.get(&quot;projectPath&quot;) + &quot;/src/main/resources/&quot;+param.get(&quot;xml&quot;)+&quot;/&quot;                        + &quot;/&quot; + tableInfo.getEntityName() + &quot;Mapper&quot; + StringPool.DOT_XML;*/                return customPath.toString();            }        });        cfg.setFileOutConfigList(focList);        mpg.setCfg(cfg);        // 策略配置        StrategyConfig strategy = new StrategyConfig();        //数据库表映射到实体的命名策略，默认：不做任何改变，原样输出        strategy.setNaming(NamingStrategy.underline_to_camel);        //数据库表字段映射到实体的命名策略，未指定按照 naming 执行        strategy.setColumnNaming(NamingStrategy.underline_to_camel);        strategy.setEntityLombokModel(true);// 是否使用lombok        if (tablse.length &gt; 0) {            strategy.setInclude(tablse);// 数据库表 多表        } else {            strategy.setInclude(param.get(&quot;table&quot;));// 数据库表 一张表        }        strategy.setControllerMappingHyphenStyle(true);// 驼峰转连字符        //strategy.setSuperControllerClass(&quot;com.sxt.BaseController&quot;);// 公共父类        //strategy.setSuperEntityColumns(&quot;person_id&quot;,&quot;person_name&quot;);// 写于父类中的公共字段        //strategy.setInclude((&quot;表名，多个英文逗号分割&quot;).split(&quot;,&quot;));//要设置生成哪些表 如果不设置就是生成所有的表        mpg.setStrategy(strategy);// 数据库表配置        // 选择 freemarker 引擎需要指定如下加，注意 pom 依赖必须有！ 默认 Veloctiy        mpg.setTemplateEngine(new FreemarkerTemplateEngine());        mpg.execute();    }}</code></pre><p>源码：<a href="https://github.com/kylin-lawliet/blackcat-blog-web/tree/master/dome-mybatis-plus-generator" target="_blank" rel="noopener">https://github.com/kylin-lawliet/blackcat-blog-web/tree/master/dome-mybatis-plus-generator</a></p><p>简单版：MysqlGenerator<br>参数修改版：MysqlGenerator2<br>自定义模板：MysqlGenerator3</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> MyBatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
            <tag> MySql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网站收藏（工作）</title>
      <link href="/2020/01/06/website-official/"/>
      <url>/2020/01/06/website-official/</url>
      
        <content type="html"><![CDATA[<p>整理收藏的各种网址</p><a id="more"></a><h3 id="社区"><a href="#社区" class="headerlink" title="社区"></a>社区</h3><p><a href="https://www.csdn.net/" target="_blank" rel="noopener">CSND</a>&nbsp;&nbsp;&nbsp;<a href="https://www.hellojava.com/" target="_blank" rel="noopener">Java菜鸟社区</a>&nbsp;&nbsp;&nbsp;<a href="https://www.cnblogs.com/" target="_blank" rel="noopener">博客园</a>&nbsp;&nbsp;&nbsp;<a href="https://www.oschina.net/" target="_blank" rel="noopener">开源中国</a>&nbsp;&nbsp;<a href="https://www.zhihu.com/topic/19554298/top-answers" target="_blank" rel="noopener">知乎</a></p><h3 id="在线工具"><a href="#在线工具" class="headerlink" title="在线工具"></a>在线工具</h3><p><a href="http://www.txttool.com/wenben_strcompress.asp" target="_blank" rel="noopener">在线文本处理工具</a>&nbsp;&nbsp;&nbsp;<a href="http://web.chacuo.net/formatjson" target="_blank" rel="noopener">在线代码美化工具</a>&nbsp;&nbsp;&nbsp;<a href="https://www.mdeditor.com/" target="_blank" rel="noopener">在线markdown编辑器</a><br><a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html" target="_blank" rel="noopener">数据结构可视化</a>&nbsp;&nbsp;&nbsp;<a href="http://www.websocket-test.com/" target="_blank" rel="noopener">WebSocket 在线测试</a>  <a href="http://patorjk.com/software/taag" target="_blank" rel="noopener">ASCII字符画生成工具</a></p><h3 id="开发文档"><a href="#开发文档" class="headerlink" title="开发文档"></a>开发文档</h3><p><a href="https://developer.aliyun.com/special/tech-java?spm=a2c41.13037006.0.0" target="_blank" rel="noopener">阿里巴巴Java开发手册</a>&nbsp;&nbsp;&nbsp;<a href="http://svn.apache.org/repos/asf/httpd/httpd/trunk/docs/conf/mime.types" target="_blank" rel="noopener">文件媒体类型大全</a>&nbsp;&nbsp;&nbsp;<a href="https://man.linuxde.net/" target="_blank" rel="noopener">Linux 命令大全</a>&nbsp;&nbsp;&nbsp;<a href="https://cloud.tencent.com/document/product/302/19903" target="_blank" rel="noopener">HTTP 状态码</a>&nbsp;&nbsp;&nbsp;<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API" target="_blank" rel="noopener">Web API 接口参考(中文)</a>&nbsp;&nbsp;&nbsp;<a href="https://www.npmjs.com/package/xlsx" target="_blank" rel="noopener">xlsx参考手册(英文)</a>&nbsp;&nbsp;&nbsp;<a href="https://apireference.aspose.com/java/cells/com.aspose.cells/WorkBook" target="_blank" rel="noopener">aspose文档(英文)</a>&nbsp;&nbsp;&nbsp;<br><a href="https://hexo.io/zh-cn/docs/front-matter" target="_blank" rel="noopener">Hexo开发文档(中文)</a>   <a href="https://junit.org/junit5/docs/current/user-guide/#overview-what-is-junit-5" target="_blank" rel="noopener">junit5开发文档(英文)</a></p><h3 id="源码托管"><a href="#源码托管" class="headerlink" title="源码托管"></a>源码托管</h3><p><a href="https://gitee.com/" target="_blank" rel="noopener">码云</a>&nbsp;&nbsp;&nbsp;<a href="https://github.com/" target="_blank" rel="noopener">github</a></p><h3 id="资源搜索"><a href="#资源搜索" class="headerlink" title="资源搜索"></a>资源搜索</h3><p><a href="https://www.cn-ki.net/" target="_blank" rel="noopener">iData 知识搜索</a>&nbsp;&nbsp;&nbsp;<a href="https://www.w3school.com.cn/h.asp" target="_blank" rel="noopener">w3school</a>&nbsp;&nbsp;&nbsp;<a href="https://www.91sotu.com/" target="_blank" rel="noopener">搜图导航</a>&nbsp;&nbsp;&nbsp;<br><a href="http://www.demodashi.com/" target="_blank" rel="noopener">Demo大师</a>&nbsp;&nbsp;&nbsp;<a href="http://www.cssmoban.com/" target="_blank" rel="noopener">网站模板</a>  <a href="http://www.cssmoban.com/" target="_blank" rel="noopener">菜鸟</a>  <a href="https://hellogithub.com/" target="_blank" rel="noopener">hellogithub</a><br><a href="http://fontawesome.dashgame.com/" target="_blank" rel="noopener">FontAwesome 字体图标库</a>&nbsp;&nbsp;&nbsp;<a href="https://www.iconfont.cn/home/index?spm=a313x.7781069.1998910419.2" target="_blank" rel="noopener">阿里巴巴图标库</a>&nbsp;&nbsp;&nbsp;</p><h3 id="个人收藏"><a href="#个人收藏" class="headerlink" title="个人收藏"></a>个人收藏</h3><p>&nbsp;<a href="https://leancloud.cn/dashboard/applist.html#/apps" target="_blank" rel="noopener">LeanCloud</a>&nbsp;&nbsp;&nbsp;<a href="https://leetcode-cn.com/" target="_blank" rel="noopener">leetcode 练习题</a>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://www.lintcode.com/" target="_blank" rel="noopener">lintcode 练习题</a>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://www.51zxw.net/" target="_blank" rel="noopener">我要自学网</a><br><a href="http://svip.iocoder.cn/index/" target="_blank" rel="noopener">芋道源码</a>&nbsp;&nbsp;&nbsp;<a href="http://git.jiagouedu.com/java-vip/" target="_blank" rel="noopener">图灵源码中心</a>&nbsp;&nbsp;&nbsp;<a href="https://portal.qiniu.com/user/profile" target="_blank" rel="noopener">七牛云</a>&nbsp;&nbsp;&nbsp;</p><h3 id="博客关注"><a href="#博客关注" class="headerlink" title="博客关注"></a>博客关注</h3><p><a href="https://blog.csdn.net/justry_deng/" target="_blank" rel="noopener">justry_deng</a>     <a href="https://www.liaoxuefeng.com/wiki/896043488029600/896067074338496" target="_blank" rel="noopener">廖雪峰</a></p><h3 id="Java常用软件"><a href="#Java常用软件" class="headerlink" title="Java常用软件"></a>Java常用软件</h3><p>jdk<br><a href="https://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="noopener">jdk下载</a>&nbsp;&nbsp;&nbsp;<a href="https://docs.oracle.com/javase/8/docs/" target="_blank" rel="noopener">JDK1.8 开发文档</a>&nbsp;&nbsp;&nbsp;<a href="https://blog.csdn.net/weixin_44084189/article/details/98966787" target="_blank" rel="noopener">JDK1.8下载、安装和环境配置教程</a></p><p>IntelliJ IDEA<br><a href="https://www.w3cschool.cn/intellij_idea_doc/intellij_idea_doc-q3ke2coy.html" target="_blank" rel="noopener">IntelliJ IDEA 官方文档(中文)</a>&nbsp;&nbsp;&nbsp;<a href="https://blog.csdn.net/qq_35246620/article/details/78289074" target="_blank" rel="noopener">IntelliJ IDEA 插件的安装及使用方法</a>&nbsp;&nbsp;&nbsp;</p><p>Git<br><a href="https://git-scm.com/downloads" target="_blank" rel="noopener">Git 软件安装包下载官网</a>&nbsp;&nbsp;&nbsp;<a href="https://git-scm.com/book/zh/v2/起步-命令行" target="_blank" rel="noopener">Git 中文文档</a>&nbsp;&nbsp;&nbsp;<a href="https://www.jianshu.com/p/46ffff059092" target="_blank" rel="noopener">git 命令大全</a>&nbsp;&nbsp;&nbsp;<a href="https://gitee.com/progit/" target="_blank" rel="noopener">Pro Git（中文版）</a></p><p>docker<br><a href="https://hub.docker.com/" target="_blank" rel="noopener">docker官网</a>&nbsp;&nbsp;&nbsp;<a href="https://docs.docker.com/compose/install/" target="_blank" rel="noopener">docker 官网文档(英文版)</a>&nbsp;&nbsp;&nbsp;<a href="https://cr.console.aliyun.com/cn-hangzhou/instances/repositories" target="_blank" rel="noopener">阿里容器镜像服务</a></p><p>其他<br><a href="https://www.netsarang.com/download/free_license.html" target="_blank" rel="noopener">xshell免费版下载安装及使用</a>&nbsp;&nbsp;&nbsp;<a href="https://chrome.zzzmh.cn/help?token=setup" target="_blank" rel="noopener">Chrome 75 安装crx扩展插件方法汇总</a>&nbsp;&nbsp;&nbsp;<a href="https://www.typora.io/" target="_blank" rel="noopener">typora</a></p><h3 id="后端技术"><a href="#后端技术" class="headerlink" title="后端技术"></a>后端技术</h3><p>Spring<br><a href="https://spring.io/" target="_blank" rel="noopener">Spring MVC 官网</a>&nbsp;&nbsp;&nbsp;<a href="http://projects.spring.io/spring-boot/" target="_blank" rel="noopener">Spring Boot 官网</a>&nbsp;&nbsp;&nbsp;<a href="http://projects.spring.io/spring-boot/" target="_blank" rel="noopener">spring-boot-devtools 官网</a></p><p>Shiro<br><a href="http://shiro.apache.org/documentation.html" target="_blank" rel="noopener">Shiro官方文档</a></p><p>MyBatis<br><a href="https://mybatis.org/mybatis-3/zh/index.html" target="_blank" rel="noopener">MyBatis 中文使用文档</a>&nbsp;&nbsp;&nbsp;<a href="https://mp.baomidou.com" target="_blank" rel="noopener">MyBatis-Plus 插件中文使用文档</a>&nbsp;&nbsp;&nbsp;<a href="https://github.com/baomidou/mybatis-plus-samples" target="_blank" rel="noopener">MyBatis-Plus 演示例子帮助文档</a>&nbsp;&nbsp;&nbsp;<br><a href="https://blog.csdn.net/m0_37034294/article/details/82917234" target="_blank" rel="noopener">MyBatis-Plus 条件构造器queryWrapper、updateWrapper</a>&nbsp;&nbsp;&nbsp;<a href="https://www.jianshu.com/p/a20d318aed68" target="_blank" rel="noopener">mybatis-plus (查询)</a></p><p>Maven<br><a href="http://maven.apache.org/" target="_blank" rel="noopener">Maven官网</a></p><p>MySql<br><a href="https://www.mysql.com/" target="_blank" rel="noopener">MySql官网</a> </p><p>Oracle<br><a href="https://www.oracle.com/index.html" target="_blank" rel="noopener">Oracle官网</a></p><p>Redis<br><a href="https://redis.io/" target="_blank" rel="noopener">Redis 官网</a>&nbsp;&nbsp;&nbsp;<a href="http://redisdoc.com/" target="_blank" rel="noopener">Redis 命令参考</a>&nbsp;&nbsp;&nbsp;<a href="http://www.redis.cn/commands.html" target="_blank" rel="noopener">Redis 命令中心</a></p><p>FreeMarker<br><a href="http://freemarker.org/" target="_blank" rel="noopener">FreeMarker官网</a>&nbsp;&nbsp;&nbsp;<a href="http://freemarker.foofun.cn/toc.html" target="_blank" rel="noopener">FreeMarker 中文官方参考手册</a></p><p>Shiro<br><a href="http://shiro.apache.org/" target="_blank" rel="noopener">Apache Shiro官网</a></p><p>Hibernate<br><a href="https://docs.jboss.org/hibernate/core/3.6/reference/zh-CN/html_single/" target="_blank" rel="noopener">Hibernate中文使用文档</a></p><p>Poi<br><a href="http://easypoi.mydoc.io/#text_186905" target="_blank" rel="noopener">EasyPoi 教程</a></p><p>其他</p><p><a href="https://junit.org/junit5/" target="_blank" rel="noopener">junit5官网（英文）</a></p><p><a href="https://junit.org/junit5/" target="_blank" rel="noopener"></a></p><p><a href="https://mp.weixin.qq.com/s/XLyvUBftV2UFamvWyYIIRw" target="_blank" rel="noopener">设计模式内容聚合</a><br><a href="http://druid.io/" target="_blank" rel="noopener">Druid官网</a><br><a href="https://github.com/alibaba/fastjson/" target="_blank" rel="noopener">FastJson官网</a><br><a href="https://www.kutu66.com//Java_API_Classes/article_67241" target="_blank" rel="noopener">org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseType的最佳示例</a></p><p>[][]</p><p><a href="https://junit.org/junit5/" target="_blank" rel="noopener"></a></p><p><a href="https://junit.org/junit5/" target="_blank" rel="noopener"></a></p><h3 id="前端技术"><a href="#前端技术" class="headerlink" title="前端技术"></a>前端技术</h3><p>jQuery<br><a href="http://www.bejson.com/apidoc/jquery/" target="_blank" rel="noopener">Jquery Api</a>&nbsp;&nbsp;&nbsp;<a href="http://jquery.com/" target="_blank" rel="noopener">jQuery官网</a>&nbsp;&nbsp;&nbsp;<a href="https://www.runoob.com/jquery/jquery-plugin-validate.html" target="_blank" rel="noopener">jQuery Validate</a>&nbsp;&nbsp;&nbsp;<a href="https://www.w3school.com.cn/jquery/jquery_ref_selectors.asp" target="_blank" rel="noopener">jQuery 参考手册 - 选择器</a>&nbsp;&nbsp;&nbsp;<a href="https://www.jquery-confirm.cn/" target="_blank" rel="noopener">jQuery-confirm 中文网</a>&nbsp;&nbsp;&nbsp;<br><a href="http://datatables.club/reference/#options" target="_blank" rel="noopener">jQuery-Datatables 参考手册 中文网</a></p><p>Bootstrap<br>相关文章：<a href="/2020/01/19/bootstrap/" title="Bootstrap相关整理">Bootstrap相关整理</a></p><p>EasyUI<br><a href="http://www.jeasyui.net/" target="_blank" rel="noopener">EasyUI 官网</a><br><a href="https://www.runoob.com/jeasyui/jqueryeasyui-tutorial.html" target="_blank" rel="noopener">EasyUI 使用文档</a></p><p>富文本编辑器<br><a href="http://www.wangeditor.com" target="_blank" rel="noopener">wangEditor 官网</a>  轻量级web富文本编辑器<br><a href="http://kindeditor.net/demo.php" target="_blank" rel="noopener">KindEditor 官网</a></p><p>其他<br><a href="https://www.bootcdn.cn/" target="_blank" rel="noopener">BootCDN</a> 免费的前端开源项目 CDN 加速服务</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p><a href="https://www.google.cn/intl/zh-CN/chrome/" target="_blank" rel="noopener">谷歌浏览器官网</a><br><a href="https://halo.run/archives/install-quick-start" target="_blank" rel="noopener">halo 博客搭建</a></p><p><a href="https://www.cnblogs.com/ysocean/tag/Java数据结构和算法/" target="_blank" rel="noopener">Java数据结构和算法（博客文章）</a></p>]]></content>
      
      
      <categories>
          
          <category> 网址 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> website </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux安装docker使用及一些问题记录</title>
      <link href="/2020/01/03/docker/"/>
      <url>/2020/01/03/docker/</url>
      
        <content type="html"><![CDATA[<p><a href="https://docs.docker.com/" target="_blank" rel="noopener">daoker镜像官网</a><br>使用docker初衷是因为linux安装配置软件过于繁琐，而docker只需单单几行命令即可</p><a id="more"></a><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>docker 要求 CentOS 系统的内核版本高于 3.10 </p><pre><code class="linux">uname -r  命令查看你当前的内核版本</code></pre><p>使用 root 权限登录 Centos。yum 包更新到最新。</p><pre><code class="linux">yum -y update</code></pre><h2 id="已安装过重新安装"><a href="#已安装过重新安装" class="headerlink" title="已安装过重新安装"></a>已安装过重新安装</h2><h3 id="查看安装过的docker"><a href="#查看安装过的docker" class="headerlink" title="查看安装过的docker"></a>查看安装过的docker</h3><pre><code class="linux">yum list installed | grep docker</code></pre><p>查询结果示例：<br>docker.x86_64                           2:1.13.1-74.git6e3bb8e.el7.centos<br>docker-client.x86_64                    2:1.13.1-74.git6e3bb8e.el7.centos<br>docker-common.x86_64                    2:1.13.1-74.git6e3bb8e.el7.centos</p><h3 id="卸载docker"><a href="#卸载docker" class="headerlink" title="卸载docker"></a>卸载docker</h3><pre><code class="linux">sudo yum remove -y docker-ce.x86_64 docker-client.x86_64 docker-common.x86_64 </code></pre><h3 id="删除容器镜像"><a href="#删除容器镜像" class="headerlink" title="删除容器镜像"></a>删除容器镜像</h3><pre><code class="linux">sudo rm -rf /var/lib/docker</code></pre><h3 id="重新安装docker"><a href="#重新安装docker" class="headerlink" title="重新安装docker"></a>重新安装docker</h3><pre><code class="linux">sudo yum install docker-ce</code></pre><h2 id="第一次安装"><a href="#第一次安装" class="headerlink" title="第一次安装"></a>第一次安装</h2><h3 id="安装依赖包"><a href="#安装依赖包" class="headerlink" title="安装依赖包"></a>安装依赖包</h3><pre><code class="linux">sudo yum install -y yum-utils device-mapper-persistent-data lvm2 </code></pre><h3 id="设置阿里云镜像源"><a href="#设置阿里云镜像源" class="headerlink" title="设置阿里云镜像源"></a>设置阿里云镜像源</h3><pre><code class="linux">sudo yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo </code></pre><h3 id="安装-Docker-CE"><a href="#安装-Docker-CE" class="headerlink" title="安装 Docker-CE"></a>安装 Docker-CE</h3><pre><code class="linux">sudo yum install docker-ce</code></pre><h2 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h2><h3 id="启动docker服务"><a href="#启动docker服务" class="headerlink" title="启动docker服务"></a>启动docker服务</h3><pre><code class="linux">sudo systemctl start docker</code></pre><h3 id="开机自启"><a href="#开机自启" class="headerlink" title="开机自启"></a>开机自启</h3><pre><code class="linux">sudo systemctl enable docker</code></pre><h3 id="添加docker用户组（可选）"><a href="#添加docker用户组（可选）" class="headerlink" title="添加docker用户组（可选）"></a>添加docker用户组（可选）</h3><ul><li><p>建立 Docker 用户组</p><pre><code class="linux">sudo groupadd docker</code></pre></li><li><p>添加当前用户到 docker 组</p><pre><code class="linux">sudo usermod -aG docker $USER</code></pre></li></ul><h3 id="镜像加速配置"><a href="#镜像加速配置" class="headerlink" title="镜像加速配置"></a>镜像加速配置</h3><blockquote><p>加速器地址 ：<a href="https://cr.console.aliyun.com/cn-hangzhou/instances/repositories" target="_blank" rel="noopener">阿里云容器镜像服务</a><br>进入容器镜像服务， 左侧最下方容器镜像服务中复制加速器地址</p></blockquote><pre><code class="linux">sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-&#39;EOF&#39;{  &quot;registry-mirrors&quot;: [&quot;你的加速器地址&quot;]}EOF</code></pre><blockquote><p> 重启docker</p></blockquote><pre><code class="linux">sudo systemctl daemon-reloadsudo systemctl restart docker</code></pre><h3 id="GUI管理"><a href="#GUI管理" class="headerlink" title="GUI管理"></a>GUI管理</h3><p>命令行虽然效率高，但太专业，不够直观，而且多主机管理不方便。<br>图形化管理系统还可以和用户角色管理等关联起来。不用太多的专业知识也能很快上手。</p><ul><li><a href="https://portainer.io/install.html" target="_blank" rel="noopener">GUI官网</a></li><li><a href="https://docs.oracle.com/cd/E35310_01/E40129/html/Tools-Admin-GUI.html" target="_blank" rel="noopener">GUI中文使用文档</a></li><li><a href="https://www.jianshu.com/p/c3f5c644dc01" target="_blank" rel="noopener">Docker 学习系列10 开源图形化管理系统</a></li></ul><blockquote><p>安装命令</p></blockquote><pre><code class="linux">docker volume create portainer_datadocker run -d -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer</code></pre><p>访问你的 IP:9000 即可进入容器管理页面。<br><img src="/img/docker/1.png" alt="访问页面"></p><h2 id="docker命令"><a href="#docker命令" class="headerlink" title="docker命令"></a>docker命令</h2><blockquote><p>可查看这篇文章 : <a href="/2020/01/07/docker-command/" title="docker命令">docker命令</a></p></blockquote><h2 id="docker安装程序镜像"><a href="#docker安装程序镜像" class="headerlink" title="docker安装程序镜像"></a>docker安装程序镜像</h2><h3 id="docker安装MySQL"><a href="#docker安装MySQL" class="headerlink" title="docker安装MySQL"></a>docker安装MySQL</h3><blockquote><p>可查看这篇文章 : <a href="/2020/01/13/docker-mysql/" title="docker安装MySql及相关命令">docker安装MySql及相关命令</a></p></blockquote><h3 id="docker安装Redis"><a href="#docker安装Redis" class="headerlink" title="docker安装Redis"></a>docker安装Redis</h3><p>待补充</p><h2 id="win10安装"><a href="#win10安装" class="headerlink" title="win10安装"></a>win10安装</h2><p><a href="https://www.cnblogs.com/eyesfree/p/9515487.html" target="_blank" rel="noopener">windows10 docker 使用</a><br><a href="https://download.docker.com/win/stable/InstallDocker.msi" target="_blank" rel="noopener">windows10 docker 下载</a><br><a href="https://blog.csdn.net/hunan961/article/details/79484098" target="_blank" rel="noopener">WIN10中DOCKER的安装与使用</a></p><h2 id="文章整理"><a href="#文章整理" class="headerlink" title="文章整理"></a>文章整理</h2><p><a href="https://hub.docker.com/" target="_blank" rel="noopener">docker 官网</a><br><a href="https://docs.docker.com/compose/install/" target="_blank" rel="noopener">docker 官网文档 英文版</a><br><a href="https://www.cnblogs.com/bethal/p/5942369.html" target="_blank" rel="noopener">docker 容器和镜像区别</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>win10下VMware安装Centos</title>
      <link href="/2020/01/03/VMware-CentOS/"/>
      <url>/2020/01/03/VMware-CentOS/</url>
      
        <content type="html"><![CDATA[<p>CentOS版本 : CentOS-7.2-x86_64-DVD-1511</p><a id="more"></a><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><blockquote><p><strong>下载 :</strong> <a href="https://pan.baidu.com/s/1r9JOByi7EBFjQ0CPy8xxBA" target="_blank" rel="noopener">百度云链接</a> 提取码 : k5i1<br><strong>官网 :</strong> <a href="http://isoredirect.centos.org/centos/" target="_blank" rel="noopener">CentOS官网地址</a></p></blockquote><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><blockquote><p>0.创建<br><img src="/img/ssm/2.png" alt="创建虚拟机"></p></blockquote><blockquote><p>1.选择CentOS文件地址</p></blockquote><p><img src="/img/ssm/3.png" alt="创建虚拟机"></p><blockquote><p>2.输入名称(不是虚拟机名称)及创建用户，root已经默认创建了，不可以再创建。</p></blockquote><p><img src="/img/ssm/4.png" alt="创建虚拟机"></p><blockquote><p>3.输入虚拟机名称，虚拟机保存地址(建议单独建立存放虚拟机文件夹 方便管理)</p></blockquote><p><img src="/img/ssm/5.png" alt="创建虚拟机"></p><blockquote><p>4.默认即可，磁盘大小以电脑配置自行更改</p></blockquote><p><img src="/img/ssm/6.png" alt="创建虚拟机"></p><blockquote><p>5.自定义设置</p></blockquote><p><img src="/img/ssm/7.png" alt="创建虚拟机"></p><blockquote><p>6.选择CentOS文件，</p></blockquote><p><img src="/img/ssm/8.png" alt="创建虚拟机"></p><blockquote><p>7.网络适配器[网络连接]选择桥接模式，其他设置以电脑配置自行更改，修改完毕点击完成，会进行系统安装</p></blockquote><p><img src="/img/ssm/15.png" alt="创建虚拟机"></p><blockquote><p>8.如果是个人开发可不设置密码</p></blockquote><p><img src="/img/ssm/9.png" alt="创建虚拟机"></p><blockquote><p>9.点击登录依次输入创建的用户和密码</p></blockquote><p><img src="/img/ssm/10.png" alt="创建虚拟机"></p><blockquote><p>10.选择语言</p></blockquote><p><img src="/img/ssm/11.png" alt="创建虚拟机"></p><blockquote><p>11.账号可直接跳过</p></blockquote><p><img src="/img/ssm/12.png" alt="创建虚拟机"></p><blockquote><p>12.进入系统</p></blockquote><p><img src="/img/ssm/13.png" alt="创建虚拟机"></p><blockquote><p>13.成功</p></blockquote><p><img src="/img/ssm/14.png" alt="创建虚拟机"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> VMware </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VMware </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql问答</title>
      <link href="/2020/01/03/mysql-quiz/"/>
      <url>/2020/01/03/mysql-quiz/</url>
      
        <content type="html"><![CDATA[<p>MySQL一些提问解答</p><a id="more"></a><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="数据库事务特性"><a href="#数据库事务特性" class="headerlink" title="数据库事务特性"></a>数据库事务特性</h3><p><em>原子性</em>：对数据库数据的一系列操作，要么全部执行，要么都不 执行。</p><p><em>一致性</em>：数据库从一个一致状态转到另一个一致状态。</p><p><em>隔离性</em>：多个事务对数据库的操作要相互隔离</p><p><em>持久性</em>：事务提交后的数据在数据库中是永久存在的</p><h3 id="数据库并发操作产生的异常现象"><a href="#数据库并发操作产生的异常现象" class="headerlink" title="数据库并发操作产生的异常现象"></a>数据库并发操作产生的异常现象</h3><p><em>脏读</em>：读取一个事务未提交的数据</p><p><em>不可重复读</em>：一个事务中多条相同读取语句执行结果不一致，针对更新和删除</p><p><em>幻读</em>：一个事务中多条相同读取语句执行结果不一致，针对增加</p><p><em>更新丢失（X锁）</em>：一个事务的更新操作被另一个事务覆盖</p><h3 id="数据库的隔离级别"><a href="#数据库的隔离级别" class="headerlink" title="数据库的隔离级别"></a>数据库的隔离级别</h3><p><em>读未提交（S锁）</em>：可以读取一个事务未提交的数据</p><p><em>读已提交（U锁）</em>：只能读取一个事务已提交的数据</p><p><em>可重复读（X锁）</em>:  一个事务在读取的时候不允许其他事务更新删除操作</p><p><em>序列化（X锁）</em>:  一个事务只能等待另一个事务完成后才可以进行</p><h3 id="可重复读级别能解决幻读吗"><a href="#可重复读级别能解决幻读吗" class="headerlink" title="可重复读级别能解决幻读吗"></a>可重复读级别能解决幻读吗</h3><blockquote><p>具体参照：[MySQL的可重复读级别能解决幻读吗][0]。</p></blockquote><p><code>MySQL</code>可重复读的隔离级别中并不是完全解决了幻读的问题，而是解决了读数据情况下的幻读问题。而对于修改的操作依旧存在幻读问题，就是说<code>MVCC</code>对于幻读的解决时不彻底的。 </p><h3 id="MySql的存储引擎的不同"><a href="#MySql的存储引擎的不同" class="headerlink" title="MySql的存储引擎的不同"></a>MySql的存储引擎的不同</h3><p><strong>存储引擎查看</strong>：SHOW ENGINES</p><p>在<code>MySQL</code>中，不需要在整个服务器中使用同一种存储引擎，针对具体的要求，可以对每一个表使用不同的存储引擎。</p><p><code>Support</code>列的值表示某种引擎是否能使用：YES表示可以使用、NO表示不能使用、DEFAULT表示该引擎为当前默认的存储引擎。</p><p><strong>InnoDB存储引擎</strong>：<code>InnoDB</code>是事务型数据库的首选引擎，支持事务安全表（ACID），支持行锁定和外键，上图也看到了，<code>InnoDB</code>是默认的<code>MySQL</code>引擎。</p><p><strong>MyISAM存储引擎</strong>：<code>MyISAM</code>基于<code>ISAM</code>存储引擎，并对其进行扩展。它是在Web、数据仓储和其他应用环境下最常使用的存储引擎之一。<code>MyISAM</code>拥有较高的插入、查询速度，但<strong>不支持事物</strong>。</p><p><strong>MEMORY存储引擎</strong>：<code>MEMORY</code>存储引擎将表中的数据存储到内存中，未查询和引用其他表数据提供快速访问。</p><p>不同的存储引擎都有各自的特点，以适应不同的需求，如下表所示：</p><table><thead><tr><th><strong>功 能</strong></th><th><strong>MYISAM</strong></th><th><strong>Memory</strong></th><th><strong>InnoDB</strong></th><th><strong>Archive</strong></th></tr></thead><tbody><tr><td>存储限制</td><td>256TB</td><td>RAM</td><td>64TB</td><td>None</td></tr><tr><td>支持事物</td><td>No</td><td>No</td><td>Yes</td><td>No</td></tr><tr><td>支持全文索引</td><td>Yes</td><td>No</td><td>No</td><td>No</td></tr><tr><td>支持数索引</td><td>Yes</td><td>Yes</td><td>Yes</td><td>No</td></tr><tr><td>支持哈希索引</td><td>No</td><td>Yes</td><td>No</td><td>No</td></tr><tr><td>支持数据缓存</td><td>No</td><td>N/A</td><td>Yes</td><td>No</td></tr><tr><td>支持外键</td><td>No</td><td>No</td><td>Yes</td><td>No</td></tr></tbody></table><p>如果要提供提交、回滚、崩溃恢复能力的事物安全（ACID兼容）能力，并要求实现并发控制，<code>InnoDB</code>是一个好的选择</p><p>如果数据表主要用来插入和查询记录，则<code>MyISAM</code>引擎能提供较高的处理效率</p><p>如果只是临时存放数据，数据量不大，并且不需要较高的数据安全性，可以选择将数据保存在内存中的<code>Memory</code>引擎，<code>MySQL</code>中使用该引擎作为临时表，存放查询的中间结果</p><p>如果只有<code>INSERT</code>和<code>SELECT</code>操作，可以选择<code>Archive</code>，<code>Archive</code>支持高并发的插入操作，但是本身不是事务安全的。<code>Archive</code>非常适合存储归档数据，如记录日志信息可以使用<code>Archive</code></p><p>使用哪一种引擎需要灵活选择，<strong>一个数据库中多个表可以使用不同引擎以满足各种性能和实际需求</strong>，使用合适的存储引擎，将会提高整个数据库的性能</p><h3 id="单个索引、联合索引、主键索引"><a href="#单个索引、联合索引、主键索引" class="headerlink" title="单个索引、联合索引、主键索引"></a>单个索引、联合索引、主键索引</h3><p>索引是一种特殊的文件，它们包含着对所有记录的引用指针。</p><p>索引的遵循原则：</p><ul><li><strong>最左侧原则</strong>，表的最左侧的一列，往往数据不会发生改变，不影响其他列的数据；</li><li><strong>命名短小原则</strong>，索引命名过长<strong>会使索引文件变大</strong>，<strong>损耗内存</strong>。</li></ul><p><strong>普通索引</strong>：（由关键字KEY或INDEX定义的索引）的唯一任务是 <strong><em>加快对数据的访问速度</em></strong>。普通索引允许被索引的数据列<strong><em>包含重复的值</em></strong>。如果能确定某个数据列将只包含彼此各不相同的值，在为这个数据列常创建索引时应该用就用<code>关键字UNIQUE</code>把他定义成一个唯一索引。也就是说，<strong><em>唯一索引可以保证数据记录的唯一性</em></strong>。</p><p><strong>唯一索引</strong>：不允许两行具有相同的索引值。</p><p><strong>主键</strong>：是一种特殊的唯一索引，一张表中只能定义一个主键索引，通常有一列或列组合，用于唯一标识一条记录，使用关键字<code>PRIMARY KEY</code>来创建。为表定义一个主键将自动创建主键索引（聚簇索引）。当在查询中使用主键索引时，它还允许快速访问数据。</p><p><strong>联合索引</strong> ：可以<strong><em>覆盖多个数据列</em></strong>，像<code>INDEX(columnA, columnB)</code>索引，这就是联合索引。</p><p><strong>主键索引和唯一索引的区别：</strong><br>(1) 对于主键/unique constraint ， <code>oracle</code>/<code>sql server</code>/<code>mysql</code>等都会自动建立唯一索引；<br>(2) 主键不一定只包含一个字段，所以在主键的其中一个字段建唯一索引还是有必要的；<br>(3) 主键可作外键，唯一索引不可；<br>(4) 主键不可为空，唯一索引可；<br>(5) 主键可是多个字段的组合；<br>(6) 主键与唯一索引不同的是：有<code>not null</code>属性；每个表只能有一个。</p><p>(7) 主键索引一定是唯一索引， <strong>唯一索引不是主键索引</strong><br>(8) 主键可以与外键 构成 参照完整性约束， 防止数据不一致</p><h3 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h3><p><a href="https://www.cnblogs.com/songwenjie/p/9414960.html" target="_blank" rel="noopener">数据库索引背后的数据结构</a></p><p><a href="https://www.cnblogs.com/guokaifeng/p/11272896.html" target="_blank" rel="noopener">索引 与 索引数据结构</a></p><h3 id="数据库的锁"><a href="#数据库的锁" class="headerlink" title="数据库的锁"></a>数据库的锁</h3><ul><li><p><strong>表级锁</strong>：每次操作锁住整张表。开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低；</p></li><li><p><strong>行级锁</strong>：每次操作锁住一行数据。开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高；</p></li><li><p><strong>共享锁</strong>：共享锁指的就是对于多个不同的事务，对同一个资源共享同一个锁</p></li><li><p><strong>排它锁</strong>：排它锁与共享锁相对应，就是指对于多个不同的事务，对同一个资源只能有一把锁。与共享锁类型，在需要执行的语句后面加上for update就可以了</p></li><li><p><strong>页面锁</strong>：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。没弄懂，有空再看。</p></li><li><p><strong>悲观锁</strong>（Pessimistic Concurrency Control，PCC）：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。</p></li><li><p><strong>乐观锁</strong>（Optimistic Concurrency Control，OCC）：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。</p></li></ul><h3 id="数据库事务的几种粒度"><a href="#数据库事务的几种粒度" class="headerlink" title="数据库事务的几种粒度"></a>数据库事务的几种粒度</h3><p>属性值——》元组——》行——》表</p><h3 id="关系型和非关系型数据库区别"><a href="#关系型和非关系型数据库区别" class="headerlink" title="关系型和非关系型数据库区别"></a>关系型和非关系型数据库区别</h3><p><strong>关系型数据库</strong></p><p>关系型数据库最典型的<strong>数据结构是表</strong>，由<strong>二维表</strong>及其<strong>之间的联系</strong>所组成的一个数据组<br>织。</p><p>常用的：<code>mysql</code> /<code>oracle</code>/<code>sql server</code>/<code>sqlite</code> </p><p><strong>优点：</strong><br>1、易于维护：都是使用表结构，格式一致；<br>2、使用方便：<code>SQL</code>语言通用，可用于复杂查询；<br>3、复杂操作：支持<code>SQL</code>，可用于一个表以及多个表之间非常复杂的查询。<br><strong>缺点：</strong><br>1、读写性能比较差，尤其是海量数据的高效率读写；<br>2、固定的表结构，灵活度稍欠；<br>3、高并发读写需求，传统关系型数据库来说，硬盘<strong>I/O</strong>是一个很大的瓶颈。</p><p><strong>非关系型数据库</strong></p><p>非关系型数据库严格上不是一<strong>加粗样式</strong>种数据库，应该<strong>是一种数据结构化存储方法的集合，可以是文档或者键值对等</strong></p><p>常用的：<code>redis</code> / <code>hbase</code> /<code>mongoDB</code> /<code>CouchDB</code> /<code>Neo4J</code> 【注意：<code>hive</code> 不是数据库，是数据仓库 不是一个概念】</p><p><strong>优点：</strong><br>1、格式灵活：存储数据的格式可以是<code>key</code>,<code>value</code>形式、文档形式、图片形式等等，文档形式、图片形式等等，使用灵活，应用场景广泛，而关系型数据库则只支持基础类型。<br>2、速度快：<code>nosql</code>可以使用硬盘或者随机存储器作为载体，而关系型数据库只能使用硬盘；<br>3、高扩展性；<br>4、成本低：<code>nosql</code>数据库部署简单，基本都是开源软件。</p><p><strong>缺点：</strong><br>1、不提供<code>sql</code>支持，学习和使用成本较高；<br>2、无事务处理；<br>3、数据结构相对复杂，复杂查询方面稍欠。</p><p><strong>非关系型数据库的分类和比较：</strong></p><p>1、文档型<br>2、key-value型<br>3、列式数据库<br>4、图形数据库</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>问答</title>
      <link href="/2020/01/03/interview/"/>
      <url>/2020/01/03/interview/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="java基础"><a href="#java基础" class="headerlink" title="java基础"></a>java基础</h2><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>内置数据类型<br>Java语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。<br><code>byte</code>  <code>short</code>  <code>int</code>  <code>long</code>  <code>float</code>  <code>double</code>  <code>boolean</code>  <code>char</code></p><p><strong>自动类型转换</strong></p><p>整型、实型（常量）、字符型数据可以混合运算。运算中，不同类型的数据先转化为同一类型，然后进行运算。<br>数据类型转换必须满足如下规则：</p><ul><li><p>不能对boolean类型进行类型转换。</p></li><li><p>不能把对象类型转换成不相关类的对象。</p></li><li><p>在把容量大的类型转换为容量小的类型时必须使用强制类型转换。</p></li><li><p>转换过程中可能导致溢出或损失精度</p></li><li><p>浮点数到整数的转换是通过舍弃小数得到，而不是四舍五入</p></li></ul><p><strong>强制类型转换</strong></p><ul><li><p>条件是转换的数据类型必须是兼容的。</p></li><li><p>格式：<code>(type)value</code> <code>type</code>是要强制类型转换后的数据类型</p></li></ul><p><strong>隐含强制类型转换</strong></p><ul><li><p>整数的默认类型是 <code>int</code>。</p></li><li><p>浮点型不存在这种情况，因为在定义<code>float</code> 类型时必须在数字后面跟上<code>F</code>或者<code>f</code>。</p></li></ul><h3 id="Java-的引用类型有哪几种"><a href="#Java-的引用类型有哪几种" class="headerlink" title="Java 的引用类型有哪几种"></a>Java 的引用类型有哪几种</h3><p>对象、数组都是引用数据类型。<br>所有引用类型的默认值都是<code>null</code>。<br>常量在程序运行时是 <strong><em>不能被修改</em></strong>  的。<br>在 <code>Java</code> 中使用 <code>final</code> 关键字来修饰常量，声明方式和变量类似。</p><h3 id="String-类的常用方法"><a href="#String-类的常用方法" class="headerlink" title="String 类的常用方法"></a>String 类的常用方法</h3><p><code>new String(value)</code>用字符数组value创建一个String对象<br><code>new String(value, 1, 2)</code> 用字符数组以x开始的n个字符创建一个String对象<br><code>str.length()</code> 获取字符串长度<br><code>str.charAt(4)</code> 获取字符串某一位置的字符<br><code>str1.substring(2,5)</code> 获取字符串的子串<br><code>str1.compareTo(str2)</code> <code>str1.equals(str2)</code> 字符串的比较<br><code>indexOf(String str)</code> 查找子串在字符串中的位置<br><code>str.toLowerCase()</code> <code>str.toUpperCase()</code>字符串中字符的大小写转换<br><code>str.trim()</code> 字符串两端去空格<br><code>str.split(&quot;#&quot;)</code> 将字符串分割成字符串数组<br><code>String.valueOf(12.99)</code> 基本类型转换为字符串<br><code>str.replace(&#39;h&#39;,&#39;g&#39;)</code> 替换字符串</p><h3 id="string、stringbuilder、stringbuffer区别"><a href="#string、stringbuilder、stringbuffer区别" class="headerlink" title="string、stringbuilder、stringbuffer区别"></a>string、stringbuilder、stringbuffer区别</h3><p><code>String</code>是只读字符串，所引用的字符串不能被改变，<code>Stringbuffer</code>和<code>Stringbuilder</code>定义的可以通过各种方法来达到简单的增删改；</p><p>每次+操作 ： 隐式在堆上<code>new</code>了一个跟原字符串相同的<code>StringBuilder</code>对象，再调用<code>append</code>方法 拼接+后面的字符。</p><p><code>String</code>和<code>Stringbuilder</code>在单线程环境下使用；<br><code>StringBuffer</code>在多线程环境下使用，可以保证线程同步；<br><code>Stringbuilder</code> 和<code>StringBuffer</code> 实现方法类似，均表示可变字符序列，不过<code>StringBuffer</code> 用<code>synchronized</code>关键字修饰（保证线程同步）</p><p>当需要对某一字符串大量重复+操作时：<br><code>Stringbuilder</code> 最快，不需要考虑线程同步；<code>StringBuffer</code>次之；<br><code>String</code>最慢，因为每次都要重新开辟内存，产生很多匿名对象，影响系统性能。</p><p>Java6和6之前，常量池是存放在方法区中的。<br>Java7，将常量池是存放到了堆中，常量池就相当于是在永久代中，所以永久代存放在堆中。<br>Java8之后，取消了整个永久代区域，取而代之的是元空间。没有再对常量池进行调整。</p><h3 id="为什么-Java-中的-String-是不可变的"><a href="#为什么-Java-中的-String-是不可变的" class="headerlink" title="为什么 Java 中的 String 是不可变的"></a>为什么 Java 中的 String 是不可变的</h3><p>Java 中的 String 不可变是因为 Java 的设计者认为字符串使用非常频繁，将字符串设置为不可变可以允许多个客户端之间共享相同的字符串</p><h3 id="Java-中的构造器链是什么"><a href="#Java-中的构造器链是什么" class="headerlink" title="Java 中的构造器链是什么"></a>Java 中的构造器链是什么</h3><p>当你从一个构造器中调用另一个构造器，就是Java 中的构造器链。这种情况只在重载了类的构造器的时候才会出现。</p><h3 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别"></a>抽象类和接口的区别</h3><p><strong>抽象类：</strong></p><ul><li>抽象类使用<code>abstract</code>修饰；</li><li>抽象类不能实例化，即不能使用new关键字来实例化对象；</li><li>含有抽象方法（使用<code>abstract</code>关键字修饰的方法）的类是抽象类，必须使用<code>abstract</code>关键字修饰；</li><li>抽象类可以含有抽象方法，也可以不包含抽象方法，抽象类中可以有具体的方法；</li><li>如果一个子类实现了父类（抽象类）的所有抽象方法，那么该子类可以不必是抽象类，否则就是抽象类；</li><li>抽象类中的抽象方法只有方法体，没有具体实现；</li></ul><p><strong>接口：</strong></p><ul><li>接口使用<code>interface</code>修饰；</li><li>接口不能被实例化；</li><li>一个类只能继承一个类，但是可以实现多个接口；</li><li>接口中方法均为抽象方法；</li><li>接口中不能包含实例域或静态方法（静态方法必须实现，接口中方法是抽象方法，不能实现）</li></ul><h3 id="hashCode-与-equals"><a href="#hashCode-与-equals" class="headerlink" title="hashCode() 与 equals()"></a>hashCode() 与 equals()</h3><p>对象在不重写的情况下使用的是Object的equals方法和hashcode方法，从Object类的源码我们知道，默认的equals 判断的是两个对象的引用指向的是不是同一个对象；而hashcode也是根据对象地址生成一个整数数值；</p><p><strong>equals()</strong></p><ul><li><p>判断是否等于自身.</p></li><li><p>使用<code>instanceof</code>运算符判断 other 是否为Coder类型的对象.</p></li></ul><ul><li>比较Coder类中你自定义的数据域，name和age，一个都不能少.</li></ul><p><strong>hashcode</strong></p><ul><li><p>两个对象相等，hashcode一定相等</p></li><li><p>两个对象不等，hashcode不一定不等</p></li><li><p>hashcode相等，两个对象不一定相等</p></li><li><p>hashcode不等，两个对象一定不等</p></li></ul><p>在重写equals()后，一定要重写hashCode()方法</p><p>相关文章：</p><p><a href="https://blog.csdn.net/u012557538/article/details/89861552" target="_blank" rel="noopener">重写hashcode和equals方法</a></p><p><a href="https://blog.csdn.net/xl_1803/article/details/80445481" target="_blank" rel="noopener">为什么重写equals一定要重写hashcode？</a></p><p><a href="https://blog.csdn.net/neosmith/article/details/17068365" target="_blank" rel="noopener">如何重写hashCode()和equals()方法</a></p><h3 id="是不是每个对象都要重写这两个方法，到底什么时候重写？"><a href="#是不是每个对象都要重写这两个方法，到底什么时候重写？" class="headerlink" title="是不是每个对象都要重写这两个方法，到底什么时候重写？"></a>是不是每个对象都要重写这两个方法，到底什么时候重写？</h3><p>事实上一般情况下，我们并不需要重写这两个方法，只有该类被应用到集合框架中去的时候，才应该重写。</p><h3 id="为什么需要hashCode"><a href="#为什么需要hashCode" class="headerlink" title="为什么需要hashCode"></a>为什么需要hashCode</h3><p>通过hashCode可以提高对比的性能</p><h3 id="a-hashCode-有什么用？与-a-equals-b-有什么关系"><a href="#a-hashCode-有什么用？与-a-equals-b-有什么关系" class="headerlink" title="a.hashCode() 有什么用？与 a.equals(b) 有什么关系"></a>a.hashCode() 有什么用？与 a.equals(b) 有什么关系</h3><p>hashCode() 方法是相应对象整型的 hash 值。它常用于基于 hash 的集合类，如 Hashtable、HashMap、LinkedHashMap等等。它与 equals() 方法关系特别紧密。根据 Java 规范，两个使用 equal() 方法来判断相等的对象，必须具有相同的 hash code。</p><h3 id="“a-b”和”a-equals-b-”有什么区别"><a href="#“a-b”和”a-equals-b-”有什么区别" class="headerlink" title="“a==b”和”a.equals(b)”有什么区别"></a>“a==b”和”a.equals(b)”有什么区别</h3><p>如果 a 和 b 都是对象，则 a==b 是比较两个对象的引用，只有当 a 和 b 指向的是堆中的同一个对象才会返回 true，而 a.equals(b) 是进行逻辑比较，所以通常需要重写该方法来提供逻辑一致性的比较。例如，String 类重写 equals() 方法，所以可以用于两个不同对象，但是包含的字母相同的比较。</p><h3 id="Java-中的编译期常量是什么？使用它又什么风险？"><a href="#Java-中的编译期常量是什么？使用它又什么风险？" class="headerlink" title="Java 中的编译期常量是什么？使用它又什么风险？"></a>Java 中的编译期常量是什么？使用它又什么风险？</h3><p>公共静态不可变（<code>public</code> <code>static</code> <code>final</code>）变量也就是我们所说的编译期常量，这里的public可选的。<br>实际上这些变量在编译时会被替换掉，因为编译器知道这些变量的值，并且知道这些变量在运行时不能改变。<br>这种方式存在的一个问题是你使用了一个内部的或第三方库中的公有编译时常量，但是这个值后面被其他人改变了，但是你的客户端仍然在使用老的值，甚至你已经部署了一个新的jar。为了避免这种情况，当你在更新依赖JAR文件时，确保重新编译你的程序。 </p><h3 id="描述Java中的重载与重写？什么时候用重载，什么时候用重写？"><a href="#描述Java中的重载与重写？什么时候用重载，什么时候用重写？" class="headerlink" title="描述Java中的重载与重写？什么时候用重载，什么时候用重写？"></a>描述Java中的重载与重写？什么时候用重载，什么时候用重写？</h3><p>重载和重写都允许你用相同的名称来实现不同的功能，但是重载是编译时活动，而重写是运行时活动。你可以在同一个类中重载方法，但是只能在子类中重写方法。重写必须要有继承。</p><p>如果你看到一个类的不同实现有着不同的方式来做同一件事，那么就应该用重写（overriding），而重载（overloading）是用不同的输入做同一件事。在Java中，重载的方法签名不同，而重写并不是。</p><h3 id="BeanFactory和ApplicationContext的区别"><a href="#BeanFactory和ApplicationContext的区别" class="headerlink" title="BeanFactory和ApplicationContext的区别"></a>BeanFactory和ApplicationContext的区别</h3><blockquote><p>相关文章：[面试还不知道BeanFactory和ApplicationContext的区别？][3]</p></blockquote><h3 id="Java7、Java8的新特性"><a href="#Java7、Java8的新特性" class="headerlink" title="Java7、Java8的新特性"></a>Java7、Java8的新特性</h3><blockquote><p>相关文章：<a href="https://blog.csdn.net/csdnlijingran/article/details/88855000" target="_blank" rel="noopener">JDK7和JDK8新特性</a></p></blockquote><h2 id="JAVA-集合"><a href="#JAVA-集合" class="headerlink" title="JAVA 集合"></a>JAVA 集合</h2><p><strong>Collection</strong>：Collection 是集合 List、Set、Queue 的最基本的接口。</p><p><strong>Iterator</strong>：迭代器，可以通过迭代器遍历集合中的数据。</p><p><strong>Map</strong>：是映射表的基础接口。</p><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>Java 的 List 是非常常用的数据类型。List 是有序的 Collection。</p><p>Java List 一共三个实现类：分别是 ArrayList、Vector 和 LinkedList。</p><h4 id="ArrayList（数组）"><a href="#ArrayList（数组）" class="headerlink" title="ArrayList（数组）"></a>ArrayList（数组）</h4><p>ArrayList 是最常用的 List 实现类，内部是通过数组实现的，它允许对元素进行快速随机访问。数</p><p>组的缺点是每个元素之间不能有间隔，当数组大小不满足时需要增加存储能力，就要将已经有数</p><p>组的数据复制到新的存储空间中。当从 ArrayList 的中间位置插入或者删除元素时，需要对数组进</p><p>行复制、移动、代价比较高。因此，它适合随机查找和遍历，不适合插入和删除。</p><h4 id="Vector（数组实现、线程同步）"><a href="#Vector（数组实现、线程同步）" class="headerlink" title="Vector（数组实现、线程同步）"></a>Vector（数组实现、线程同步）</h4><p>Vector 与 ArrayList 一样，也是通过数组实现的，不同的是它支持线程的同步，即某一时刻只有一</p><p>个线程能够写 Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，因此，</p><p>访问它比访问 ArrayList 慢。</p><h4 id="LinkList（链表）"><a href="#LinkList（链表）" class="headerlink" title="LinkList（链表）"></a>LinkList（链表）</h4><p>LinkedList 是用链表结构存储数据的，很适合数据的动态插入和删除，随机访问和遍历速度比较</p><p>慢。另外，他还提供了 List 接口中没有定义的方法，专门用于操作表头和表尾元素，可以当作堆</p><p>栈、队列和双向队列使用。</p><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>Set 注重独一无二的性质,该体系集合用于存储无序(存入和取出的顺序不一定相同)元素，值不能重<br>复。对象的相等性本质是对象 hashCode 值（java 是依据对象的内存地址计算出的此序号）判断<br>的，如果想要让两个不同的对象视为相等的，就必须覆盖 Object 的 hashCode 方法和 equals 方<br>法</p><h4 id="HashSet（Hash-表）"><a href="#HashSet（Hash-表）" class="headerlink" title="HashSet（Hash 表）"></a>HashSet（Hash 表）</h4><p>哈希表边存放的是哈希值。HashSet 存储元素的顺序并不是按照存入时的顺序（和 List 显然不</p><p>同） 而是按照哈希值来存的所以取数据也是按照哈希值取得。元素的哈希值是通过元素的</p><p>hashcode 方法来获取的, HashSet 首先判断两个元素的哈希值，如果哈希值一样，接着会比较</p><p>equals 方法 如果 equls 结果为 true ，HashSet 就视为同一个元素。如果 equals 为 false 就不是</p><p>同一个元素。</p><p>哈希值相同 equals 为 false 的元素是怎么存储呢,就是在同样的哈希值下顺延（可以认为哈希值相</p><p>同的元素放在一个哈希桶中）。也就是哈希一样的存一列。如图 1 表示 hashCode 值不相同的情</p><p>况；图 2 表示 hashCode 值相同，但 equals 不相同的情况。</p><p>HashSet 通过 hashCode 值来确定元素在内存中的位置。一个 hashCode 位置上可以存放多个元</p><p>素。</p><h4 id="TreeSet（二叉树）"><a href="#TreeSet（二叉树）" class="headerlink" title="TreeSet（二叉树）"></a>TreeSet（二叉树）</h4><ol><li>TreeSet()是使用二叉树的原理对新 add()的对象按照指定的顺序排序（升序、降序），每增</li></ol><p>加一个对象都会进行排序，将对象插入的二叉树指定的位置。</p><ol start="2"><li>Integer 和 String 对象都可以进行默认的 TreeSet 排序，而自定义类的对象是不可以的，自</li></ol><p>己定义的类必须实现 Comparable 接口，并且覆写相应的 compareTo()函数，才可以正常使</p><p>用。</p><ol start="3"><li><p>在覆写 compare()函数时，要返回相应的值才能使 TreeSet 按照一定的规则来排序</p></li><li><p>比较此对象与指定对象的顺序。如果该对象小于、等于或大于指定对象，则分别返回负整</p></li></ol><p>数、零或正整数。</p><h4 id="LinkHashSet（HashSet-LinkedHashMap）"><a href="#LinkHashSet（HashSet-LinkedHashMap）" class="headerlink" title="LinkHashSet（HashSet+LinkedHashMap）"></a>LinkHashSet（HashSet+LinkedHashMap）</h4><p>对于 LinkedHashSet 而言，它继承与 HashSet、又基于 LinkedHashMap 来实现的。</p><p>LinkedHashSet 底层使用 LinkedHashMap 来保存所有元素，它继承与 HashSet，其所有的方法</p><p>操作上又与 HashSet 相同，因此 LinkedHashSet 的实现上非常简单，只提供了四个构造方法，并</p><p>通过传递一个标识参数，调用父类的构造器，底层构造一个 LinkedHashMap 来实现，在相关操</p><p>作上与父类 HashSet 的操作相同，直接调用父类 HashSet 的方法即可。</p><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a><strong>Map</strong></h3><h4 id="HashMap（数组-链表-红黑树）"><a href="#HashMap（数组-链表-红黑树）" class="headerlink" title="HashMap（数组+链表+红黑树）"></a>HashMap（数组+链表+红黑树）</h4><p>HashMap 根据键的 hashCode 值存储数据，大多数情况下可以直接定位到它的值，因而具有很快</p><p>的访问速度，但遍历顺序却是不确定的。</p><p> HashMap 最多只允许一条记录的键为 null，允许多条记</p><p>录的值为 null。</p><p>HashMap 非线程安全，即任一时刻可以有多个线程同时写 HashMap，可能会导</p><p>致数据的不一致。如果需要满足线程安全，可以用 Collections 的 synchronizedMap 方法使</p><p>HashMap 具有线程安全的能力，或者使用 ConcurrentHashMap。我们用下面这张图来介绍</p><p>HashMap 的结构。</p><h4 id="HashTable（线程安全）"><a href="#HashTable（线程安全）" class="headerlink" title="HashTable（线程安全）"></a>HashTable（线程安全）</h4><p>Hashtable 是遗留类，很多映射的常用功能与 HashMap 类似，不同的是它承自 Dictionary 类，</p><p>并且是线程安全的，任一时间只有一个线程能写 Hashtable，并发性不如 ConcurrentHashMap，</p><p>因为 ConcurrentHashMap 引入了分段锁。Hashtable 不建议在新代码中使用，不需要线程安全</p><p>的场合可以用 HashMap 替换，需要线程安全的场合可以用 ConcurrentHashMap 替换。</p><h4 id="TreeMap-（可排序）"><a href="#TreeMap-（可排序）" class="headerlink" title="TreeMap**（可排序）**"></a><strong>TreeMap**</strong>（可排序）**</h4><p>TreeMap 实现 SortedMap 接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，</p><p>也可以指定排序的比较器，当用 Iterator 遍历 TreeMap 时，得到的记录是排过序的。</p><p>如果使用排序的映射，建议使用 TreeMap。</p><p>在使用 TreeMap 时，key 必须实现 Comparable 接口或者在构造 TreeMap 传入自定义的</p><p>Comparator，否则会在运行时抛出 java.lang.ClassCastException 类型的异常。</p><p>参考：<a href="https://www.ibm.com/developerworks/cn/java/j-lo-tree/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-lo-tree/index.html</a></p><h4 id="LinkHashMap（记录插入顺序）"><a href="#LinkHashMap（记录插入顺序）" class="headerlink" title="LinkHashMap（记录插入顺序）"></a>LinkHashMap（记录插入顺序）</h4><p>LinkedHashMap 是 HashMap 的一个子类，保存了记录的插入顺序，在用 Iterator 遍历</p><p>LinkedHashMap 时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。</p><p>参考 1：<a href="http://www.importnew.com/28263.html" target="_blank" rel="noopener">http://www.importnew.com/28263.html</a></p><p>参考 2：<a href="http://www.importnew.com/20386.html#comment-648123" target="_blank" rel="noopener">http://www.importnew.com/20386.html#comment-648123</a></p><h4 id="ArrayList和LinkedList各自实现和区别"><a href="#ArrayList和LinkedList各自实现和区别" class="headerlink" title="ArrayList和LinkedList各自实现和区别"></a>ArrayList和LinkedList各自实现和区别</h4><ul><li><code>ArrayList</code>是实现了基于动态数组的数据结构，<code>LinkedList</code>基于链表的数据结构。 （<code>LinkedList</code>是双向链表，有next也有previous）</li><li><code>ArrayList</code>和<code>LinkedList</code>而言，在列表末尾增加一个元素所花的开销都是固定的。对<code>ArrayList</code>而言，主要是在内部数组中增加一项，指向所添加的元素，偶尔可能会导致对数组重新进行分配；而对<code>LinkedList</code>而言，这个开销是统一的，分配一个内部<code>Entry</code>对象。</li><li><code>ArrayList</code>的中间插入或删除一个元素意味着这个列表中剩余的元素都会被移动；而在<code>LinkedList</code>的中间插入或删除一个元素的开销是固定的。</li><li><code>LinkedList</code>不支持高效的随机元素访问。</li><li><code>ArrayList</code>的空间浪费主要体现在在list列表的结尾预留一定的容量空间，而<code>LinkedList</code>的空间花费则体现在它的每一个元素都需要消耗相当的空间</li></ul><p>场景：<br><code>LinkedList</code>链表，插入删除快，查找修改慢。 适用于频繁增删的场景。<br><code>ArrayList</code>数组，查找快，插入删除慢。 适用于频繁查找和修改的场景。</p><h4 id="怎么给List排序？"><a href="#怎么给List排序？" class="headerlink" title="怎么给List排序？"></a>怎么给List排序？</h4><ul><li>使用  Collections.sort 默认正序，可以传第二个参数自定义排序。</li><li>自定义bean实现 Comparable 接口。</li><li>实现Comparator接口自定义比较器。</li></ul><h4 id="都知道哪些常用的Map集合"><a href="#都知道哪些常用的Map集合" class="headerlink" title="都知道哪些常用的Map集合?"></a>都知道哪些常用的Map集合?</h4><p>HashMap、HashTable、TreeMap、LinkedHashMap</p><p><strong>HashMap介绍</strong></p><p><code>HashMap</code>中的数据结构为散列表，又名哈希表。<code>HashMap</code>是基于哈希表的<code>Map</code>接口的非同步实现。此实现提供所有可选的映射操作，并<strong><em>允许使用null值和null键</em></strong>。<br><code>HashMap</code>使用散列存储的方式保存kay-value键值对，因此其<strong><em>不支持数据保存的顺序</em></strong>。如果想要使用有序容器可以使用<code>LinkedHashMap</code>。<br><code>HashMap</code>是<strong><em>非线程安全的类</em></strong>，当作为共享可变资源使用的时候会出现线程安全问题。</p><ul><li><strong>数组</strong>：数组删除、插入性能不佳，寻址性能极优。其结构决定了其访问效率非常高，时间复杂度为 O(1)。这样的结构同时造成了对其进行插入和删除改动范围大的问题，影响了修改效率，时间复杂度为 O(n)。</li><li><strong>链表</strong>：链表查询性能不佳，删除、插入性能极优。链表的存储是通过一条（或两条）引用链条串联起来的，所以数据可以离散存储，对存储空间要求比较低。但其结构同样造成了其访问效率比较低，时间复杂度为 O(n)。数据的变更最多只会影响其相邻的两个数据节点，其时间复杂度仅仅为 O(1)。</li></ul><p><code>HashMap</code>使用数组+链表+树形结构的数据结构。除了数据本身的形式外，主要就是数据项查询和修改的效率。<br>哈希表的思想实际是基于数组可以通过下标随机访问数据的特性实现的。</p><p>参考：<br><a href="https://www.jianshu.com/p/b1d2d2711ccf" target="_blank" rel="noopener">HashMap实现原理</a><br><a href="https://www.jianshu.com/p/c561bab28e19" target="_blank" rel="noopener">HashMap实现原理</a><br><a href="https://www.cnblogs.com/vitasyuan/p/9220773.html" target="_blank" rel="noopener">HashMap实现原理及源码分析</a><br><a href="https://www.cnblogs.com/yuanblog/p/4441017.html" target="_blank" rel="noopener">Java中HashMap的实现原理</a></p><h4 id="hashtable和hashmap的区别"><a href="#hashtable和hashmap的区别" class="headerlink" title="hashtable和hashmap的区别"></a>hashtable和hashmap的区别</h4><p><strong>继承的父类不同</strong></p><p><code>Hashtable</code>继承自<code>Dictionary</code>类，而<code>HashMap</code>继承自<code>AbstractMap</code>类。但二者都实现了<code>Map</code>接口。</p><p><strong>线程安全性不同</strong></p><p><code>javadoc</code>中关于<code>hashmap</code>的一段描述如下：此实现不是同步的。如果多个线程同时访问一个哈希映射，而其中至少一个线程从结构上修改了该映射，则它必须保持外部同步。</p><p><strong>是否提供contains方法</strong></p><p><code>HashMap</code>把<code>Hashtable</code>的<code>contains</code>方法去掉了，改成<code>containsValue</code>和<code>containsKey</code>，因为<code>contains</code>方法容易让人引起误解。<br><code>Hashtable</code>则保留了<code>contains</code>，<code>containsValue</code>和<code>containsKey</code>三个方法，其中<code>contains</code>和<code>containsValue</code>功能相同。</p><p><strong>key和value是否允许null值</strong></p><p>其中key和value都是对象，并且不能包含重复key，但可以包含重复的value。<br><code>Hashtable</code>中，key和value都不允许出现null值。但是如果在<code>Hashtable</code>中有类似<code>put(null,null)</code>的操作，编译同样可以通过，<br>因为key和value都是<code>Object</code>类型，但运行时会抛出<code>NullPointerException</code>异常，这是JDK的规范规定的。</p><p><code>HashMap</code>中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null。<br>当<code>get()</code>方法返回null值时，可能是 <code>HashMap</code>中没有该键，也可能使该键所对应的值为null。<br>因此，在<code>HashMap</code>中不能由<code>get()</code>方法来判断<code>HashMap</code>中是否存在某个键， 而应该用<code>containsKey()</code>方法来判断。</p><p><strong>两个遍历方式的内部实现上不同</strong></p><p><code>Hashtable</code>、<code>HashMap</code>都使用了<code>Iterator</code>。而由于历史原因，<code>Hashtable</code>还使用了<code>Enumeration</code>的方式 。</p><p><strong>hash值不同</strong></p><p>哈希值的使用不同，<code>HashTable</code>直接使用对象的<code>hashCode</code>。而<code>HashMap</code>重新计算hash值。<br><code>hashCode</code>是jdk根据对象的地址或者字符串或者数字算出来的<code>int</code>类型的数值。<br><code>Hashtable</code>计算hash值，直接用key的<code>hashCode()</code>，而<code>HashMap</code>重新计算了key的hash值，<code>Hashtable</code>在求hash值对应的位置索引时，用取模运算，而<code>HashMap</code>在求位置索引时，则用与运算，且这里一般先用hash&amp;0x7FFFFFFF后，再对length取模，&amp;0x7FFFFFFF的目的是为了将负的hash值转化为正值，因为hash值有可能为负数，而&amp;0x7FFFFFFF后，只有符号外改变，而后面的位都不变。</p><p><strong>内部实现使用的数组初始化和扩容方式不同</strong></p><p><code>HashTable</code>在不指定容量的情况下的默认容量为11，而<code>HashMap</code>为16，<code>Hashtable</code>不要求底层数组的容量一定要为2的整数次幂，而<code>HashMap</code>则要求一定为2的整数次幂。<br><code>Hashtable</code>扩容时，将容量变为原来的2倍加1，而<code>HashMap</code>扩容时，将容量变为原来的2倍。<br><code>Hashtable</code>和<code>HashMap</code>它们两个内部实现方式的数组的初始大小和扩容的方式。<code>HashTable</code>中hash数组默认大小是11，增加的方式是 old*2+1。</p><p><code>Hashtable</code> 中的方法是<code>Synchronize</code>的，而<code>HashMap</code>中的方法在缺省情况下是非<code>Synchronize</code>的。在多线程并发的环境下，可以直接使用<code>Hashtable</code>，不需要自己为它的方法实现同步，但使用<code>HashMap</code>时就必须要自己增加同步处理。（结构上的修改是指添加或删除一个或多个映射关系的任何操作；仅改变与实例已经包含的键关联的值不是结构上的修改。）这一般通过对自然封装该映射的对象进行同步操作来完成。</p><p>如果不存在这样的对象，则应该使用 <code>Collections.synchronizedMap</code> 方法来“包装”该映射。最好在创建时完成这一操作，以防止对映射进行意外的非同步访问，如下所示：</p><pre><code class="java">Map m = Collections.synchronizedMap(new HashMap(...));</code></pre><p><code>Hashtable</code> 线程安全很好理解，因为它每个方法中都加入了<code>Synchronize</code>。<br><code>HashMap</code>底层是一个<code>Entry</code>数组，当发生hash冲突的时候，hashmap是采用链表的方式来解决的，在对应的数组位置存放链表的头结点。对链表而言，新加入的节点会从头结点加入。</p><h2 id="Java异常"><a href="#Java异常" class="headerlink" title="Java异常"></a>Java异常</h2><h3 id="Java检查异常、非检查异常、运行时异常、非运行时异常的区别"><a href="#Java检查异常、非检查异常、运行时异常、非运行时异常的区别" class="headerlink" title="Java检查异常、非检查异常、运行时异常、非运行时异常的区别"></a>Java检查异常、非检查异常、运行时异常、非运行时异常的区别</h3><p>Java把所有的非正常情况分为两种： <strong>异常（Exception）</strong>和 <strong>错误（Error） __，它们都继承<code>Throwable</code>父类。<br>Java的异常分为 __检查异常</strong> 和 <strong>非检查的异常</strong>。<br>其中根据<code>Exception</code>异常进行分类，可分为 <strong>运行时异常</strong>和 <strong>非运行时异常</strong>。</p><p><strong>异常：</strong></p><p>就是编译器要求你必须处理的异常。比如我们在编程某个文件的读于写时，编译器要求你必须要对某段代码try….catch… 或者 throws exception，这就是检查异常.简单的来说，你代码还没有运行，编码器就会检查你的代码，对可能出现的异常必须做出相对的处理。（比如当文件不存在时..）</p><p><strong>处理检查异常：</strong></p><ul><li>续往上抛出，（这是一个消极的方法），一直可以抛到java虚拟机来处理，通过throw exception抛出。</li><li>try…catch捕获</li></ul><p>(提示) 对于检查时的异常必须处理，或者必须捕获或者必须抛出</p><p><strong>检查异常大概有哪些？</strong></p><p>除了<code>RuntimeException</code>与其派生类(子类),以及错误(Error)。其他的差不多都是检查异常。</p><p><strong>检查异常：</strong></p><p>编译器不要求强制处置的异常，虽然有可能出现错误，但是我不会在编译的时候检查。</p><p><strong>如何处理非检查异常：</strong></p><ul><li>try….catch捕获</li><li>续抛出</li><li>处理</li></ul><p>这类异常一般我们是不处理的，因为会很判断会出现什么问题，而且有些异常你也无法运行时处理，比如空指针。</p><p><strong>非检查异常有哪些：</strong></p><p><code>RuntimeException</code>与其子类，以及错误(Error)</p><p><code>Exception</code>异常进行划分，它可分为运行时异常和非运行时异常。</p><p><strong>运行时异常:</strong></p><p>都是<code>RuntimeException</code>类及其子类异常，如<code>NullPointerException</code>(空指针异常)、<code>IndexOutOfBoundsException</code>(下标越界异常)等，这些异常是非检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。</p><p>运行时异常的特点是Java编译器不会检查它，也就是说，当程序中可能出现这类异常，即使没有用try-catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过</p><p><strong>非运行时异常：</strong></p><p>是<code>RuntimeException</code>以外的异常，类型上都属于<code>Exception</code>类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如<code>IOException</code>、<code>SQLException</code>等以及用户自定义的<code>Exception</code>异常，一般情况下不要自定义检查异常。</p><h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><h4 id="jsp和servlet的区别"><a href="#jsp和servlet的区别" class="headerlink" title="jsp和servlet的区别"></a>jsp和servlet的区别</h4><p><strong>什么是servlet:</strong></p><ul><li><code>Servlet</code>是一种服务器端的Java应用程序，具有独立于平台和协议的特性,可以生成动态的Web页面。 </li><li>它担当客户请求（Web浏览器或其他HTTP客户程序）与服务器响应（HTTP服务器上的数据库或应用程序）的中间层。</li></ul><p><strong>什么是jsp：</strong></p><ul><li><code>JSP</code>全名为<code>Java Server Pages</code>，中文名叫java服务器页面，其根本是一个简化的<code>Servlet</code>设计，它  是由Sun Microsystems公司倡导、许多公司参与一起建立的一种动态网页技术标准。</li><li><code>jsp</code>就是在html里面写java代码，<code>servlet</code>就是在java里面写html代码</li><li><code>jsp</code>更侧重于前端页面显示，<code>servlet</code>更侧重于业务逻辑。</li><li><code>Jsp</code> 本质上是<code>servle</code>t，用<code>jsp</code>实现的页面用<code>servlet</code>也能实现。</li></ul><p><strong>servlet和jsp的共同点和不同点：</strong></p><ul><li><code>servlet</code>在java代码中通过http servlet response来动态的生成一个html页面 </li><li><code>jsp</code>是通过吧java代码嵌入到html中去生成一个动态的html页面 </li></ul><p>一个是在java中写html，另一个是在html中写java代码</p><p><strong>jsp和servlet出现的意义：</strong></p><ul><li>当我们使用<code>servlet</code>来生成动态页面的时候，会非常的复杂。因为需要在out.println()来写入html语句。但是<code>servlet</code>在处理前端和后台数据交互的时候有特别的优秀。 </li><li>因此在这个时候我们引入<code>jsp</code>技术来替代<code>servlet</code>生成html的功能。让<code>serlvet</code>只专注前端页面和后台数据的交互。从而也是实现来mvc的思想。</li></ul><h4 id="hibernate跟Mybatis-ibatis-的区别"><a href="#hibernate跟Mybatis-ibatis-的区别" class="headerlink" title="hibernate跟Mybatis/ ibatis 的区别"></a>hibernate跟Mybatis/ ibatis 的区别</h4><blockquote><p>相关文章：[Hibernate与 MyBatis的比较][0]</p></blockquote><p><strong>两者相同点</strong></p><ul><li>Hibernate与MyBatis都可以是通过<code>SessionFactoryBuider</code>由XML配置文件生成<code>SessionFactory</code>，然后由<code>SessionFactory</code>生成<code>Session</code>，最后由<code>Session</code>来开启执行事务和SQL语句。其中<code>SessionFactoryBuider</code>，<code>SessionFactory</code>，<code>Session</code>的生命周期都是差不多的。</li><li>Hibernate和MyBatis都支持JDBC和JTA事务处理。</li></ul><p><strong>Mybatis优势</strong></p><ul><li>MyBatis可以进行更为细致的SQL优化，可以减少查询字段。MyBatis容易掌握，而Hibernate门槛较高。</li></ul><p><strong>Hibernate优势</strong></p><ul><li>Hibernate的DAO层开发比MyBatis简单，Mybatis需要维护SQL和结果映射。</li><li>Hibernate对对象的维护和缓存要比MyBatis好，对增删改查的对象的维护要方便。</li><li>Hibernate数据库移植性很好，MyBatis的数据库移植性不好，不同的数据库需要写不同SQL。</li><li>Hibernate有更好的二级缓存机制，可以使用第三方缓存。MyBatis本身提供的缓存机制不佳。</li></ul><h4 id="Hibernate的原理体系架构，五大核心接口，Hibernate对象的三种状态转换，事务管理。"><a href="#Hibernate的原理体系架构，五大核心接口，Hibernate对象的三种状态转换，事务管理。" class="headerlink" title="Hibernate的原理体系架构，五大核心接口，Hibernate对象的三种状态转换，事务管理。"></a>Hibernate的原理体系架构，五大核心接口，Hibernate对象的三种状态转换，事务管理。</h4><p>五大核心接口：</p><p><code>Configuration</code>接口：配置<code>Hibernate</code>,根启动<code>Hibernate</code>，创建<code>SessionFactory</code>对象。</p><p><code>SessionFactory</code>接口：初始化<code>Hibernate</code>，充当数据存储源的代理，创建<code>Session</code>对象。</p><p><code>Session</code>接口：负责保存、更新、删除、加载和查询对象。</p><p><code>Transaction</code>接口：管理事务。</p><p><code>Query</code>和<code>Criteria</code>接口：执行数据库查询。</p><p>三种状：<a href="https://www.cnblogs.com/smellpawn/p/10789369.html" target="_blank" rel="noopener">三种状态的转换</a></p><p>*<em>瞬时状态 (Transient) *</em></p><p>当我们通过Java的<code>new</code>关键字来生成一个实体对象时，这时这个实体对象就处于自由状态</p><p><strong>瞬时对象特点：</strong></p><p>不和<code>Session</code>实例关联 在数据库中没有和瞬时对象关联的记录</p><p><strong>持久状态 (Persistent)</strong></p><p>持久化对象就是已经被保存进数据库的实体对象，并且这个实体对象现在还处于<code>Hibernate</code>的缓存管理之中。这是对该实体对象的任何修改，都会在清理缓存时同步到数据库中。</p><p><strong>瞬时对象转为持久对象：</strong></p><p>通过 <code>Session</code> 的 <code>save()</code> 和 <code>saveOrUpdate()</code> 方法把一个瞬时对象与数据库相关联，这个瞬时对象就成为持久化对象。<br>使用 <code>fine()</code>,<code>get()</code>,<code>load()</code> 和<code>iterater()</code>待方法查询到的数据对象，将成为持久化对象。</p><p><strong>持久化对象的特点：</strong></p><p>和<code>Session</code>实例关联 在数据库中有和持久对象关联的记录</p><p><strong>脱管状态 (Detached) 游离状态</strong></p><p>当一个持久化对象，脱离开<code>Hibernate</code>的缓存管理后，它就处于游离状态，游离对象和自由对象的最大区别在于，游离对象在数据库中可能还存在一条与它对应的记录。</p><p>只是现在这个游离对象脱离了<code>Hibernate</code>的缓存管理，而自由对象不会在数据库中出现与它对应的数据记录。</p><p><strong>脱管对象特点：</strong></p><p>本质上和瞬时对象相同 只是比爱瞬时对象多了一个数据库记录标识值 id.</p><p><strong>持久对象转为脱管对象：</strong></p><p>当执行<code>close()</code>或<code>clear()</code>,<code>evict()</code>之后，持久对象会变为脱管对象。</p><p><strong>瞬时对象转为持久对象：</strong></p><p>通过 <code>Session</code> 的 <code>update()</code>,<code>saveOrUpdate()</code> 和 <code>lock()</code> 等方法，把脱管对象变为持久对象。</p><p><strong>事务管理：</strong></p><p>事务就是逻辑上的一组操作，组成这组操作的各个单元要么全部成功，要么全都失败。</p><p><strong>事务四个特性</strong></p><ul><li><p><strong>原子性</strong>: 不可分割</p></li><li><p><strong>一致性</strong>: 事务在执行前后，要保证数据的一致。</p></li><li><p><strong>隔离性</strong>: 一个事务在执行的过程中，不应该受到其它事务的干扰。</p></li><li><p><strong>持久性</strong>: 事务一旦结束，数据持久化到数据库。</p></li></ul><p><strong>问题:不考虑事务的隔离性，会产生什么问题?</strong></p><ul><li><strong>脏读</strong>: 一个事务读取到另一个事务的未提交数据</li><li><strong>不可重复读</strong>: 一个事务读取到另一个事务提交的数据(主要是指update)，会导致两次读取的结果不一致。</li><li><strong>虚读(幻读)</strong>: 一个事务读取到另一个事务提交的数据(主要是指insert),会导致两次读取结果不一致.</li></ul><p><strong>问题:对于上述问题如何解决?</strong></p><p>我们可以通过设置隔离级别来解决.</p><ul><li><code>READ_UNCOMMITED</code> 读取未提交， 它引发所有的隔离问题</li><li><code>READ_COMMITTED</code> 读已提交, 阻止脏读，可能发生不可重复读与虚读.</li><li><code>REPEATABLE_READ</code> 重复读 阻止脏读，不可重复读 可能发生虚读</li><li><code>SERIALIZABLE</code> 串行化 解决所有问题 不允许两个事务，同时操作一个目标数据。（效率低下）</li><li><code>ORACLE</code> 默认的是事务隔离级别 <code>READ_COMMITTED</code></li><li><code>MYSQL</code> 默认的事务隔离级别 <code>REPEATABLE_READ</code></li></ul><p><strong>Hibernate提供了三种管理session的方式:</strong></p><ul><li><code>Session</code>对象的生命周期与本地线程绑定(<code>ThreadLocal</code>)</li><li><code>Session</code>对象的生命周期与<code>JTA</code>事务绑定(分布式事务管理)</li><li><code>Hibernate</code>委托程序来管理<code>Session</code>的生命周期</li></ul><h3 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h3><h4 id="MyBatis框架的缺点？"><a href="#MyBatis框架的缺点？" class="headerlink" title="MyBatis框架的缺点？"></a>MyBatis框架的缺点？</h4><ul><li>SQL语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写SQL语句的功底有一定要求。</li><li>SQL语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。</li></ul><h4 id="MyBatis框架适用场合？"><a href="#MyBatis框架适用场合？" class="headerlink" title="MyBatis框架适用场合？"></a>MyBatis框架适用场合？</h4><ul><li>MyBatis专注于SQL本身，是一个足够灵活的DAO层解决方案。</li><li>对性能的要求很高，或者需求变化较多的项目，如互联网项目，MyBatis将是不错的选择。</li></ul><h4 id="Mybatis动态sql有什么用？执行原理？有哪些动态sql？"><a href="#Mybatis动态sql有什么用？执行原理？有哪些动态sql？" class="headerlink" title="Mybatis动态sql有什么用？执行原理？有哪些动态sql？"></a>Mybatis动态sql有什么用？执行原理？有哪些动态sql？</h4><p>Mybatis动态sql可以在Xml映射文件内，以标签的形式编写动态sql，执行原理是根据表达式的值 完成逻辑判断并动态拼接sql的功能。</p><p>Mybatis提供了9种动态sql标签：trim | where | set | foreach | if | choose | when | otherwise | bind。</p><h4 id="Xml映射文件中，除了常见的select-insert-updae-delete标签之外，还有哪些标签？"><a href="#Xml映射文件中，除了常见的select-insert-updae-delete标签之外，还有哪些标签？" class="headerlink" title="Xml映射文件中，除了常见的select|insert|updae|delete标签之外，还有哪些标签？"></a>Xml映射文件中，除了常见的select|insert|updae|delete标签之外，还有哪些标签？</h4><p><code>&lt;resultMap&gt;</code>、<code>&lt;parameterMap&gt;</code>、<code>&lt;sql&gt;</code>、<code>&lt;include&gt;</code>、<code>&lt;selectKey&gt;</code>，加上动态sql的9个标签，其中<code>&lt;sql&gt;</code>为sql片段标签，通过<code>&lt;include&gt;</code>标签引入sql片段，<code>&lt;selectKey&gt;</code>为不支持自增的主键生成策略标签。</p><h4 id="为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？"><a href="#为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？" class="headerlink" title="为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？"></a>为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？</h4><p>Hibernate属于全自动ORM映射工具，使用Hibernate查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。而Mybatis在查询关联对象或关联集合对象时，需要手动编写sql来完成，所以，称之为半自动ORM映射工具。</p><h4 id="MyBatis实现一对一有几种方式-具体怎么操作的？"><a href="#MyBatis实现一对一有几种方式-具体怎么操作的？" class="headerlink" title="MyBatis实现一对一有几种方式?具体怎么操作的？"></a>MyBatis实现一对一有几种方式?具体怎么操作的？</h4><p>有联合查询和嵌套查询,联合查询是几个表联合查询,只查询一次, 通过在resultMap里面配置association节点配置一对一的类就可以完成；</p><p>嵌套查询是先查一个表，根据这个表里面的结果的 外键id，去再另外一个表里面查询数据,也是通过association配置，但另外一个表的查询通过select属性配置。</p><h4 id="MyBatis实现一对多有几种方式-怎么操作的？"><a href="#MyBatis实现一对多有几种方式-怎么操作的？" class="headerlink" title="MyBatis实现一对多有几种方式,怎么操作的？"></a>MyBatis实现一对多有几种方式,怎么操作的？</h4><p>有联合查询和嵌套查询。联合查询是几个表联合查询,只查询一次,通过在resultMap里面的collection节点配置一对多的类就可以完成；嵌套查询是先查一个表,根据这个表里面的 结果的外键id,去再另外一个表里面查询数据,也是通过配置collection,但另外一个表的查询通过select节点配置</p><h4 id="Mybatis的一级、二级缓存"><a href="#Mybatis的一级、二级缓存" class="headerlink" title="Mybatis的一级、二级缓存"></a>Mybatis的一级、二级缓存</h4><p><strong>一级缓存</strong>: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认打开一级缓存。</p><p><strong>二级缓存</strong>: 与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储，不同在于其存储作用域为 Mapper(Namespace)，并且可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现Serializable序列化接口(可用来保存对象的状态),可在它的映射文件中配置<code>&lt;cache/&gt;</code></p><p>对于缓存数据更新机制，当某一个作用域(一级缓存 Session/二级缓存Namespaces)的进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear。 </p><h3 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h3><h4 id="使用Spring框架的好处是什么？"><a href="#使用Spring框架的好处是什么？" class="headerlink" title="使用Spring框架的好处是什么？"></a>使用Spring框架的好处是什么？</h4><p><strong><em>轻量：</em></strong> Spring 是轻量的，基本的版本大约2MB。<br><strong><em>控制反转：</em></strong> Spring通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是创建或查找依赖的对象们。<br><strong><em>面向切面的编程(AOP)：</em></strong> Spring支持面向切面的编程，并且把应用业务逻辑和系统服务分开。<br><strong><em>容器：</em></strong> Spring 包含并管理应用中对象的生命周期和配置。<br><strong><em>MVC框架：</em></strong> Spring的WEB框架是个精心设计的框架，是Web框架的一个很好的替代品。<br><strong><em>事务管理：</em></strong> Spring 提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事务（JTA）。<br><strong><em>异常处理：</em></strong> Spring 提供方便的API把具体技术相关的异常（比如由JDBC，Hibernate or JDO抛出的）转化为一致的unchecked 异常。</p><h4 id="springMVC流程说明"><a href="#springMVC流程说明" class="headerlink" title="springMVC流程说明"></a>springMVC流程说明</h4><ul><li>客户端（浏览器）发送请求，直接请求到<code>DispatcherServlet</code>。</li><li>由 DispatcherServlet 控制器查询一个或多个 HandlerMapping，找到处理请求的Controller。</li><li>DispatcherServlet 将请求提交到 Controller。</li><li>Controller 调用业务逻辑处理</li><li>处理器处理完业务后，会返回一个<code>ModelAndView</code>对象，<code>Model</code>是返回的数据对象<code>View</code>是个逻辑上的<code>View</code>。</li><li><code>ViewResolver</code>会根据逻辑<code>View</code>查找实际的<code>View</code>。</li><li><code>DispaterServlet</code>把返回的<code>Model</code>传给<code>View</code>。</li><li>通过<code>View</code>返回给请求者（浏览器）</li></ul><h4 id="什么是Spring-MVC框架的控制器？"><a href="#什么是Spring-MVC框架的控制器？" class="headerlink" title="什么是Spring MVC框架的控制器？"></a>什么是Spring MVC框架的控制器？</h4><p>控制器提供一个访问应用程序的行为，此行为通常通过服务接口实现。控制器解析用户输入并将其转换为一个由视图呈现给用户的模型。Spring用一个非常抽象的方式实现了一个控制层，允许用户创建多种用途的控制器。</p><h4 id="spring注入的几种方式（循环注入）"><a href="#spring注入的几种方式（循环注入）" class="headerlink" title="spring注入的几种方式（循环注入）"></a>spring注入的几种方式（循环注入）</h4><p><strong>构造方法注入 构造函数注入</strong></p><p>构造函数注入是除属性注入之外的另一种常用的注入方式，它可以保证一些必要的属性在bean实例化时就得到了设置，并在实例化后就可以使用。<br>循环依赖问题</p><p>Spring容器对构造函数配置Bean进行实例化有一个前提，即Bean构造函数入参引用的对象必须已经准备就绪。由于这个机制，如果两个Bean都相互引用，都采用构造函数注入方式，就会发生类似于线程死锁的循环依赖问题。</p><p><strong>构造函数注入方式：</strong></p><p><strong>优点：</strong></p><ul><li>构造函数可以保证一些重要的属性在bean实例化的时候就设置好，避免因为一些重要的属性没有提供而导致一个无用的Bean 实例情况</li><li>不需要为每个属性提供Setter方法，减少了类的方法个数</li><li>可以更好的封装类变量，不需要为每个属性提供Setter方法，避免外部错误的调用</li></ul><p><strong>缺点：</strong></p><ul><li>如果一个类属性太多，那么构造函数的参数将变成一个庞然大物，可读性较差</li><li>灵活性不强，在有些属性是可选的情况下，如果通过构造函数注入，也需要为可选的参数提供一个null值</li><li>如果有多个构造函数，则需要考虑配置文件和具体构造函数匹配歧义的问题，配置上相对复杂</li><li>构造函数不利于类的继承和拓展，因为子类需要引用父类复杂的构造函数</li><li>构造函数注入有时会造成循环依赖的问题</li></ul><p><strong>setter注入 属性注入</strong><br>属性注入即通过<code>setXXX( )</code>方法注入bean的属性值或依赖对象。由于属性注入方式具有可选择性和灵活性高的特点，因此它也是实际开发中最常用的注入方式。</p><p><strong>基于注解的注入 工厂方法注入</strong><br>工厂方法是应用中被经常使用的设计模式，也是 控制反转 和 单实例设计思想 的主要实现方法。工厂类负责创建一个或多个工厂类实例，工厂类方法一般以接口或抽象类变量的形式返回目标类实例。</p><p><strong>Spring工厂注入的方法可以分为 静态 和 非静态 两种。</strong></p><p><strong>【非静态工厂方法】</strong></p><p>有些工厂方法是非静态的，必须实例化工厂类之后才能调用工厂方法。下面通过一个实例来演示。</p><p><strong>【静态工厂方法】</strong></p><p>很多工厂类方法都是静态的，这意味着无需创建工厂类实例的情况下就可以调用工厂类方法。因此静态工程方法比非静态工厂方法的调用更加方便简洁。下面通过一个实例来演示静态工厂方法。</p><p><strong>构造函数注入理由：</strong></p><p>构造函数保证重要属性预先设置；<br>无需提供每个属性的setter方法，减少类的方法个数；<br>可以更好地封装类变量，避免外部错误调用。</p><p><strong>属性注入理由：</strong></p><p>属性过多时，构造函数变的臃肿；<br>构造函数注入灵活性不强，有时需要为属性注入null值；<br>多个构造函数时，配置上产生歧义，复杂度升高；<br>构造函数不利于类的继承和扩展；<br>构造函数注入会引起循环依赖的问题。 </p><p>相关文章:</p><p><a href="https://blog.csdn.net/qq_37464248/article/details/82463889" target="_blank" rel="noopener">Spring 依赖注入三种方式的实现，及循环依赖问题的解决（源码+XML配置）</a></p><p><a href="https://blog.csdn.net/shadow_zed/article/details/72566611" target="_blank" rel="noopener">Spring的五种依赖注入方式</a></p><h4 id="Spring框架的事务管理有哪些优点？"><a href="#Spring框架的事务管理有哪些优点？" class="headerlink" title="Spring框架的事务管理有哪些优点？"></a>Spring框架的事务管理有哪些优点？</h4><p>它为不同的事务API 如 JTA，JDBC，Hibernate，JPA 和JDO，提供一个不变的编程模式。<br>它为编程式事务管理提供了一套简单的API而不是一些复杂的事务API如<br>它支持声明式事务管理。<br>它和Spring各种数据访问抽象层很好得集成。</p><h4 id="spring如何实现事物管理的"><a href="#spring如何实现事物管理的" class="headerlink" title="spring如何实现事物管理的"></a>spring如何实现事物管理的</h4><p><strong>Spring内置AOP默认使用动态代理模式实现</strong></p><ul><li>编程式事务管理对基于 <code>POJO</code> 的应用来说是唯一选择。我们需要在代码中调用<code>beginTransaction()</code>、<code>commit()</code>、<code>rollback()</code>等事务管理相关的方法，这就是编程式事务管理。</li><li>基于 <code>TransactionProxyFactoryBean</code>的声明式事务管理</li><li>基于 <code>@Transactional</code> 的声明式事务管理</li><li>基于<code>Aspectj AOP</code>配置事务</li></ul><p>相关文章:<a href="https://www.cnblogs.com/yixianyixian/p/8372832.html" target="_blank" rel="noopener">spring事务管理(详解和实例)</a></p><h4 id="为什么说Spring是一个容器？"><a href="#为什么说Spring是一个容器？" class="headerlink" title="为什么说Spring是一个容器？"></a>为什么说Spring是一个容器？</h4><p>Spring的核心理念就是更方便地管理Java Bean，而被管理的Java Bean存缓存在一个Map中，这个Map就可以理解为用来装Java Bean的容器，即IOC容器</p><h4 id="springIOC-控制反转"><a href="#springIOC-控制反转" class="headerlink" title="springIOC 控制反转"></a>springIOC 控制反转</h4><p><code>IOC</code>的别名：<strong>依赖注入(DI)</strong><br><code>IOC</code>是<code>Inversion of Control</code>的缩写，多数书籍翻译成“控制反转”，还有些书籍翻译成为“控制反向”或者“控制倒置”。</p><p>为了解决对象之间的耦合度过高的问题 <strong>依赖注入(DI) __ 和 __控制反转(IOC)</strong> 是从不同的角度的描述的同一件事情，就是指通过引入<code>IOC</code>容器，利用依赖关系注入的方式，实现对象之间的解耦。</p><p>可以把<code>IOC</code>容器的工作模式看做是工厂模式的升华，可以把<code>IOC</code>容器看作是一个工厂，这个工厂里要生产的对象都在配置文件中给出定义，然后利用编程语言的的反射编程，根据配置文件中给出的类名生成相应的对象。</p><p>从实现来看，<code>IOC</code>是把以前在工厂方法里写死的对象生成代码，改变为由配置文件来定义，也就是把工厂和对象生成这两者独立分隔开来，目的就是提高灵活性和可维护性。</p><p>相关文章:[<a href="https://www.cnblogs.com/superjt/p/4311577.html" target="_blank" rel="noopener">Spring的IOC原理通俗解释一下</a></p><h4 id="IOC的优点是什么？"><a href="#IOC的优点是什么？" class="headerlink" title="IOC的优点是什么？"></a>IOC的优点是什么？</h4><p>IOC 或 依赖注入把应用的代码量降到最低。它使应用容易测试，单元测试不再需要单例和JNDI查找机制。</p><p>最小的代价和最小的侵入性使松散耦合得以实现。IOC容器支持加载服务时的饿汉式初始化和懒加载。</p><h4 id="spring-AOP的原理"><a href="#spring-AOP的原理" class="headerlink" title="spring AOP的原理"></a>spring AOP的原理</h4><p><code>Spring AOP</code>的面向切面编程，是面向对象编程的一种补充，用于处理系统中分布的各个模块的横切关注点，比如说事务管理、日志、缓存等。</p><p>它是使用动态代理实现的，在内存中临时为方法生成一个<code>AOP</code>对象，这个对象包含目标对象的所有方法，在特定的切点做了增强处理，并回调原来的方法。</p><p><code>Spring AOP</code>的动态代理主要有两种方式实现，<code>JDK</code>动态代理和<code>cglib</code>动态代理。</p><p><code>JDK</code>动态代理通过反射来接收被代理的类，但是被代理的类必须实现接口，核心是<code>InvocationHandler</code>和<code>Proxy</code>类。</p><p><code>cglib</code>动态代理的类一般是没有实现接口的类，<code>cglib</code>是一个代码生成的类库，可以在运行时动态生成某个类的子类，所以，<code>CGLIB</code>是通过继承的方式做的动态代理，因此如果某个类被标记为<code>final</code>，那么它是无法使用<code>CGLIB</code>做动态代理的。</p><p>相关文章:</p><p><a href="https://blog.csdn.net/moreevan/article/details/11977115/" target="_blank" rel="noopener">Spring AOP 实现原理</a></p><p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-springaopcglib/index.html" target="_blank" rel="noopener">Spring AOP 实现原理与 CGLIB 应用</a></p><h4 id="AOP-核心概念"><a href="#AOP-核心概念" class="headerlink" title="AOP 核心概念"></a>AOP 核心概念</h4><p>1、切面（aspect）：类是对物体特征的抽象，切面就是对横切关注点的抽象<br>2、横切关注点：对哪些方法进行拦截，拦截后怎么处理，这些关注点称之为横切关注点。 3、连接点（joinpoint）：被拦截到的点，因为 Spring 只支持方法类型的连接点，所以在 Spring<br>中连接点指的就是被拦截到的方法，实际上连接点还可以是字段或者构造器。 4、切入点（pointcut）：对连接点进行拦截的定义<br>5、通知（advice）：所谓通知指的就是指拦截到连接点之后要执行的代码，通知分为前置、后置、<br>异常、最终、环绕通知五类。 6、目标对象：代理的目标对象<br>7、织入（weave）：将切面应用到目标对象并导致代理对象创建的过程<br>8、引入（introduction）：在不修改代码的前提下，引入可以在运行期为类动态地添加一些方法<br>或字段。</p><h4 id="在SpringAOP中，关注点和横切关注的区别是什么？"><a href="#在SpringAOP中，关注点和横切关注的区别是什么？" class="headerlink" title="在SpringAOP中，关注点和横切关注的区别是什么？"></a>在SpringAOP中，关注点和横切关注的区别是什么？</h4><p>关注点是应用中一个模块的行为，一个关注点可能会被定义成一个我们想实现的一个功能。<br>横切关注点是一个关注点，此关注点是整个应用都会使用的功能，并影响整个应用，比如日志，安全和数据传输，几乎应用的每个模块都需要的功能。因此这些都属于横切关注点。</p><h4 id="你怎样定义类的作用域"><a href="#你怎样定义类的作用域" class="headerlink" title="你怎样定义类的作用域?"></a>你怎样定义类的作用域?</h4><p>当定义一个 在Spring里，我们还能给这个bean声明一个作用域。它可以通过bean 定义中的scope属性来定义。如，当Spring要在需要的时候每次生产一个新的bean实例，bean的scope属性被指定为prototype。</p><p>另一方面，一个bean每次使用的时候必须返回同一个实例，这个bean的scope 属性 必须设为 singleton。</p><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="什么是-JVM-？"><a href="#什么是-JVM-？" class="headerlink" title="什么是 JVM ？"></a>什么是 JVM ？</h3><p>JVM，即 Java Virtual Machine，Java 虚拟机。它通过模拟一个计算机来达到一个计算机所具有的的计算功能。JVM 能够跨计算机体系结构来执行 Java 字节码，主要是由于 JVM 屏蔽了与各个计算机平台相关的软件或者硬件之间的差异，使得与平台相关的耦合统一由 JVM 提供者来实现。</p><h3 id="JVM-由哪些部分组成？"><a href="#JVM-由哪些部分组成？" class="headerlink" title="JVM 由哪些部分组成？"></a>JVM 由哪些部分组成？</h3><p>*<em>类加载器 *</em> : 在 JVM 启动时或者类运行时将需要的 class 加载到 JVM 中</p><p><strong>执行引擎</strong> : 执行引擎的任务是负责执行 class 文件中包含的字节码指令，相当于实际机器上的 CPU</p><p><strong>内存区</strong> : 将内存划分成若干个区以模拟实际机器上的存储、记录和调度功能模块，如实际机器上的各种功能的寄存器或者 PC 指针的记录器等</p><p><strong>本地方法调用</strong> : 调用 C 或 C++ 实现的本地方法的代码返回结果</p><h3 id="类加载器是有了解吗？"><a href="#类加载器是有了解吗？" class="headerlink" title="类加载器是有了解吗？"></a>类加载器是有了解吗？</h3><p>类加载器（class loader）用来加载 Java 类到 Java 虚拟机中。</p><p>一般来说，Java 虚拟机使用 Java 类的方式如下：</p><p>Java 源程序（.java 文件）在经过 Java 编译器编译之后就被转换成 Java 字节代码（.class 文件）。</p><p>类加载器负责读取 Java 字节代码，并转换成 java.lang.Class类的一个实例。每个这样的实例用来表示一个 Java 类。通过此实例的 newInstance()方法就可以创建出该类的一个对象。实际的情况可能更加复杂，比如 Java 字节代码可能是通过工具动态生成的，也可能是通过网络下载的。</p><h3 id="Java-虚拟机是如何判定两个-Java-类是相同的？"><a href="#Java-虚拟机是如何判定两个-Java-类是相同的？" class="headerlink" title="Java 虚拟机是如何判定两个 Java 类是相同的？"></a>Java 虚拟机是如何判定两个 Java 类是相同的？</h3><p>Java 虚拟机不仅要看类的全名是否相同，还要看加载此类的类加载器是否一样。</p><p>只有两者都相同的情况，才认为两个类是相同的。即便是同样的字节代码，被不同的类加载器加载之后所得到的类，也是不同的。</p><p>比如一个 Java 类 com.example.Sample，编译之后生成了字节代码文件 Sample.class。</p><p>两个不同的类加载器 ClassLoaderA和 ClassLoaderB分别读取了这个 Sample.class文件，并定义出两个 java.lang.Class类的实例来表示这个类。</p><p>这两个实例是不相同的。对于 Java 虚拟机来说，它们是不同的类。试图对这两个类的对象进行相互赋值，会抛出运行时异常 ClassCastException。</p><h3 id="Java-是如何实现跨平台的？"><a href="#Java-是如何实现跨平台的？" class="headerlink" title="Java 是如何实现跨平台的？"></a>Java 是如何实现跨平台的？</h3><p>我们编写的 Java 源码，编译后会生成一种 .class 文件，称为字节码文件。Java 虚拟机（JVM）就是负责将字节码文件翻译成特定平台下的机器码然后运行，也就是说，只要在不同平台上安装对应的 JVM，就可以运行字节码文件，运行我们编写的 Java 程序。</p><p>而这个过程，我们编写的 Java 程序没有做任何改变，仅仅是通过 JVM 这一 “中间层” ，就能在不同平台上运行，真正实现了 “一次编译，到处运行” 的目的。</p><p><strong>注意</strong>：跨平台的是 Java 程序，而不是 JVM。JVM 是用 C/C++ 开发的，是编译后的机器码，不能跨平台，不同平台下需要安装不同版本的 JVM</p><h3 id="说说Java虚拟机的生命周期及体系结构。"><a href="#说说Java虚拟机的生命周期及体系结构。" class="headerlink" title="说说Java虚拟机的生命周期及体系结构。"></a>说说Java虚拟机的生命周期及体系结构。</h3><blockquote><p>相关文章 <a href="https://www.iteye.com/blog/maozj-697376" target="_blank" rel="noopener">Java虚拟机生命周期和体系结构</a></p></blockquote><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="synchronized-关键字？"><a href="#synchronized-关键字？" class="headerlink" title="synchronized 关键字？"></a>synchronized 关键字？</h3><p>进入时，执行 monitorenter，将计数器 +1，释放锁 monitorexit 时，计数器-1；<br>当一个线程判断到计数器为 0 时，则当前锁空闲，可以占用；反之，当前线程进入等待状态。<br>含义：（monitor 机制）<br>Synchronized 是在加锁，加对象锁。</p><p>对象锁是一种重量锁（monitor），synchronized 的锁机制会根据线程竞争情况在运行时会有偏向锁（单一线程）、轻量锁（多个线程访问 synchronized 区域）、对象锁（重量锁，多个线程存在竞争的情况）、自旋锁等。<br>该关键字是一个几种锁的封装。</p><h3 id="volatile-关键字？"><a href="#volatile-关键字？" class="headerlink" title="volatile 关键字？"></a>volatile 关键字？</h3><p>该关键字可以保证可见性不保证原子性。</p><p>功能：<br>主内存和工作内存，直接与主内存产生交互，进行读写操作，保证可见性；禁止 JVM 进行的指令重排序。<br>解析：</p><p>关于指令重排序的问题，可以查阅 DCL 双检锁失效相关资料。</p><h3 id="volatile-能使得一个非原子操作变成原子操作吗？"><a href="#volatile-能使得一个非原子操作变成原子操作吗？" class="headerlink" title="volatile 能使得一个非原子操作变成原子操作吗？"></a>volatile 能使得一个非原子操作变成原子操作吗？</h3><p>能。</p><p>一个典型的例子是在类中有一个 long 类型的成员变量。如果你知道该成员变量会被多个线程访问，如计数器、价格等，你最好是将其设置为 volatile。为什么？因为 Java 中读取 long 类型变量不是原子的，需要分成两步，如果一个线程正在修改该 long 变量的值，另一个线程可能只能看到该值的一半（前 32 位）。但是对一个 volatile 型的 long 或 double 变量的读写是原子。</p><h3 id="如果拿到synchronized的线程异常退出了，那么等待锁的线程是否会一直等待呢？"><a href="#如果拿到synchronized的线程异常退出了，那么等待锁的线程是否会一直等待呢？" class="headerlink" title="如果拿到synchronized的线程异常退出了，那么等待锁的线程是否会一直等待呢？"></a>如果拿到synchronized的线程异常退出了，那么等待锁的线程是否会一直等待呢？</h3><p>否定的，当<code>JVM</code>发现有锁的线程异常了之后会将它的锁自动释放，再由其它等待的线程拿到锁。</p><h3 id="了解可重入锁的含义，以及ReentrantLock-和synchronized的区别"><a href="#了解可重入锁的含义，以及ReentrantLock-和synchronized的区别" class="headerlink" title="了解可重入锁的含义，以及ReentrantLock 和synchronized的区别"></a>了解可重入锁的含义，以及ReentrantLock 和synchronized的区别</h3><p><code>Lock</code>是一个接口，不是Java语言内置的，<code>synchronized</code>是java语言内置的关键字。</p><p><code>Lock</code>与<code>synchronized</code>有一点非常大的不同，采用<code>synchronized</code>不需要用户区手动释放锁，当<code>synchronized</code>方法或者<code>synchronized</code>代码块执行完之后，系统会自动让线程释放对锁的占用；而<code>Lock</code>则必须要用户区手动释放锁，如果没有主动释放锁，就有可能导致出现死锁。</p><h3 id="atomicinteger和Volatile等线程安全操作的关键字的理解和使用"><a href="#atomicinteger和Volatile等线程安全操作的关键字的理解和使用" class="headerlink" title="atomicinteger和Volatile等线程安全操作的关键字的理解和使用"></a>atomicinteger和Volatile等线程安全操作的关键字的理解和使用</h3><p>多个线程访问一个共享变量时会发生线程安全问题。<br>AtomicInteger关键字能保证变量值得准确性，但不能保证它们能按顺序输出。但一般我们都只是获取它的值，而不是打印它的值。如果你既想保证数字的准确性又想保证能按顺序输出，你只能用Synchronized关键字了</p><p>volatile关键字它保证了变量在线程之间的可见性。让程序不要去缓存中取值，而是去主存中取值。被volatile修饰的变量，在多个线程下是可见的，其作用是让该变量在多哥线程下是透明的（让程序从内存中加载，不允许在缓存中加载）。可以保证变量的修改让所有线程可见;</p><p>可重入锁<br>一个线程获取它本身的锁是可以成功的，多个线程同时抢占同一个锁会失败。因为他们之间是互斥的。但是一个线程再次获取一个自己已经拿过的锁是可以成功的，这叫可重入锁机制 。</p><h3 id="Java创建线程之后，直接调用start-方法和run-的区别"><a href="#Java创建线程之后，直接调用start-方法和run-的区别" class="headerlink" title="Java创建线程之后，直接调用start()方法和run()的区别"></a>Java创建线程之后，直接调用start()方法和run()的区别</h3><p><code>run()</code>方法:在本线程内调用该<code>Runnable</code>对象的<code>run()</code>方法，可以重复多次调用；</p><p><code>start()</code>方法:启动一个线程，调用该<code>Runnable</code>对象的<code>run()</code>方法，不能多次启动一个线程；</p><ul><li><p><code>start()</code>用来启动一个线程，当调用<code>start()</code>方法时，系统才会开启一个线程，通过<code>Thead</code>类中<code>start()</code>方法来启动的线程处于就绪状态（可运行状态），此时并没有运行，一旦得到<code>CPU</code>时间片，就自动开始执行<code>run()</code>方法。此时不需要等待<code>run()</code>方法执行完也可以继续执行下面的代码，所以也由此看出<code>run()</code>方法并没有实现多线程。 </p></li><li><p><code>run()</code>方法是在本线程里的，只是线程里的一个函数,而不是多线程的。如果直接调用<code>run()</code>,其实就相当于是调用了一个普通函数而已，直接待用<code>run()</code>方法必须等待<code>run()</code>方法执行完毕才能执行下面的代码，所以执行路径还是只有一条，根本就没有线程的特征，所以在多线程执行时要使用<code>start()</code>方法而不是<code>run()</code>方法。</p></li><li><p>把需要处理的代码放到<code>run()</code>方法中，<code>start()</code>方法启动线程将自动调用<code>run()</code>方法，这个由java的内存机制规定的。并且<code>run()</code>方法必需是<code>public</code>访问权限，返回值类型为<code>void</code>。</p></li><li><p>当程序调用<code>start()</code>方法一个新线程将会被创建，并且在<code>run()</code>方法中的代码将会在新线程上运行</p></li></ul><h3 id="sleep-和-wait-n-、wait-的区别？"><a href="#sleep-和-wait-n-、wait-的区别？" class="headerlink" title="sleep( ) 和 wait( n)、wait( ) 的区别？"></a>sleep( ) 和 wait( n)、wait( ) 的区别？</h3><p>sleep 方法： 是 Thread 类的静态方法，当前线程将睡眠 n 毫秒，线程进入阻塞状态。当睡眠时间到了，会解除阻塞，进行可运行状态，等待 CPU 的到来。睡眠不释放锁（如果有的话）；<br>wait 方法： 是 Object 的方法，必须与 synchronized 关键字一起使用，线程进入阻塞状态，当 notify 或者 notifyall 被调用后，会解除阻塞。但是，只有重新占用互斥锁之后才会进入可运行状态。睡眠时，释放互斥锁。</p><h3 id="我们为什么要使用线程池？核心线程池内部实现了解吗？"><a href="#我们为什么要使用线程池？核心线程池内部实现了解吗？" class="headerlink" title="我们为什么要使用线程池？核心线程池内部实现了解吗？"></a>我们为什么要使用线程池？核心线程池内部实现了解吗？</h3><p>减少创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。<br>可以根据系统的承受能力，调整线程池中工作线程的数目，放置因为消耗过多的内存，而把服务器累趴下（每个线程大约需要 1 MB 内存，线程开的越多，消耗的内存也就越大，最后死机）</p><h3 id="核心线程池内部实现了解吗？"><a href="#核心线程池内部实现了解吗？" class="headerlink" title="核心线程池内部实现了解吗？"></a>核心线程池内部实现了解吗？</h3><p>对于核心的几个线程池，无论是 newFixedThreadPool() 方法，newSingleThreadExecutor() 还是 newCachedThreadPool() 方法，虽然看起来创建的线程有着完全不同的功能特点，但其实内部实现均使用了 ThreadPoolExecutor 实现，其实都只是 ThreadPoolExecutor 类的封装。</p><h3 id="常用的线程池模式以及不同线程池的使用场景"><a href="#常用的线程池模式以及不同线程池的使用场景" class="headerlink" title="常用的线程池模式以及不同线程池的使用场景"></a>常用的线程池模式以及不同线程池的使用场景</h3><p><strong>newCachedThreadPool：</strong></p><p><strong>底层：</strong>返回ThreadPoolExecutor实例，corePoolSize为0；maximumPoolSize为Integer.MAX_VALUE；keepAliveTime为60L；unit为TimeUnit.SECONDS；workQueue为SynchronousQueue(同步队列)</p><p><strong>通俗：</strong>当有新任务到来，则插入到SynchronousQueue中，由于SynchronousQueue是同步队列，因此会在池中寻找可用线程来执行，若有可以线程则执行，若没有可用线程则创建一个线程来执行该任务；若池中线程空闲时间超过指定大小，则该线程会被销毁。</p><p><strong>适用：</strong>执行很多短期异步的小程序或者负载较轻的服务器</p><p><strong>newFixedThreadPool：</strong></p><p><strong>底层：</strong>返回ThreadPoolExecutor实例，接收参数为所设定线程数量nThread，corePoolSize为nThread，maximumPoolSize为nThread；keepAliveTime为0L(不限时)；unit为：TimeUnit.MILLISECONDS；WorkQueue为：new LinkedBlockingQueue<Runnable>() 无解阻塞队列</p><p><strong>通俗：</strong>创建可容纳固定数量线程的池子，每隔线程的存活时间是无限的，当池子满了就不在添加线程了；如果池中的所有线程均在繁忙状态，对于新任务会进入阻塞队列中(无界的阻塞队列)</p><p><strong>适用：</strong>执行长期的任务，性能好很多</p><p><strong>newSingleThreadExecutor:</strong></p><p><strong>底层：</strong>FinalizableDelegatedExecutorService包装的ThreadPoolExecutor实例，corePoolSize为1；maximumPoolSize为1；keepAliveTime为0L；unit为：TimeUnit.MILLISECONDS；workQueue为：new LinkedBlockingQueue<Runnable>() 无解阻塞队列</p><p><strong>通俗：</strong>创建只有一个线程的线程池，且线程的存活时间是无限的；当该线程正繁忙时，对于新任务会进入阻塞队列中(无界的阻塞队列)</p><p><strong>适用：</strong>一个任务一个任务执行的场景</p><p><strong>NewScheduledThreadPool:</strong></p><p><strong>底层：</strong>创建ScheduledThreadPoolExecutor实例，corePoolSize为传递来的参数，maximumPoolSize为Integer.MAX_VALUE；keepAliveTime为0；unit为：TimeUnit.NANOSECONDS；workQueue为：new DelayedWorkQueue() 一个按超时时间升序排序的队列</p><p><strong>通俗：</strong>创建一个固定大小的线程池，线程池内线程存活时间无限制，线程池可以支持定时及周期性任务执行，如果所有线程均处于繁忙状态，对于新任务会进入DelayedWorkQueue队列中，这是一种按照超时时间排序的队列结构</p><p><strong>适用：</strong>周期性执行任务的场景</p><p><strong>线程池任务执行流程：</strong></p><p>当线程池小于corePoolSize时，新提交任务将创建一个新线程执行任务，即使此时线程池中存在空闲线程。<br>当线程池达到corePoolSize时，新提交任务将被放入workQueue中，等待线程池中任务调度执行<br>当workQueue已满，且maximumPoolSize&gt;corePoolSize时，新提交任务会创建新线程执行任务<br>当提交任务数超过maximumPoolSize时，新提交任务由RejectedExecutionHandler处理<br>当线程池中超过corePoolSize线程，空闲时间达到keepAliveTime时，关闭空闲线程<br>当设置allowCoreThreadTimeOut(true)时，线程池中corePoolSize线程空闲时间达到keepAliveTime也将关闭</p><p><strong>备注：</strong></p><p>一般如果线程池任务队列采用LinkedBlockingQueue队列的话，那么不会拒绝任何任务（因为队列大小没有限制），这种情况下，ThreadPoolExecutor最多仅会按照最小线程数来创建线程，也就是说线程池大小被忽略了。</p><p>如果线程池任务队列采用ArrayBlockingQueue队列的话，那么ThreadPoolExecutor将会采取一个非常负责的算法，比如假定线程池的最小线程数为4，最大为8所用的ArrayBlockingQueue最大为10。随着任务到达并被放到队列中，线程池中最多运行4个线程（即最小线程数）。即使队列完全填满，也就是说有10个处于等待状态的任务，ThreadPoolExecutor也只会利用4个线程。如果队列已满，而又有新任务进来，此时才会启动一个新线程，这里不会因为队列已满而拒接该任务，相反会启动一个新线程。新线程会运行队列中的第一个任务，为新来的任务腾出空间。</p><p>这个算法背后的理念是：该池大部分时间仅使用核心线程（4个），即使有适量的任务在队列中等待运行。这时线程池就可以用作节流阀。如果挤压的请求变得非常多，这时该池就会尝试运行更多的线程来清理；这时第二个节流阀—最大线程数就起作用了。</p><h3 id="多线程之间通信的同步问题"><a href="#多线程之间通信的同步问题" class="headerlink" title="多线程之间通信的同步问题"></a>多线程之间通信的同步问题</h3><p>在 Windows 系统中线程之间的通信有两种方式</p><p>使用全局变量进行通信<br>使用自定义消息进行通信<br>使隶属于同一进程的线程协调一致的工作就是线程间的同步。<br>在多线程环境里，需要对线程进行同步。<br>常用的同步对象有临界区（Critical Section）、互斥（Mutex）、信号量（Semaphore）和事件（event）等。<br>用于解决线程访问顺序引发的问题。<br>需要同步的情况可以从以下两方面考虑：<br>同时访问同一内存空间时发生的情况。<br>需要指定访问同一内存空间的线程执行顺序的情况。</p><p>相关文章:</p><p><a href="https://www.cnblogs.com/JNovice/p/9425361.html" target="_blank" rel="noopener">关于Java多线程的线程同步和线程通信的一些小问题（顺便分享几篇高质量的博文）</a></p><p><a href="https://blog.csdn.net/qq_41291253/article/details/92065354" target="_blank" rel="noopener">多线程间的通信和同步</a></p><h3 id="定时线程的使用"><a href="#定时线程的使用" class="headerlink" title="定时线程的使用"></a>定时线程的使用</h3><p>方法<code>schedule(TimerTask task,Date time)</code></p><p>在指定的日期执行一次某一任务。</p><p>方法<code>schedule(TimerTask task,Date firstTime,long period)</code></p><p>在指定的日期之后，按指定的间隔周期性地无限循环的执行某一任务。</p><p>方法<code>schedule(TimerTask task,long delay)</code></p><p>作用：以执行schedule(TimerTask task,long delay)方法当前的时间为参考时间，在此时间基础上延迟指定的毫秒数后执行一次TimerTask任务。</p><p>方法<code>schedule(TimerTask task,long delay,long period)</code></p><p>作用：以执行schedule(TimerTask task,long delay,long period)方法当前的时间为参考时间，在此时间基础上延迟指定的毫秒数，再以某一时间间隔无限次数执行某一任务。</p><p><a href="https://blog.csdn.net/xiao714041/article/details/73727417" target="_blank" rel="noopener">https://blog.csdn.net/xiao714041/article/details/73727417</a></p><h3 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h3><p><strong>根本区别：</strong></p><p>进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位在开销方面：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；<br>线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。</p><p><strong>所处环境：</strong></p><p>在操作系统中能同时运行多个进程（程序）；<br>而在同一个进程（程序）中有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行）</p><p><strong>内存分配方面：</strong></p><p>系统在运行的时候会为每个进程分配不同的内存空间；<br>而对线程而言，除了CPU外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），线程组之间只能共享资源。</p><p><strong>包含关系：</strong></p><p>没有线程的进程可以看做是单线程的，如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；<br>线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。</p><h3 id="什么叫线程安全"><a href="#什么叫线程安全" class="headerlink" title="什么叫线程安全"></a>什么叫线程安全</h3><p>死锁和脏数据就是典型的线程安全问题。</p><p>简单来说，线程安全就是： 在多线程环境中，能永远保证程序的正确性</p><p>只有存在共享数据时才需要考虑线程安全问题</p><p>线程安全的代码是多个线程同时执行也能工作的代码<br>如果一段代码可以保证多个线程访问的时候正确操作共享数据，那么它是线程安全的<br>当一个类被多个线程进行访问并且正确运行，它就是线程安全的</p><p>当多个线程访问某各类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步或者协同，这个类都能表现出正确的行为，那么就称这个类是线程安全的。</p><p>线程安全的级别或者粒度有三种，如下：</p><p><strong>线程安全</strong></p><p>这种情况下其实没有线程安全问题，比如上面的例子中，每个人都有自己专用的卫生间，所以不会存在竞争问题。</p><p><strong>条件安全</strong></p><p>条件安全，顾名思义是有条件的，所有人共用几个卫生间，抢到资源的就把门关上，通过门来隔离资源，后面的人就在外面等待直到里面的人出来。</p><p><strong>不安全</strong></p><p>这种情况下连门都没有，所以并不能很好保证资源安全，所以这种情况***不能让同时让多个人直接使用。</p><p>实现线程安全的方式</p><p>方式一：</p><p>不共享状态：</p><ul><li><p>无状态对象： 无状态对象一定是线程安全的，因为不会影响到其他线程</p></li><li><p>线程关闭： 仅在单线程环境下使用</p></li></ul><p>核心思路是避免共享数据结构，共享状态。包括：</p><ul><li><p>使用线程local变量</p></li><li><p>使用不可变对象</p></li></ul><p>方式二：</p><p>核心思路是共享不可避免，需要通过条件来确保按照。包括：</p><p><strong>互斥锁</strong></p><p>加锁：</p><ul><li><p>锁能使其保护的代码以串行的形式来访问，当给一个复合操作加锁后，能使其成为原子操作。一种错误的思想是只要对写数据的方法加锁，其实这是错的，对数据进行操作的所有方法都需加锁，不管是读还是写</p></li><li><p>加锁时需要考虑性能问题，不能总是一味地给整个方法加锁synchronized2就了事了，应该将方法中不影响共享状态且执行时间比较长的代码分离出去</p></li><li><p>加锁的含义不仅仅局限于互斥，还包括可见性。为了确保所有线程都能看见最新值，读操作和写操作必须使用同样的锁对象</p></li></ul><p><strong>CAS原子操作</strong></p><p>不可变对象：</p><p>可以使用final修饰的对象保证线程安全，由于final修饰的引用型变量(除String外)不可变是指引用不可变，但其指向的对象是可变的，所以此类必须安全发布，也即不能对外提供可以修改final对象的接口</p><h3 id="线程的几种状态"><a href="#线程的几种状态" class="headerlink" title="线程的几种状态"></a>线程的几种状态</h3><p><strong>新建(NEW)：</strong>新创建了一个线程对象。</p><p><strong>可运行(RUNNABLE)：</strong>线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取cpu 的使用权 。</p><p><strong>运行(RUNNING)：</strong>可运行状态(runnable)的线程获得了cpu 时间片（timeslice） ，执行程序代码。</p><p><strong>阻塞(BLOCKED)：</strong>阻塞状态是指线程因为某种原因放弃了cpu 使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有机会再次获得cpu timeslice 转到运行(running)状态。阻塞的情况分三种： </p><ul><li>等待阻塞：运行(running)的线程执行o.wait()方法，JVM会把该线程放入等待队列(waitting queue)中。</li><li>同步阻塞：运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。</li><li>其他阻塞：运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。</li></ul><p><strong>死亡(DEAD)：</strong>线程run()、main() 方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。</p><p>相关文章:<a href="https://blog.csdn.net/xingjing1226/article/details/81977129" target="_blank" rel="noopener">线程的5种状态详解</a></p><h3 id="HashMap-是否线程安全"><a href="#HashMap-是否线程安全" class="headerlink" title="HashMap 是否线程安全"></a>HashMap 是否线程安全</h3><p>不是线程安全<br>当多个线程同时检测到总数量超过门限值的时候就会同时调用resize操作，各自生成新的数组并rehash后赋给该map底层的数组table，结果最终只有最后一个线程生成的新数组被赋给table变量，其他线程的均会丢失。而且当某些线程已经完成赋值而其他线程刚开始的时候，就会用已经被赋值的table作为原始数组，这样也会有问题。</p><p>相关文章:<a href="https://blog.csdn.net/mydreamongo/article/details/8960667" target="_blank" rel="noopener">HashMap为什么是线程不安全的？</a></p><h2 id="Java-IO"><a href="#Java-IO" class="headerlink" title="Java IO"></a>Java IO</h2><h3 id="操作的数据是否是纯文本数据？"><a href="#操作的数据是否是纯文本数据？" class="headerlink" title="操作的数据是否是纯文本数据？"></a>操作的数据是否是纯文本数据？</h3><p><strong>如果是：</strong></p><ul><li><p>数据source：Reader</p></li><li><p>数据destination：Writer </p></li></ul><p><strong>如果不是：</strong></p><ul><li><p>数据source：InputStream</p></li><li><p>数据destination：OutputStream123456</p></li></ul><h3 id="Java-IO体系中有太多的对象，到底用哪个呢？"><a href="#Java-IO体系中有太多的对象，到底用哪个呢？" class="headerlink" title="Java IO体系中有太多的对象，到底用哪个呢？"></a>Java IO体系中有太多的对象，到底用哪个呢？</h3><p>   明确操作的数据设备。<br>   数据source对应的设备：硬盘(File)，内存(数组)，键盘(System.in)<br>   数据destination对应的设备：硬盘(File)，内存(数组)，控制台(System.out)。</p><h3 id="java中有几种类型的流？"><a href="#java中有几种类型的流？" class="headerlink" title="java中有几种类型的流？"></a>java中有几种类型的流？</h3><p>字符流和字节流。</p><p>字节流继承inputStream和OutputStream</p><p>字符流继承自InputSteamReader和OutputStreamWriter。</p><h3 id="字符流和字节流有什么区别？"><a href="#字符流和字节流有什么区别？" class="headerlink" title="字符流和字节流有什么区别？"></a>字符流和字节流有什么区别？</h3><p>要把一片二进制数据数据逐一输出到某个设备中，或者从某个设备中逐一读取一片二进制数据，不管输入输出设备是什么，我们要用统一的方式来完成这些操作，用一种抽象的方式进行描述，这个抽象描述方式起名为IO流，不同的实现类就代表不同的输入和输出设备，它们都是针对字节进行操作的。</p><p>*<em>应用中，经常要完全是字符的一段文本输出去或读进来，用字节流可以吗？ *</em></p><p>计算机中的一切最终都是二进制的字节形式存在。对于“中国”这些字符，首先要得到其对应的字节，然后将字节写入到输出流。读取时，首先读到的是字节，可是我们要把它显示为字符，我们需要将字节转换成字符。由于这样的需求很广泛，人家专门提供了字符流的包装类。</p><p>底层设备永远只接受字节数据，有时候要写字符串到底层设备，需要将字符串转成字节再进行写入。字符流是字节流的包装，字符流则是直接接受字符串，它内部将串转成字节，再写入底层设备，这为我们向IO设别写入或读取字符串提供了一点点方便。</p><h3 id="IO里面的常见类，字节流、字符流、接口、实现类、方法阻塞"><a href="#IO里面的常见类，字节流、字符流、接口、实现类、方法阻塞" class="headerlink" title="IO里面的常见类，字节流、字符流、接口、实现类、方法阻塞"></a>IO里面的常见类，字节流、字符流、接口、实现类、方法阻塞</h3><p>输入流就是从外部文件输入到内存，输出流主要是从内存输出到文件。 </p><p><code>IO</code>里面常见的类，第一印象就只知道<code>IO</code>流中有很多类，<code>IO</code>流主要分为字符流和字节流。</p><p>字符流中有抽象类<code>InputStream</code>和<code>OutputStream</code>，它们的子类<code>FileInputStream</code>，<code>FileOutputStream</code>,<code>BufferedOutputStream</code>等。字符流<code>BufferedReader</code>和<code>Writer</code>等。都实现了<code>Closeable</code>, <code>Flushable</code>,<code>Appendable</code>这些接口。</p><p>程序中的输入输出都是以流的形式保存的，流中保存的实际上全都是字节文件。<br>java中的阻塞式方法是指在程序调用改方法时，必须等待输入数据可用或者检测到输入结束或者抛出异常，否则程序会一直停留在该语句上，不会执行下面的语句。比如<code>read()</code>和<code>readLine()</code>方法。</p><h3 id="String-编码UTF-8-和GBK的区别"><a href="#String-编码UTF-8-和GBK的区别" class="headerlink" title="String 编码UTF-8 和GBK的区别"></a>String 编码UTF-8 和GBK的区别</h3><p><code>GBK</code>字符均使用双字节来表示，只不过为区分中文，将其最高位都定成1。</p><p><code>UTF－8</code>编码则是用以解决国际上字符的一种多字节编码，它对英文使用8位（即一个字节），中文使用24位（三个字节）来编码。对于英文字符较多的论坛则用UTF－8节省空间。</p><p><code>GBK</code>包含全部中文字符；</p><p><code>UTF-8</code>则包含全世界所有国家需要用到的字符。</p><p><code>GBK</code>是在国家标准<code>GB2312</code>基础上扩容后兼容<code>GB2312</code>的标准；（好像还不是国家标准）</p><p><code>UTF-8</code>编码的文字可以在各国各种支持<code>UTF8</code>字符集的浏览器上显示。</p><p>总结：</p><p><code>GBK</code>就是在保存你的帖子的时候，一个汉字占用两个字节。外国人看会出现乱码，此为我中华为自己汉字编码而形成之解决方案。</p><p><code>UTF8</code>就是在保存你的帖子的时候，一个汉字占用3个字节。但是外国人看的话不会乱码，此为西人为了解决多字节字符而形成之解决方案。</p><pre><code>   GBK编码方式的编码是以中国国情而创造的，在国际上的兼容性不好，这也是为什么大多数的网页是使用UTF-8编码而不是GBK。</code></pre><h3 id="session和cookie的区别和联系"><a href="#session和cookie的区别和联系" class="headerlink" title="session和cookie的区别和联系"></a>session和cookie的区别和联系</h3><p>1、Cookie定义</p><pre><code>   Cookie是服务器在本地机器上存储的小段文本并随每一个请求发送至同一服务器。Cookies保存在客户端，主要内容包括：名字，值，过期时间，路径等等。  </code></pre><p>2、会话cookie和持久cookie的区别</p><p>会话cookie：不设置过期时间，只要关闭浏览器窗口cookie就消失了。会话cookie不保存在硬盘上，保存在内存里。</p><p>持久cookie：设置过期时间，浏览器就会把cookie保存到硬盘上，关闭后再次打开浏览器，这些cookie依然有效直到超过设定的过期时间。存储在硬盘上的cookie可以在不同的浏览器进程间共享。而对于保存在内存的cookie，不同的浏览器有不同的处理方式。</p><pre><code>   利用持久Cookie自动登录：当用户在某个网站注册后，就会收到一个惟一用户ID的cookie。客户后来重新连接时，这个用户ID会自动返回，服务器对它进行检查，确定它是否为注册用户且选择了自动登录，从而使用户无需给出明确的用户名和密码，就可以访问服务器上的资源。</code></pre><p>3、Session定义</p><pre><code>  Session是在服务器端保存用户数据。浏览器第一次发送请求时，服务器自动生成了Session ID来唯一标识这个并将其通过响应发送到浏览器。浏览器第二次发送请求会将前一次服务器响应中的Session ID放在请求中一并发送到服务器上，服务器从请求中提取出Session ID，并和保存的所有Session ID进行对比，找到这个用户的信息。一般这个Session ID会有个时间限制，默认30分钟超时后毁掉这次Session ID。</code></pre><p>  Session和Cookie有一定关系，Session id存在Cookie中，每次访问的时候将Session id传到服务器进行对比。</p><p>4、Cookie和Session的区别</p><p>Cookie 在客户端（浏览器、易伪造、不安全），Session 在服务器端（会消耗服务器资源）。</p><p>Cookie 只能保存ASCII字符串，如果是Unicode字符或者二进制数据需要先进行编码。</p><p>Cookie中也不能直接存取Java对象。</p><p> Session能够存取很多类型的数据，包括String、Integer、List、Map等，Session中也可以保存JJava对象。</p><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="什么是里氏替换原则？"><a href="#什么是里氏替换原则？" class="headerlink" title="什么是里氏替换原则？"></a>什么是里氏替换原则？</h3><p>1、开闭原则（Open Close Principle）</p><p>开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。</p><p>2、里氏代换原则（Liskov Substitution Principle）</p><p>里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。—— From Baidu 百科</p><p>3、依赖倒转原则（Dependence Inversion Principle）</p><p>这个是开闭原则的基础，具体内容：真对接口编程，依赖于抽象而不依赖于具体。</p><p>4、接口隔离原则（Interface Segregation Principle）</p><p>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。</p><p>5、迪米特法则（最少知道原则）（Demeter Principle）</p><p>为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。</p><p>6、合成复用原则（Composite Reuse Principle）</p><p>原则是尽量使用合成/聚合的方式，而不是使用继承</p><h3 id="适配器模式是什么？什么时候使用？"><a href="#适配器模式是什么？什么时候使用？" class="headerlink" title="适配器模式是什么？什么时候使用？"></a>适配器模式是什么？什么时候使用？</h3><p>适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。适配器模式提供对接口的转换。如果你的客户端使用某些接口，但是你有另外一些接口，你就可以写一个适配去来连接这些接口。</p><h3 id="什么时候使用访问者模式？"><a href="#什么时候使用访问者模式？" class="headerlink" title="什么时候使用访问者模式？"></a>什么时候使用访问者模式？</h3><p>访问者模式用于解决在类的继承层次上增加操作，但是不直接与之关联。这种模式采用双派发的形式来增加中间层。</p><h3 id="适配器模式与装饰器模式有什么区别？"><a href="#适配器模式与装饰器模式有什么区别？" class="headerlink" title="适配器模式与装饰器模式有什么区别？"></a>适配器模式与装饰器模式有什么区别？</h3><p>适配器模式被用于桥接两个接口，而装饰模式的目的是在不修改类的情况下给类增加新的功能。</p><p>装饰者模式：动态地将责任附加到对象上，若要扩展功能，装饰者模提供了比继承更有弹性的替代方案。</p><p>通俗的解释：装饰模式就是给一个对象增加一些新的功能，而且是动态的，要求装饰对象和被装饰对象实现同一个接口，装饰对象持有被装饰对象的实例。</p><p>适配器模式：将一个类的接口，转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间。</p><p>适配器模式有三种：类的适配器模式、对象的适配器模式、接口的适配器模式。</p><p>通俗的说法：适配器模式将某个类的接口转换成客户端期望的另一个接口表示，目的是消除由于接口不匹配所造成的类的兼容性问题。</p><h3 id="继承和组合之间有什么不同？"><a href="#继承和组合之间有什么不同？" class="headerlink" title="继承和组合之间有什么不同？"></a>继承和组合之间有什么不同？</h3><p>虽然两种都可以实现代码复用，但是组合比继承共灵活，因为组合允许你在运行时选择不同的实现。用组合实现的代码也比继承测试起来更加简单。</p><h3 id="讲一下模版模式和策略模式的区别？"><a href="#讲一下模版模式和策略模式的区别？" class="headerlink" title="讲一下模版模式和策略模式的区别？"></a>讲一下模版模式和策略模式的区别？</h3><p>模板方法模式的主要思想：定义一个算法流程，将一些特定步骤的具体实现、延迟到子类。使得可以在不改变算法流程的情况下，通过不同的子类、来实现“定制”流程中的特定的步骤。</p><p>策略模式的主要思想：使不同的算法可以被相互替换，而不影响客户端的使用。</p><h3 id="工厂模式与抽象工厂模式的区别？"><a href="#工厂模式与抽象工厂模式的区别？" class="headerlink" title="工厂模式与抽象工厂模式的区别？"></a>工厂模式与抽象工厂模式的区别？</h3><p>首先来看看这两者的定义区别：</p><p>工厂模式：定义一个用于创建对象的借口，让子类决定实例化哪一个类</p><p>抽象工厂模式：为创建一组相关或相互依赖的对象提供一个接口，而且无需指定他们的具体类</p><p>这个区别在于产品，如果产品单一，最合适用工厂模式，但是如果有多个业务品种、业务分类时，通过抽象工厂模式产生需要的对象是一种非常好的解决方式。再通俗深化理解下：工厂模式针对的是一个产品等级结构 ，抽象工厂模式针对的是面向多个产品等级结构的。</p><h3 id="什么时候使用享元模式？"><a href="#什么时候使用享元模式？" class="headerlink" title="什么时候使用享元模式？"></a>什么时候使用享元模式？</h3><p>享元模式通过共享对象来避免创建太多的对象。为了使用享元模式，你需要确保你的对象是不可变的，这样你才能安全的共享。JDK 中 String 池、Integer 池以及 Long 池都是很好的使用了享元模式的例子。</p><h3 id="你可以说出几个在JDK库中使用的设计模式吗？"><a href="#你可以说出几个在JDK库中使用的设计模式吗？" class="headerlink" title="你可以说出几个在JDK库中使用的设计模式吗？"></a>你可以说出几个在JDK库中使用的设计模式吗？</h3><p>装饰器设计模式（Decorator design pattern）被用于多个Java IO类中。单例模式（Singleton pattern）用于Runtime，Calendar和其他的一些类中。工厂模式（Factory pattern）被用于各种不可变的类如Boolean，像Boolean.valueOf，观察者模式（Observer pattern）被用于Swing和很多的事件监听中。</p><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h3 id="使用redis优缺点？"><a href="#使用redis优缺点？" class="headerlink" title="使用redis优缺点？"></a>使用redis优缺点？</h3><p>优点</p><ul><li>速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)</li><li>支持丰富数据类型，支持string，list，set，sorted set，hash</li><li>支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行</li><li>丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除</li><li>支持主从复制，主机会自动将数据同步到从机，可以进行读写分离。</li></ul><p>缺点</p><ul><li>数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。</li><li>Redis 不具备自动容错和恢复功能，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或者手动切换前端的IP才能恢复。</li><li>主机宕机，宕机前有部分数据未能及时同步到从机，切换IP后还会引入数据不一致的问题，降低了系统的可用性。</li><li>Redis 较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。为避免这一问题，运维人员在系统上线时必须确保有足够的空间，这对资源造成了很大的浪费。</li></ul><h3 id="Redis支持的数据类型？"><a href="#Redis支持的数据类型？" class="headerlink" title="Redis支持的数据类型？"></a>Redis支持的数据类型？</h3><ul><li><p>String字符串 </p></li><li><p>Hash（哈希）</p></li><li><p>List（列表）</p></li><li><p>Set（集合）</p></li><li><p>zset(sorted set：有序集合)</p></li></ul><h3 id="什么是Redis持久化？Redis有哪几种持久化方式？优缺点是什么？"><a href="#什么是Redis持久化？Redis有哪几种持久化方式？优缺点是什么？" class="headerlink" title="什么是Redis持久化？Redis有哪几种持久化方式？优缺点是什么？"></a>什么是Redis持久化？Redis有哪几种持久化方式？优缺点是什么？</h3><p>持久化就是把内存的数据写到磁盘中去，防止服务宕机了内存数据丢失。</p><p>Redis 提供了两种持久化方式:<code>RDB</code>(默认)和<code>AOF</code> </p><p><strong>RDB：</strong>  rdb是Redis DataBase缩写</p><p>功能核心函数rdbSave(生成RDB文件)和rdbLoad（从文件加载内存）两个函数</p><p><strong>AOF:</strong>   Aof是Append-only file缩写</p><p>每当执行服务器(定时)任务或者函数时flushAppendOnlyFile 函数都会被调用， 这个函数执行以下两个工作aof写入保存：</p><ul><li><p><strong>WRITE</strong>：根据条件，将 aof_buf 中的缓存写入到 AOF 文件</p></li><li><p><strong>SAVE</strong>：根据条件，调用 fsync 或 fdatasync 函数，将 AOF 文件保存到磁盘中。</p></li></ul><p><strong>存储结构:</strong></p><p> 内容是redis通讯协议(RESP )格式的命令文本存储。</p><p><strong>比较</strong>：</p><p>1、aof文件比rdb更新频率高，优先使用aof还原数据。</p><p>2、aof比rdb更安全也更大</p><p>3、rdb性能比aof好</p><p>4、如果两个都配了优先加载AOF</p><h3 id="Redis的内存淘汰策略有哪些？"><a href="#Redis的内存淘汰策略有哪些？" class="headerlink" title="Redis的内存淘汰策略有哪些？"></a>Redis的内存淘汰策略有哪些？</h3><p>Redis的内存淘汰策略是指在Redis的用于缓存的内存不足时，怎么处理需要新写入且需要申请额外空间的数据。</p><p><strong>全局的键空间选择性移除</strong></p><p>noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。<br>allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。（这个是最常用的）<br>allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。</p><p><strong>设置过期时间的键空间选择性移除</strong></p><p>volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。<br>volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。<br>volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。</p><p><strong>总结</strong></p><p>Redis的内存淘汰策略的选取并不会影响过期的key的处理。内存淘汰策略用于处理内存不足时的需要申请额外空间的数据；过期策略用于处理过期的缓存数据。</p><h3 id="Redis-有哪些架构模式？"><a href="#Redis-有哪些架构模式？" class="headerlink" title="Redis 有哪些架构模式？"></a>Redis 有哪些架构模式？</h3><p> <strong>单机版</strong></p><p>特点：简单</p><p>问题：</p><p>1、内存容量有限 2、处理能力有限 3、无法高可用。</p><p><strong>主从复制</strong></p><p>Redis 的复制（replication）功能允许用户根据一个 Redis 服务器来创建任意多个该服务器的复制品，其中被复制的服务器为主服务器（master），而通过复制创建出来的服务器复制品则为从服务器（slave）。 只要主从服务器之间的网络连接正常，主从服务器两者会具有相同的数据，主服务器就会一直将发生在自己身上的数据更新同步 给从服务器，从而一直保证主从服务器的数据相同。</p><p>特点：</p><p>1、master/slave 角色</p><p>2、master/slave 数据相同</p><p>3、降低 master 读压力在转交从库</p><p>问题：</p><p>无法保证高可用</p><p>没有解决 master 写的压力</p><p><strong>哨兵</strong></p><p>Redis sentinel 是一个分布式系统中监控 redis 主从服务器，并在主服务器下线时自动进行故障转移。其中三个特性：</p><ul><li><p><strong>监控（Monitoring</strong>）：  Sentinel 会不断地检查你的主服务器和从服务器是否运作正常。</p></li><li><p><strong>提醒（Notification）</strong>： 当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。</p></li><li><p><strong>自动故障迁移（Automatic failover）</strong>： 当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作。</p></li></ul><p>特点：</p><p>1、保证高可用</p><p>2、监控各个节点</p><p>3、自动故障迁移</p><p>缺点：主从模式，切换需要时间丢数据</p><p>没有解决 master 写的压力</p><p><strong>集群（proxy 型）</strong></p><p>Twemproxy 是一个 Twitter 开源的一个 redis 和 memcache 快速/轻量级代理服务器； Twemproxy 是一个快速的单线程代理程序，支持 Memcached ASCII 协议和 redis 协议。</p><p>特点：1、多种 hash 算法：MD5、CRC16、CRC32、CRC32a、hsieh、murmur、Jenkins </p><p>2、支持失败节点自动删除</p><p>3、后端 Sharding 分片逻辑对业务透明，业务方的读写方式和操作单个 Redis 一致</p><p>缺点：增加了新的 proxy，需要维护其高可用。</p><p><strong>集群（直连型）</strong></p><p>从redis 3.0之后版本支持redis-cluster集群，Redis-Cluster采用无中心结构，每个节点保存数据和整个集群状态,每个节点都和其他所有节点连接。</p><p>特点：</p><p>1、无中心架构（不存在哪个节点影响性能瓶颈），少了 proxy 层。</p><p>2、数据按照 slot 存储分布在多个节点，节点间数据共享，可动态调整数据分布。</p><p>3、可扩展性，可线性扩展到 1000 个节点，节点可动态添加或删除。</p><p>4、高可用性，部分节点不可用时，集群仍可用。通过增加 Slave 做备份数据副本</p><p>5、实现故障自动 failover，节点之间通过 gossip 协议交换状态信息，用投票机制完成 Slave到 Master 的角色提升。</p><p>缺点：</p><p>1、资源隔离性较差，容易出现相互影响的情况。</p><p>2、数据通过异步复制,不保证数据的强一致性</p><h3 id="什么是缓存穿透？如何避免？什么是缓存雪崩？何如避免？"><a href="#什么是缓存穿透？如何避免？什么是缓存雪崩？何如避免？" class="headerlink" title="什么是缓存穿透？如何避免？什么是缓存雪崩？何如避免？"></a>什么是缓存穿透？如何避免？什么是缓存雪崩？何如避免？</h3><p><strong>缓存穿透</strong></p><p>一般的缓存系统，都是按照key去缓存查询，如果不存在对应的value，就应该去后端系统查找（比如DB）。一些恶意的请求会故意查询不存在的key,请求量很大，就会对后端系统造成很大的压力。这就叫做缓存穿透。</p><p><strong>如何避免？</strong></p><p>1：对查询结果为空的情况也进行缓存，缓存时间设置短一点，或者该key对应的数据insert了之后清理缓存。</p><p>2：对一定不存在的key进行过滤。可以把所有的可能存在的key放到一个大的Bitmap中，查询时通过该bitmap过滤。</p><p><strong>缓存雪崩</strong></p><p>当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，会给后端系统带来很大压力。导致系统崩溃。</p><p><strong>如何避免？</strong></p><p>1：在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。</p><p>2：做二级缓存，A1为原始缓存，A2为拷贝缓存，A1失效时，可以访问A2，A1缓存失效时间设置为短期，A2设置为长期</p><p>3：不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。</p><h3 id="事务管理（ACID）概述"><a href="#事务管理（ACID）概述" class="headerlink" title="事务管理（ACID）概述"></a>事务管理（ACID）概述</h3><p><strong>原子性（Atomicity）</strong><br>原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。</p><p><strong>一致性（Consistency）</strong><br>事务前后数据的完整性必须保持一致。</p><p><strong>隔离性（Isolation）</strong><br>多个事务并发执行时，一个事务的执行不应影响其他事务的执行</p><p><strong>持久性（Durability）</strong><br>持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响</p><p><strong>Redis的事务总是具有ACID中的一致性和隔离性</strong>，其他特性是不支持的。当服务器运行在<em>AOF</em>持久化模式下，并且appendfsync选项的值为always时，事务也具有耐久性。</p><h3 id="Redis事务支持隔离性吗"><a href="#Redis事务支持隔离性吗" class="headerlink" title="Redis事务支持隔离性吗"></a>Redis事务支持隔离性吗</h3><p>Redis 是单进程程序，并且它保证在执行事务时，不会对事务进行中断，事务可以运行直到执行完所有事务队列中的命令为止。因此，<strong>Redis 的事务是总是带有隔离性的</strong>。</p><h3 id="Redis事务保证原子性吗，支持回滚吗"><a href="#Redis事务保证原子性吗，支持回滚吗" class="headerlink" title="Redis事务保证原子性吗，支持回滚吗"></a>Redis事务保证原子性吗，支持回滚吗</h3><p>Redis中，单条命令是原子性执行的，但<strong>事务不保证原子性，且没有回滚</strong>。事务中任意命令执行失败，其余的命令仍会被执行。</p><h3 id="Redis事务其他实现"><a href="#Redis事务其他实现" class="headerlink" title="Redis事务其他实现"></a>Redis事务其他实现</h3><p>基于Lua脚本，Redis可以保证脚本内的命令一次性、按顺序地执行，<br>其同时也不提供事务运行错误的回滚，执行过程中如果部分命令运行错误，剩下的命令还是会继续运行完</p><p>基于中间标记变量，通过另外的标记变量来标识事务是否执行完成，读取数据时先读取该标记变量判断是否事务执行完成。但这样会需要额外写代码实现，比较繁琐</p><h2 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h2><h3 id="Tomcat有几种部署方式？"><a href="#Tomcat有几种部署方式？" class="headerlink" title="Tomcat有几种部署方式？"></a>Tomcat有几种部署方式？</h3><p><strong>第一种方法</strong>：在tomcat中的<code>conf</code>目录中，在<code>server.xml</code>中的，<code>host</code>节点中添加： <code>Context</code> </p><p><strong>第二种方法</strong>：将web项目文件件拷贝到webapps 目录中。</p><p><strong>第三种方法</strong>：在conf目录中，新建 Catalina（注意大小写）＼localhost目录，在该目录中新建一个xml文件，名字可以随意取，只要和当前文件中的文件名不重复就行了</p><p><strong>第四种方法</strong>:  可以用tomcat在线后台管理器,一般tomcat都打开了,直接上传war就可以。</p><p>第三种方法有个优点，可以定义别名。服务器端运行的项目名称为path，外部访问的URL则使用XML的文件名。这个方法很方便的隐藏了项目的名称，对一些项目名称被固定不能更换，但外部访问时又想换个路径，非常有效。</p><p>第二、三种还有个优点，可以定义一些个性配置，如数据源的配置等。</p><h3 id="请解释servlet如何完成生命周期"><a href="#请解释servlet如何完成生命周期" class="headerlink" title="请解释servlet如何完成生命周期?"></a>请解释servlet如何完成生命周期?</h3><p>第一次访问Servlet，init()和service()都被调用了</p><p>第二次访问Servlet，service()被调用了</p><p>第三次访问Servlet，还是service()被调用了</p><p>我们关闭Tomcat服务器的时候，destroy()被调用了！</p><p>Servlet生命周期可分为5个步骤：</p><ul><li><strong>加载Servlet</strong>：当Tomcat第一次访问Servlet的时候，Tomcat会负责创建Servlet的实例；</li><li><strong>初始化</strong>：当Servlet被实例化后，Tomcat会调用init()方法初始化这个对象；</li><li><strong>处理服务</strong>：当浏览器访问Servlet的时候，Servlet 会调用service()方法处理请求；</li><li><strong>销毁</strong>：当Tomcat关闭时或者检测到Servlet要从Tomcat删除的时候会自动调用destroy()方法，让该实例释放掉所占的资源。一个Servlet如果长时间不被使用的话，也会被Tomcat自动销毁；</li><li><strong>卸载</strong>：当Servlet调用完destroy()方法后，等待垃圾回收。如果有需要再次使用这个Servlet，会重新调用init()方法进行初始化操作。</li></ul><p>简单总结：只要访问Servlet，service()就会被调用。init()只有第一次访问Servlet的时候才会被调用。destroy()只有在Tomcat关闭的时候才会被调用。</p><h3 id="tomcat有哪几种Connector运行模式？"><a href="#tomcat有哪几种Connector运行模式？" class="headerlink" title="tomcat有哪几种Connector运行模式？"></a>tomcat有哪几种Connector运行模式？</h3><p>Tomcat Connector有三种运行模式（<code>BIO</code>, <code>NIO</code>, <code>APR</code>）</p><p>三种模式的不同之处如下：</p><p>BIO：传统的Java I/O操作，同步且阻塞IO。一个线程处理一个请求。缺点：并发量高时，线程数较多，浪费资源。Tomcat7或以下，在Linux系统中默认使用这种方式。</p><p>NIO：JDK1.4开始支持，同步阻塞或同步非阻塞IO。利用Java的异步IO处理，可以通过少量的线程处理大量的请求。Tomcat8在Linux系统中默认使用这种方式。Tomcat7必须修改Connector配置来启动。</p><p>APR：JDK7开始支持，异步非阻塞IO。即Apache Portable Runtime，从操作系统层面解决io阻塞问题。Tomcat7或Tomcat8在Win7或以上的系统中启动默认使用这种方式。Linux如果安装了apr和native，Tomcat直接启动就支持apr。</p><h3 id="你平时怎么给tomcat调优"><a href="#你平时怎么给tomcat调优" class="headerlink" title="你平时怎么给tomcat调优?"></a>你平时怎么给tomcat调优?</h3><p>第一步 – 提高JVM栈内存</p><p>第二步 – 解决JRE内存泄露</p><p>第三步 – 线程池设置</p><p>第四步 - 压缩</p><p>第六步 – Tomcat原生库</p><p>第七步 – 其他选项</p><p><a href="https://blog.csdn.net/qq_35393693/article/details/86647661" target="_blank" rel="noopener">https://blog.csdn.net/qq_35393693/article/details/86647661</a></p><h2 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a>网络通信</h2><h3 id="http是无状态通信，http的请求方式有哪些，可以自己定义新的请求方式么"><a href="#http是无状态通信，http的请求方式有哪些，可以自己定义新的请求方式么" class="headerlink" title="http是无状态通信，http的请求方式有哪些，可以自己定义新的请求方式么"></a>http是无状态通信，http的请求方式有哪些，可以自己定义新的请求方式么</h3><p><strong>无状态的理解</strong></p><p>http的无状态是指请求与请求之间不保存状态，即服务器端不会主动记住上一次请<br>求是谁发的，和这次请求有没有连系。</p><p><strong>HTTP请求方式</strong></p><p>不能自定义新的请求方式，http 1.1已规定的请求方式有：</p><p><strong>OPTIONS</strong></p><p>返回服务器针对特定资源所支持的HTTP请求方法，也可以利用向web服务器发送‘*’的请求来测试服务器的功能性</p><p>OPTIONS方法用于获取当前URL所支持的方法。若请求成功，则它会在HTTP头中包含一个名为“Allow”的头，值是所支持的方法，如“GET, POST”。</p><p><strong>HEAD</strong></p><p>向服务器索与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以再不必传输整个响应内容的情况下，就可以获取包含在响应小消息头中的元信息。</p><p>HEAD方法与GET方法的行为很类似，但服务器在响应中只返回实体的主体部分。这就允许客户端在未获取实际资源的情况下，对资源的首部进行检查，</p><p>使用HEAD，我们可以更高效的完成以下工作： </p><ul><li>在不获取资源的情况下，了解资源的一些信息，比如资源类型； </li><li>通过查看响应中的状态码，可以确定资源是否存在； </li><li>通过查看首部，测试资源是否被修改。</li></ul><p><strong>GET</strong></p><p>向特定的资源发出请求。它本质就是发送一个请求来取得服务器上的某一资源。资源通过一组HTTP头和呈现数据（如HTML文本，或者图片或者视频等）返回给客户端。GET请求中，永远不会包含呈现数据。</p><p>Get是最常用的方法，通常用于请求服务器发送某个资源，而且应该是安全的和幂等的。</p><p><strong>POST</strong></p><p>向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。</p><p>Loadrunner中对应POST请求函数：web_submit_data,web_submit_form</p><p>POST方法向服务器提交数据，比如完成表单数据的提交，将数据提交给服务器处理。</p><p><strong>PUT</strong><br>向指定资源位置上传其最新内容</p><p>PUT方法是让服务器用请求的主体部分来创建一个由所请求的URL命名的新文档；如果那个文档存在的话，就用这个主体来代替它。</p><p><strong>DELETE</strong><br>请求服务器删除Request-URL所标识的资源</p><p>DELETE方法就是请求服务器删除指定URL所对应的资源。但是，客户端无法保证删除操作一定会被执行，因为HTTP规范允许服务器在不通知客户端的情况下撤销请求。</p><p><strong>TRACE</strong></p><p>回显服务器收到的请求，主要用于测试或诊断</p><p>TRACE方法会在目的服务器端发起一个“回环”诊断，我们都知道，客户端在发起一个请求时，这个请求可能要穿过防火墙、代理、网关、或者其它的一些应用程序。这中间的每个节点都可能会修改原始的HTTP请求，TRACE方法允许客户端在最终将请求发送服务器时，它变成了什么样子。由于有一个“回环”诊断，在请求最终到达服务器时，服务器会弹回一条TRACE响应，并在响应主体中携带它收到的原始请求报文的最终模样。这样客户端就可以查看HTTP请求报文在发送的途中，是否被修改过了。</p><p><strong>CONNECT</strong></p><p>HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。</p><h3 id="socket通信模型的使用，AIO和NIO"><a href="#socket通信模型的使用，AIO和NIO" class="headerlink" title="socket通信模型的使用，AIO和NIO"></a>socket通信模型的使用，AIO和NIO</h3><p><strong>BIO（同步阻塞IO）</strong></p><p>使用ServerSocket绑定IP地址和监听端口，客户端发起连接，通过三次握手建立连接，用socket来进行通信，通过输入输出流的方式来进行同步阻塞的通信每次客户端发起连接请求，都会启动一个线程。<br>线程数量：客户端并发访问数为1：1，由于线程是Java虚拟机中非常宝贵的资源，一旦线程数急剧增加，系统性能会急剧下降，导致线程栈溢出，创建新的线程失败，并最终导致宕机</p><p><strong>NIO（同步非阻塞IO）</strong></p><p>用NIO方式处理IO使用多路复用器Selector来轮询每个通道Channel，当通道中有事件时就通知处理，不过使用起来相当复杂。</p><p><strong>AIO（真正的异步非阻塞IO）</strong></p><p>NIO2.0引入了新的异步通道的概念，不需要使用多路复用器（Selector）对注册通道进行轮询即可实现异步读写，从而简化了NIO编程模型。</p><p>相关文章:</p><p><a href="https://blog.csdn.net/u014401141/article/details/54406195" target="_blank" rel="noopener">Socket,NIO,AIO基本概念(一)</a></p><p><a href="https://blog.csdn.net/anxpp/article/details/51512200" target="_blank" rel="noopener">Java 网络IO编程总结（BIO、NIO、AIO均含完整实例代码）</a></p><h3 id="NIO的实现原理，为什么是异步非阻塞"><a href="#NIO的实现原理，为什么是异步非阻塞" class="headerlink" title="NIO的实现原理，为什么是异步非阻塞"></a>NIO的实现原理，为什么是异步非阻塞</h3><p><strong>NIO</strong></p><p>答：看了一些文章，传统的IO流是阻塞式的，会一直监听一个ServerSocket，在调用read等方法时，他会一直等到数据到来或者缓冲区已满时才返回。调用accept也是一直阻塞到有客户端连接才会返回。每个客户端连接过来后，服务端都会启动一个线程去处理该客户端的请求。并且多线程处理多个连接。每个线程拥有自己的栈空间并且占用一些 CPU 时间。每个线程遇到外部未准备好的时候，都会阻塞掉。阻塞的结果就是会带来大量的进程上下文切换。<br>对于NIO，它是非阻塞式，核心类： </p><ul><li>Buffer为所有的原始类型提供 (Buffer)缓存支持。 </li><li>Charset字符集编码解码解决方案 </li><li>Channel一个新的原始 I/O抽象，用于读写Buffer类型，通道可以认为是一种连接，可以是到特定设备，程序或者是网络的连接。</li></ul><p>NIO就是非阻塞IO（直译）。</p><p>非阻塞的意思就是调用是实时返回的不会导致当前线程被挂起（阻塞），<br>比如对一个通道进行read操作nio下如果通道中没有可读数据会直接返回只不过返回值是0，<br>而BIO（阻塞IO）下则会等到通道中有数据才会返回；</p><p>但是IO中有个特例就是File IO，因为文件是确定的 而且文件句柄在操作系统中是不能同时被多个线程持有的（多个线程不能同时读写同一个文件，虽然java中有些API声称可以同时操作 只不过是底层实现每次操作都获取一次句柄释放一次句柄而已），<br>所以呢File IO你可以理解为都是非阻塞的，因为read时候文件里面有数据就读数据返回 没数据就是EOF。</p><h3 id="同步和异步，阻塞和非阻塞"><a href="#同步和异步，阻塞和非阻塞" class="headerlink" title="同步和异步，阻塞和非阻塞"></a>同步和异步，阻塞和非阻塞</h3><p><strong>同步</strong>：就是指一个进程在执行某个请求的时候，若该请求需要一段时间才能返回信息，那么这个进程将会一直等待下去，直到收到返回信息才继续执行下去；</p><p><strong>异步</strong>：是指进程不需要一直等下去，而是继续执行下面的操作，不管其他进程的状态。当有消息返回时系统会通知进程进行处理，这样可以提高执行的效率。 </p><p><strong>阻塞调用</strong>：是指调用结果返回之前，当前线程会被挂起。一直处于等待消息通知，不能够执行其他业务，调用线程只有在得到结果之后才会返回。</p><p><strong>非阻塞调用</strong>：指在不能立刻得到结果之前，该调用不会阻塞当前线程，而会立刻返回。</p><p><strong>示例讲解:你打电话问书店老板有没有《ECMAScript 6入门》这本书时</strong></p><p><strong>同步通信机制</strong>: 书店老板会说，你稍等，别挂电话，”我查一下”，然后开始查啊查，等查好了（可能是1分钟，也可能是一天）告诉你结果（返回结果）。在书店老板查找这个过程，你一直在等待他的回复，这期间你不能去干别的事情。<br><strong>异步通信机制</strong>: 书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。然后查好了，他会主动打电话给你。在这里老板通过“回电”这种方式来回调。在书店老板查找这个过程，这期间你可以先去干别的事情。</p><p><strong>同步阻塞</strong>：你打电话告诉老板你要买《ECMAScript 6入门》这本书，老板拿起电话听你说完就去查书，没有说话，你什么也不知道，在得到任何结果之前，你一直拿着电话干等，你此时什么也干不了。30分钟后老板直接把书送到你家，这时你才挂断电话。每次电话你都要得到结果（书到家）后你才挂断电话，这是同步。你一直拿着电话等结果，这是阻塞。</p><p><strong>同步非阻塞</strong>：你打电话告诉老板你要买《ECMAScript 6入门》这本书，老板拿起电话后说“我不知道有没有货，现在去查”便挂了电话，又过了10分种你第二次打电话说你要买《ECMAScript 6入门》这本书，老板拿起电话说完“还没有查到，你再等会儿”便挂断电话。挂断电话5分钟后老板查到有书，但并没有主动打电话告诉你。</p><p>你再次等待10分钟后第三次电话老板问结果，老板说“书有了，我给你送到家”，你断挂电话。每次电话你都要得得到结果（去查-&gt;还没有查到-&gt;有货）后你才挂断电话，这是同步。你每隔10分钟打电话询问结果，这是非阻塞。</p><p><strong>异步阻塞</strong>：你打电话过去问老板有没有《ECMAScript 6入门》这本书，老板说“我不知道有没有货，现在去查，先挂了电话，有结果告诉你，你等我电话”就挂掉电话。</p><p>等电话期间你什么也不干，老板主动给你发短信通知你结果书有了，5分钟后希望老板现在把书送来，你再次打电话让老板送书，老板马上送书上门。老板主动给你发短信，这是异步。等待老板的短信期间你什么也没干，这是阻塞。</p><p><strong>异步非阻塞</strong>：你打电话过去后问老板有没有《ECMAScript 6入门》这本书，老板说“好的，有货我直接给你送上门”就挂掉电话。然后你想干嘛干嘛，等老板门到后你看书。等待老板主动给你送书上门，这是异步。挂了电话后你就想干嘛干嘛，这是非阻塞。所以一般异步是配合非阻塞使用的，这样才能发挥异步的效用。</p><h3 id="http中，get-post的区别"><a href="#http中，get-post的区别" class="headerlink" title="http中，get post的区别"></a>http中，get post的区别</h3><p>GET一般用于获取/查询资源信息，Get是最常用的方法，通常用于请求服务器发送某个资源，而且应该是安全的和幂等的。</p><p>而POST一般用于更新资源信息。POST方法向服务器提交数据，比如完成表单数据的提交，将数据提交给服务器处理。</p><p>GET和POST的区别：</p><p>GET请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），以？分割URL和传输数据，参数之间以&amp;相连，如：login.action?name=hyddd&amp;password=idontknow&amp;verify=%E4%BD%A0%E5%A5%BD。</p><p>如果数据是英文字母或数字，则原样发送；如果是空格，转换为+；如果是中文或其他字符，则直接把字符串用BASE64加密，得出如：%E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII码值。而与之对应的，POST把提交的数据放置在HTTP包的包体中。</p><p>POST的安全性要比GET的安全性高。</p><p>注意：这里所说的安全性和上面GET提到的“安全”不是同个概念。</p><p>上面“安全”的含义仅仅是不作数据修改，而这里安全的含义是真正的Security的含义。</p><p>比如：通过GET提交数据，用户名和密码将明文出现在URL上，</p><p>因为：</p><p>(1)登录页面有可能被浏览器缓存，</p><p>(2)其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了，除此之外，使用GET提交数据还可能会造成Cross-site request forgery攻击（CSRF,跨站请求伪造，也被称为：one click attack/session riding）。</p><p>相关文章:<a href="https://www.cnblogs.com/williamjie/p/9099940.html" target="_blank" rel="noopener">浅谈HTTP中GET、POST用法以及它们的区别</a></p><h3 id="http-tcp-udp之间关系和区别"><a href="#http-tcp-udp之间关系和区别" class="headerlink" title="http,tcp,udp之间关系和区别"></a>http,tcp,udp之间关系和区别</h3><p>*<em>TCP协议 *</em></p><p>TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC 793定义。在简化的计算机网络OSI模型中，它完成第四层传输层所指定的功能，用户数据报协议（UDP）是同一层内另一个重要的传输协议。</p><p>*<em>TCP的优点 *</em></p><p>可靠，稳定<br>TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源。</p><p>*<em>TCP的缺点 *</em></p><p>慢，效率低，占用系统资源高，易被攻击<br>TCP在传递数据之前，要先建连接，这会消耗时间，而且在数据传递时，确认机制、重传机制、拥塞控制机制等都会消耗大量的时间，而且要在每台设备上维护所有的传输连接，事实上，每个连接都会占用系统的CPU、内存等硬件资源。 </p><p>由于TCP存在确认机制和三次握手机制，这些是导致TCP容易被人利用，实现DOS、DDOS、CC等攻击。</p><p>*<em>TCP应用场景 *</em></p><p>当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议。 </p><p>在日常生活中，常见使用TCP协议的应用比如：浏览器使用HTTP，Outlook使用POP、SMTP，QQ文件传输等。</p><p>*<em>UDP协议 *</em></p><p>UDP 是User Datagram Protocol的简称， 中文名是用户数据报协议，是OSI（Open System Interconnection，开放式系统互联） 参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务，IETF RFC 768是UDP的正式规范。UDP在IP报文的协议号是17。</p><p>*<em>UDP的优点 *</em></p><p>快，比TCP稍安全<br>UDP没有TCP的握手、确认、窗口、重传、拥塞控制等机制，UDP是一个无状态的传输协议，所以它在传递数据时非常快。没有TCP的这些机制，UDP较TCP被攻击者利用的漏洞就要少一些。但UDP也是无法避免攻击的，比如：UDP Flood攻击……</p><p>*<em>UDP的缺点 *</em></p><p>不可靠，不稳定<br>因为UDP没有TCP那些可靠的机制，在数据传递时，如果网络质量不好，就会很容易丢包。</p><p><strong>UDP应用场景</strong> </p><p>当对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用UDP。在日常生活中，常见使用UDP协议的应用比如：QQ语音、QQ视频、TFTP等。</p><p>相关文章:<a href="https://blog.csdn.net/hai_chao/article/details/79626161" target="_blank" rel="noopener">说说TCP,UDP和socket,Http之间联系和区别</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 问答 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ssm项目搭建及后续开发记录</title>
      <link href="/2020/01/01/ssm/"/>
      <url>/2020/01/01/ssm/</url>
      
        <content type="html"><![CDATA[<p>本文章记录web版博客搭建及开发记录系列整合</p><p>项目框架: spring boot + spring + mybatis的maven项目<br>数据库: mysql<br>缓存: redis<br>权限: shrio<br>搜索: solr （考虑）<br>开发环境: Windows + idea + VMware + docker</p><p>VMware：可用可不用，docker也有windows版本。主要是为了练习linux操作。</p><p><strong>如果上述所有软件都已安装直接略过[安装软件]步骤</strong></p><a id="more"></a><h2 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a><strong>安装软件</strong></h2><p>安装所需要的软件(软件链接都已放在百度云中), 如链接失效发送邮箱[<a href="mailto:kylin_lawliet@163.com">kylin_lawliet@163.com</a>]提醒修改<br>(idea安装就不需要我多说了)</p><h3 id="win10安装VMware（可不安装，直接安装Windows版本docker）"><a href="#win10安装VMware（可不安装，直接安装Windows版本docker）" class="headerlink" title="win10安装VMware（可不安装，直接安装Windows版本docker）"></a>win10安装VMware（可不安装，直接安装Windows版本docker）</h3><p><strong>因为当时安装没有想到截图，安装过程简单除了安装地址，其他基本选择默认的即可。</strong></p><blockquote><p>我是在win10下安装的，14版本无法运行程序，使用的是15版本。</p></blockquote><p><strong>下载 :</strong> <a href="https://pan.baidu.com/s/122g7mRA6D0OBgSdrGb-GjQ" target="_blank" rel="noopener">百度云链接</a> 提取码 : xg86<br><strong>使用 :</strong> <a href="https://docs.vmware.com/cn/VMware-Workstation-Player-for-Windows/15.0/com.vmware.player.win.using.doc/GUID-B8509247-258C-4B11-8637-5DABACEA4965.html" target="_blank" rel="noopener">VMware中文帮助文档</a><br>激活密钥:<br>FF31K-AHZD1-H8ETZ-8WWEZ-WUUVA<br>CV7T2-6WY5Q-48EWP-ZXY7X-QGUWD</p><p><a href="https://docs.vmware.com/cn/VMware-Workstation-Player-for-Windows/15.0/com.vmware.player.win.using.doc/GUID-B8509247-258C-4B11-8637-5DABACEA4965.html" target="_blank" rel="noopener">VMware 官网文档 中文</a></p><h3 id="win10下VMware安装Centos"><a href="#win10下VMware安装Centos" class="headerlink" title="win10下VMware安装Centos"></a>win10下VMware安装Centos</h3><blockquote><p>可查看这篇文章 : <a href="/2020/01/03/VMware-CentOS/" title="win10下VMware安装Centos">win10下VMware安装Centos</a></p></blockquote><h3 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h3><p>Linux docker安装MySQL，docker安装Redis都在该文章内</p><blockquote><p>可查看这篇文章 : <a href="/2020/01/03/docker/" title="Linux安装docker使用及一些问题记录">Linux安装docker使用及一些问题记录</a></p></blockquote><h2 id="项目搭建"><a href="#项目搭建" class="headerlink" title="项目搭建"></a><strong>项目搭建</strong></h2><h3 id="创建springboot项目"><a href="#创建springboot项目" class="headerlink" title="创建springboot项目"></a>创建springboot项目</h3><blockquote><p>可查看这篇文章 : <a href="/2020/01/07/SpringBoot-Create/" title="创建SpringBoot项目">创建SpringBoot项目</a></p></blockquote><h2 id="功能开发"><a href="#功能开发" class="headerlink" title="功能开发"></a><strong>功能开发</strong></h2><h3 id="添加mybatis-plus-mysql-代码生成器"><a href="#添加mybatis-plus-mysql-代码生成器" class="headerlink" title="添加mybatis plus mysql 代码生成器"></a>添加mybatis plus mysql 代码生成器</h3><blockquote><p>可查看这篇文章 : <a href="/2020/01/07/mybatis-plus-generator/" title="mybatis plus mysql 代码生成器">mybatis plus mysql 代码生成器</a></p></blockquote><h3 id="springboot-集成mybatis-plus"><a href="#springboot-集成mybatis-plus" class="headerlink" title="springboot 集成mybatis-plus"></a>springboot 集成mybatis-plus</h3><blockquote><p>可查看这篇文章 : <a href="/2020/01/18/springboot-mybatis-plus/" title="springboot 2.2 集成mybatis-plus">springboot 2.2 集成mybatis-plus</a></p></blockquote><h3 id="添加shiro权限"><a href="#添加shiro权限" class="headerlink" title="添加shiro权限"></a>添加shiro权限</h3><p>看很多博客项目也有采用shiro权限管理，也主要是想学习一下shiro。</p><blockquote><p>可查看这篇文章 : <a href="/2020/02/01/springboot-shiro/" title="Springboot 集成 Shiro">Springboot 集成 Shiro</a></p></blockquote><h3 id="添加系统参数配置维护"><a href="#添加系统参数配置维护" class="headerlink" title="添加系统参数配置维护"></a>添加系统参数配置维护</h3><p>用来管理一些全局变量，和设置一些系统参数<br>已完成 后期补充 整理分类大纲</p><h3 id="文章功能"><a href="#文章功能" class="headerlink" title="文章功能"></a>文章功能</h3><p>功能上没什么好说的，就是编辑文章展示文章。主要功能在与如何编辑文章，用什么编辑了。<br>已完成 后期补充 整理分类大纲</p><h3 id="评论功能"><a href="#评论功能" class="headerlink" title="评论功能"></a>评论功能</h3><p>考虑了下大概有几种方式，<br>1：一种是引用类型，每一条回复都显示一行，如果是回复的话就加载所引用回复的评论。（类似CSDN论坛）<br>2：评论层层嵌套，每个评论下面还挂着若干个对评论的回复。（类似CSDN博客）<br>3：最简单的每条评论单行显示。<br>已完成 后期补充 整理分类大纲</p><h3 id="消息提醒"><a href="#消息提醒" class="headerlink" title="消息提醒"></a>消息提醒</h3><p>有打算使用WebSocket（用过），ActivteMq（没用过）,RabbitMq（没用过）等。WebSocket以前项目中写过，确定不错，Mq的话可以称这个学习。<br>但是有考虑到这个项目其实并不需要那么复杂的功能，因为本身用到的也只有在后台登陆时显示提醒条数，其他也没有用到，并不一定非要即时提醒。<br>所以最终没用用到上面的技术，但是上面的技术也很想学，就考虑以后新的项目中用。</p><h3 id="待补充"><a href="#待补充" class="headerlink" title="待补充"></a>待补充</h3><p>..</p><h3 id="SpringBoot相关文章"><a href="#SpringBoot相关文章" class="headerlink" title="SpringBoot相关文章"></a>SpringBoot相关文章</h3><p><a href="https://blog.csdn.net/qq_34021712/category_7123099.html" target="_blank" rel="noopener">SpringBoot 学习博客</a><br><a href="https://www.cnblogs.com/ldy-blogs/p/8550406.html" target="_blank" rel="noopener">SpringBoot 注解大全</a><br><a href="https://blog.csdn.net/qq_15071263/article/details/79779920" target="_blank" rel="noopener">Springboot Freemarker配置全局变量</a><br><a href="https://www.cnblogs.com/fangpengchengbupter/p/7826565.html" target="_blank" rel="noopener">SpringBoot @RequestParam写与不写的区别</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> ssm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring boot </tag>
            
            <tag> spring </tag>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>freemaker学习笔记</title>
      <link href="/2019/12/28/freemaker/"/>
      <url>/2019/12/28/freemaker/</url>
      
        <content type="html"><![CDATA[<p>待编写</p><a id="more"></a><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="获取request中值"><a href="#获取request中值" class="headerlink" title="获取request中值"></a>获取request中值</h3><pre><code class="java">&lt;#assign basePath=request.contextPath /&gt;</code></pre><h2 id="获取后台数据"><a href="#获取后台数据" class="headerlink" title="获取后台数据"></a>获取后台数据</h2><h3 id="js获取后台list对象数组数据"><a href="#js获取后台list对象数组数据" class="headerlink" title="js获取后台list对象数组数据"></a>js获取后台list对象数组数据</h3><pre><code class="js">&lt;script&gt;var parentsListSize = &#39;${parents?size}&#39;;if(parentsListSize!=0)        {    &lt;#list parents as parent &gt;    alert(&#39;${parent.title}&#39;);    &lt;/#list&gt;}&lt;/script&gt;</code></pre><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="Failed-at-include"><a href="#Failed-at-include" class="headerlink" title="Failed at: #include"></a>Failed at: #include</h3><p><code>&lt;#include&gt;</code>标签的路径参数将被作为绝对路径处理。</p><pre><code class="html">&lt;#include &quot;../sidebar.ftl&quot;/&gt; // 错误写法&lt;#include &quot;${basePath}/sidebar.ftl&quot;/&gt;// 正确写法</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Idea笔记</title>
      <link href="/2019/12/25/idea/"/>
      <url>/2019/12/25/idea/</url>
      
        <content type="html"><![CDATA[<p>一些问题记录</p><a id="more"></a><h2 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h2><h2 id="问题整理"><a href="#问题整理" class="headerlink" title="问题整理"></a>问题整理</h2><h3 id="UTF-8编码下’-u7528-u6237"><a href="#UTF-8编码下’-u7528-u6237" class="headerlink" title="UTF-8编码下’\u7528\u6237"></a>UTF-8编码下’\u7528\u6237</h3><p><strong><em>问题</em></strong>：项目的编码已被设置为UTF-8，还是出现‘\u7528\u6237\u6B63\u5904\u4E8E\u767B\u9646\u72B6\u6001’。<br><strong><em>解决</em></strong>：<br><img src="/img/idea/1.png" alt=""></p><h3 id="Data标签getset不起作用"><a href="#Data标签getset不起作用" class="headerlink" title="@Data标签getset不起作用"></a>@Data标签getset不起作用</h3><blockquote><p>原因是idea中没有添加Lombok插件，添加上插件便可以解决。仅提供外网方式。</p></blockquote><ul><li>Ctrl+Alt+S 进入设置</li><li>左上角 搜索栏搜索Plugins </li><li>插件管理页面最上面三个页签选择Marketplace</li><li>在插件管理页面搜索lombok 一般第一个结果就是 点击Install</li><li>重启Idea。问题解决了。<br>注意：idea默认新建的工程不支持注解，我们需要手动设置支持注解。去设置中Build，Execution，Deployment&gt;Compiler&gt;Annotation Processors页面，勾选Enable annotation processing </li></ul><h2 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h2><h3 id="idea-Git版本回退"><a href="#idea-Git版本回退" class="headerlink" title="idea Git版本回退"></a>idea Git版本回退</h3><ul><li>项目右键 查看历史版本“Show History”<br><img src="/img/git/hg/0.png" alt=""><br><img src="/img/git/hg/1.png" alt=""></li><li>选择想回滚的版本右键 “Copy Revision Number”复制版本的版本号：<br><img src="/img/git/hg/2.png" alt=""></li><li>项目右键<br><img src="/img/git/hg/3.png" alt=""></li><li>Reset Type项选择Hard，To Commit项填写刚刚复制的版本号；然后点击Reset按钮<ul><li><code>Reset Type</code> 有三种：</li><li>mixed 默认方式，只保留源码，回退commit和index信息</li><li>soft 回退到某个版本，只回退了commit的信息，不会恢复到index file一级。如果还要提交，直接commit</li><li>hard 彻底回退，本地源码也会变成上一个版本内容</li><li>选择Hard彻底回退，点击Reset就能将本地代码版本回滚到指定版本。<br><img src="/img/git/hg/4.png" alt=""></li></ul></li></ul><p>回滚的本地代码提交到远程仓库，此时有两种方式：</p><ul><li>第一种，直接强制提交，使用git命令提交 git push -f，但是这样会把回滚版本之后的提交记录全部删除，因此不建议这样做。</li><li>第二种，用前面我们回滚本地的方式，再次回滚到最新版本。<ul><li>首先，获取到远程分支最新版本的版本号</li><li>然后，Git-&gt;Repository-&gt;Reset HEAD 这次与之前有些不一样，Reset Type采用Mixed方式将源码保留，然后点击Reset。</li><li>最后，代码已经是旧版本的代码，并且版本还是最新版本，此时正常提交push后我们的本地和远程代码的回滚就完成了。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> Idea </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Idea </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>easyui记录使用过程中出现的问题</title>
      <link href="/2019/12/24/easyui/"/>
      <url>/2019/12/24/easyui/</url>
      
        <content type="html"><![CDATA[<p>刚刚学习easyui,记录使用过程中出现的问题</p><a id="more"></a><h2 id="input相关"><a href="#input相关" class="headerlink" title="input相关"></a>input相关</h2><h3 id="jq修改值"><a href="#jq修改值" class="headerlink" title="jq修改值"></a>jq修改值</h3><blockquote><p>使用过程中发现jq的<code>attr()</code>,<code>val()</code>,<code>prop()</code>动态修改值页面均为显示。解决方法:</p></blockquote><pre><code class="js">$(&#39;#test&#39;).textbox(&#39;setValue&#39;, &#39;设定的值&#39;);</code></pre><h2 id="easyui-radiobutton"><a href="#easyui-radiobutton" class="headerlink" title="easyui-radiobutton"></a>easyui-radiobutton</h2><h3 id="取值"><a href="#取值" class="headerlink" title="取值"></a>取值</h3><pre><code class="js">$(&quot;input[name=&#39;radioName&#39;][checked]&quot;).val(); </code></pre><h3 id="设置选中"><a href="#设置选中" class="headerlink" title="设置选中"></a>设置选中</h3><pre><code class="js">$(&quot;input[name=&#39;&quot; + name + &quot;&#39;][value=&#39;&quot; + val + &quot;&#39;]&quot;).attr(&quot;checked&quot;, &quot;checked&quot;);</code></pre><h3 id="记录问题"><a href="#记录问题" class="headerlink" title="记录问题"></a>记录问题</h3><p>记录个人未解决问题，easyUI版本是当前（2019年12月）最新版本</p><blockquote><p><input class="easyui-radiobutton" name="state" value="open" > juqery 无法设置选中 一下方法都试过 暂未解决</p></blockquote><ul><li>$(“input[name=’”+name+”‘][value=’”+val+”‘]”).iRadiobutton({checked: true});</li><li>$(“input[name=’” + name + “‘][value=’” + val + “‘]”).attr(“checked”, “checked”);</li><li>$(“input[name=’” + name + “‘][value=’” + val + “‘]”).prop(“checked”, “checked”);</li></ul><blockquote><p>下拉框选中</p></blockquote><pre><code class="js">&lt;select class=&quot;easyui-combobox&quot; name=&quot;model&quot; id=&quot;model&quot;&gt;    &lt;option value=&quot;1&quot;&gt;后台管理&lt;/option&gt;    &lt;option value=&quot;2&quot;&gt;导航菜单&lt;/option&gt;&lt;/select&gt;var selectId = [&#39;parentId&#39;,&#39;model&#39;];$(&quot;#editForm&quot;).each(function () {    // 这种写法下 页面显示选中 显示值是下拉框的text值    if($.inArray(key, selectId) &gt;= 0){// 下拉框赋值        $(&#39;#&#39;+name).combobox(&#39;setValue&#39;, val);    }    // 这种写法下 页面显示选中 显示值是下拉框的value值    var tagName =$(this)[0].tagName.toLowerCase(); // tagName是select    if(tagName==&quot;select&quot;){// 下拉框赋值        $(&#39;#&#39;+name).combobox(&#39;setValue&#39;, val);    }});</code></pre><ul><li></li></ul><h2 id="easyui-combobox"><a href="#easyui-combobox" class="headerlink" title="easyui-combobox"></a>easyui-combobox</h2><h3 id="jq修改值-1"><a href="#jq修改值-1" class="headerlink" title="jq修改值"></a>jq修改值</h3><pre><code class="js">$(&#39;#&#39;+name).combobox(&#39;setValue&#39;, &#39;设定的值&#39;);</code></pre><h3 id="下拉框加图标显示"><a href="#下拉框加图标显示" class="headerlink" title="下拉框加图标显示"></a>下拉框加图标显示</h3><pre><code class="js">&lt;input id=&quot;iconCls&quot;  name=&quot;iconCls&quot; class=&quot;easyui-combobox&quot; /&gt;var data=comboboxData(text);$(&#39;#iconCls&#39;).combobox( {    showItemIcon:true,// 显示图标    panelHeight: &#39;auto&#39;,//自适应    valueField: &#39;value&#39;,//绑定字段value    textField: &#39;text&#39;,//绑定字段text    onLoadSuccess:function(){        $(&quot;.combo&quot;).click(function(){            $(this).prev().combobox(&quot;showPanel&quot;);        });    },    data:data,    formatter: function (row) {        var opts = $(this).combobox(&#39;options&#39;);        return row[opts.textField]    }});</code></pre><h3 id="下拉框添加多选"><a href="#下拉框添加多选" class="headerlink" title="下拉框添加多选"></a>下拉框添加多选</h3><pre><code class="js">&lt;input id=&quot;ceckbox&quot; class=&quot;easyui-combobox&quot; /&gt;var data=comboboxData(text);$(&#39;#ceckbox&#39;).combobox( {    multiple: true,// 支持多选    panelHeight: &#39;auto&#39;,//自适应    valueField: &#39;value&#39;,//绑定字段value    textField: &#39;text&#39;,//绑定字段text    onLoadSuccess:function(){        $(&quot;.combo&quot;).click(function(){            $(this).prev().combobox(&quot;showPanel&quot;);        });    },    data:[data],    formatter: function (row) {        var opts = $(this).combobox(&#39;options&#39;);        return &#39;&lt;input type=&quot;checkbox&quot; class=&quot;combobox-checkbox&quot; style=&quot;margin:0 5px;vertical-align: -2px&quot; id=&quot;&#39; + row[opts.valueField] + &#39;&quot;&gt;&#39; + row[opts.textField]    },    onSelect: function (row) {// 选择树节点触发事件        var opts = $(this).combobox(&#39;options&#39;);        var el = opts.finder.getEl(this, row[opts.valueField]);        el.find(&#39;input.combobox-checkbox&#39;)._propAttr(&#39;checked&#39;, true);    },    onUnselect: function (row) {// 取消选择checkbox        var opts = $(this).combobox(&#39;options&#39;);        var el = opts.finder.getEl(this, row[opts.valueField]);        el.find(&#39;input.combobox-checkbox&#39;)._propAttr(&#39;checked&#39;, false);    }});</code></pre><h2 id="datagrid"><a href="#datagrid" class="headerlink" title="datagrid"></a>datagrid</h2><h3 id="列表特殊格式数据处理"><a href="#列表特殊格式数据处理" class="headerlink" title="列表特殊格式数据处理"></a>列表特殊格式数据处理</h3><pre><code class="js">在要处理的列后面加入{field:&#39;model&#39;,title:&#39;所属模块&#39;,width:80,align:&#39;center&#39;,sortable:true,    formatter: function(value,row,index){        if (value == 1){            return &#39;后台管理&#39;;        } else if(value ==2) {            return &#39;导航菜单&#39;;        }    }}</code></pre><p>formatter</p><h2 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h2><h3 id="Cannot-read-property-‘options’-of-undefined"><a href="#Cannot-read-property-‘options’-of-undefined" class="headerlink" title="Cannot read property ‘options’ of undefined"></a>Cannot read property ‘options’ of undefined</h3><blockquote><p>具体报错原由未查明。<br>在遍历时修改input值时,使用<code>$(this)</code>就是报上面的错误</p></blockquote><pre><code class="js">$(&quot;#editForm&quot;).find(&quot;input&quot;).each(function () {    var name = $(this).attr(&quot;name&quot;);    if (name != undefined &amp;&amp; name != &#39;iconCls&#39;) {        $.each(obj, function (key, val) {            if (name == key) {                $(&#39;#&#39;+name).textbox(&#39;setValue&#39;, val);// 解决方式                // $(this).textbox(&#39;setValue&#39;, value);// 报错行            }        });    }});</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> easyUI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> easyUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jquery各种函数使用示例</title>
      <link href="/2019/12/24/jquery/"/>
      <url>/2019/12/24/jquery/</url>
      
        <content type="html"><![CDATA[<p>jquery相关使用示例,有的来源于百度阅读整理,有的是笔记，笔记慢慢整理。<br><a href="https://www.jquery123.com/" target="_blank" rel="noopener">jQuery API 中文文档</a></p><a id="more"></a><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><h3 id="获节点的方法"><a href="#获节点的方法" class="headerlink" title="获节点的方法"></a>获节点的方法</h3><h4 id="获取父级节点"><a href="#获取父级节点" class="headerlink" title="获取父级节点"></a>获取父级节点</h4><blockquote><p><code>$(selector).parent(selector)</code>：获取父节点<br><code>$(selector).parentNode</code>：以node[]的形式存放父节点，如果没有父节点，则返回空数组<br><code>$(selector).parents(selector)</code>：获取祖先元素</p></blockquote><h4 id="获取兄弟节点"><a href="#获取兄弟节点" class="headerlink" title="获取兄弟节点"></a>获取兄弟节点</h4><blockquote><p><code>$(selector).prev()</code>/<code>$(selector).previousSibling()</code>：获取上一个兄弟节点<br><code>$(selector).prevAll()</code>：获取之前所用的兄弟节点<br><code>$(selector).next()</code>/<code>$(selector).nextSibling()</code>：获取下一个兄弟节点<br><code>$(selector).nextAll()</code>：获取之后所有的兄弟节点<br><code>$(selector).siblings()</code>：获取所有的兄弟节点</p></blockquote><h4 id="获取子节点"><a href="#获取子节点" class="headerlink" title="获取子节点"></a>获取子节点</h4><blockquote><p><code>$(selector).children()</code>：获取所有直接子节点<br><code>$(selector).childNodes</code>：以node[]的形式存放子节点，如果没有子节点，则返回空数组<br><code>$(selector).children(&quot;:first&quot;).firstChild</code>：获取第一个子节点<br><code>$(selector).children(&quot;:last&quot;).lastChild</code>：获取最后一个子节点<br><code>$(selector).contents</code>：获取包含的所有内容，包括空文本<br><code>$(selector).removeChild(selector)</code>：删除并返回指定的子节点<br><code>$(selector).replaceChild(selector)</code>：替换并返回指定的子节点</p></blockquote><h3 id="获取指定值或奇偶"><a href="#获取指定值或奇偶" class="headerlink" title="获取指定值或奇偶"></a>获取指定值或奇偶</h3><pre><code class="js">//选取每个class为one的父元素下的索引值为偶数的子元素 索引从1 开始$(&#39;div .one :nth-child(even)&#39;);//选取每个class为one的父元素下的索引值为奇数的子元素 索引从1 开始$(&#39;div .one :nth-child(odd)&#39;);//获取选中的复选框，索引为0$(&quot;input[name=&#39;checkname[]&#39;]:checked:eq(0)&quot;);$(&quot;input[name=&#39;checkname[]&#39;]&quot;).eq(0).is(&#39;:checked&#39;);</code></pre><h2 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h2><h3 id="在容器内增加和删除"><a href="#在容器内增加和删除" class="headerlink" title="在容器内增加和删除"></a>在容器内增加和删除</h3><h4 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h4><blockquote><p><code>append()</code> - 在被选元素的结尾插入内容<br><code>prepend()</code> - 在被选元素的开头插入内容<br><code>after()</code> - 在被选元素之后插入内容<br><code>before()</code> - 在被选元素之前插入内容</p></blockquote><h4 id="删除元素-内容"><a href="#删除元素-内容" class="headerlink" title="删除元素/内容"></a>删除元素/内容</h4><blockquote><p><code>remove()</code> - 删除被选元素（及其子元素）<br><code>empty()</code> - 从被选元素中删除子元素</p></blockquote><h4 id="复制元素"><a href="#复制元素" class="headerlink" title="复制元素"></a>复制元素</h4><blockquote><p><code>clone()</code> - 复制被选元素中元素</p></blockquote><h2 id="CheckBox"><a href="#CheckBox" class="headerlink" title="CheckBox"></a>CheckBox</h2><h3 id="选中值拼接"><a href="#选中值拼接" class="headerlink" title="选中值拼接"></a>选中值拼接</h3><pre><code class="js">// 方式一var ck = $(&quot;input[name=&#39;ck&#39;]:checked&quot;).map(function () {    return $(this).val();}).get().join(&#39;,&#39;);// 方式二var synTypes = new Array();$(&quot;input[name=synType]:checked&quot;).each(function(i,n){    synTypes.push(n.value);});</code></pre><h3 id="取指定选中值"><a href="#取指定选中值" class="headerlink" title="取指定选中值"></a>取指定选中值</h3><pre><code class="js">$(&quot;input[name=&#39;id&#39;]:checked:eq(0)&quot;).val();</code></pre><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="判断数组是否存在某个值"><a href="#判断数组是否存在某个值" class="headerlink" title="判断数组是否存在某个值"></a>判断数组是否存在某个值</h3><pre><code class="js">if($.inArray(&#39;判断值&#39;,arr) &gt;= 0){    alert(&#39;存在&#39;);}else{    alert(&#39;不存在&#39;);}</code></pre><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><h3 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h3><pre><code class="js">var arr = [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;];  var text = &quot;Array &quot;;  $.each(arr, function(i, val) {      text = text + &quot; #Index:&quot; + i + &quot;:&quot; + val;  });  console.log(text);  //Array #Index:0:one #Index:1:two #Index:2:three #Index:3:four #Index:4:five  </code></pre><h3 id="遍历对象属性"><a href="#遍历对象属性" class="headerlink" title="遍历对象属性"></a>遍历对象属性</h3><blockquote><p><code>For/In</code> 循环</p></blockquote><pre><code class="js">var person={fname:&quot;John&quot;,lname:&quot;Doe&quot;,age:25}; for (x in person) { txt = txt + person[x];}</code></pre><blockquote><p><code>$.each()</code> 遍历对象属性</p></blockquote><pre><code class="js">var obj = { one: 1, two: 2, three: 3, four: 4, five: 5 };  // 遍历对象text = &quot;Object &quot;;  $.each(obj, function(i, val) {      text = text + &quot;Key:&quot; + i + &quot;, Value:&quot; + val; });  console.log(text);  //Object Key:one, Value:1Key:two, Value:2Key:three, Value:3Key:four, Value:4Key:five, Value:5</code></pre><h3 id="遍历table"><a href="#遍历table" class="headerlink" title="遍历table"></a>遍历table</h3><pre><code class="js">$(&#39;#btntb&#39;).click(function(){    $(&#39;#tab tr&#39;).each(function(i){// 遍历 tr       $(this).children(&#39;td&#39;).each(function(j){// 遍历 tr 的各个 td          alert(&quot;第&quot;+(i+1)+&quot;行，第&quot;+(j+1)+&quot;个td的值：&quot;+$(this).text()+&quot;。&quot;);       });    });});</code></pre><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><h3 id="绑定事件方法及区别"><a href="#绑定事件方法及区别" class="headerlink" title="绑定事件方法及区别"></a>绑定事件方法及区别</h3><blockquote><p>click</p></blockquote><pre><code class="js">$(document).ready(function(){    $(&quot;#clickme&quot;).click(function(){        alert(&quot;hello world click&quot;);    });});</code></pre><blockquote><p>bind </p></blockquote><pre><code class="js">// 简写方式为第一种$(&#39;#clickmebind&#39;).bind(&quot;click&quot;, function(){    alert(&quot;Hello World bind&quot;);});</code></pre><blockquote><p>on </p></blockquote><pre><code class="js">$(&#39;#clickmeon&#39;).on(&quot;click&quot;,function(){    alert(&quot;hello world on&quot;)})//注意:只适用于jquery 1.7以上的版本</code></pre><blockquote><p>live </p></blockquote><pre><code class="js">$(&quot;button&quot;).live(&quot;click&quot;,function(){    $(&quot;p&quot;).slideToggle();});</code></pre><blockquote><p>delegate </p></blockquote><pre><code class="js">$(&quot;div&quot;).delegate(&quot;button&quot;,&quot;click&quot;,function(){    $(&quot;p&quot;).slideToggle();});</code></pre><blockquote><p>one </p></blockquote><pre><code class="js">$(document).ready(function(){    $(&quot;p&quot;).one(&quot;click&quot;,function(){        $(this).animate({fontSize:&quot;+=6px&quot;});    });});</code></pre><blockquote><p>方法区别<br><code>bind(type,[data],fn)</code> 为每个匹配元素的特定事件绑定事件处理函数</p></blockquote><pre><code class="js">$(&quot;a&quot;).bind(&quot;click&quot;,function(){alert(&quot;ok&quot;);});</code></pre><blockquote><p><code>live(type,[data],fn)</code> 给所有匹配的元素附加一个事件处理函数，即使这个元素是以后再添加进来的 </p></blockquote><pre><code class="js">$(&quot;a&quot;).live(&quot;click&quot;,function(){alert(&quot;ok&quot;);});</code></pre><blockquote><p><code>delegate(selector,[type],[data],fn)</code> 指定的元素（属于被选元素的子元素）添加一个或多个事件处理程序，并规定当这些事件发生时运行的函数 </p></blockquote><pre><code class="js">$(&quot;#container&quot;).delegate(&quot;a&quot;,&quot;click&quot;,function(){alert(&quot;ok&quot;);})</code></pre><blockquote><p><code>on(events,[selector],[data],fn)</code> 在选择元素上绑定一个或多个事件的事件处理函数</p></blockquote><pre><code class="js">$(&quot;div&quot;).on(&quot;click&quot;,&quot;p&quot;,function(){alert(&quot;ok&quot;);})</code></pre><blockquote><p>最大的差别<br><code>bind()</code>的事件函数只能针对已经存在的元素进行事件的设置。如果你想对动态创建的元素<code>bind()</code>事件，是没有办法达到效果的，但是<code>live()</code>,<code>on()</code>,<code>delegate()</code>均支持未来新添加元素的事件设置。</p><ul><li><code>.bind()</code>是直接绑定在元素上（） jquery1.7版本以前比较受推崇，1.7版本出来之后，官方已经不推荐用<code>bind()</code>，替代函数为<code>on()</code>,这也是1.7版本新添加的函数，同样，可以用来代替<code>live()</code>函数，<code>live()</code>函数在1.9版本已经删除；</li><li><code>.delegate()</code>则是更精确的小范围使用事件代理，性能优于<code>.live()</code>（在Jquery1.7中已经移除）</li><li><code>.live()</code>则是通过冒泡的方式来绑定到元素上的。更适合列表类型的，绑定到document DOM节点上。和<code>.bind()</code>的优势是支持动态数据。（在Jquery1.7中已经移除，相应<code>die()</code>也移除）<br><code>live()</code>函数和<code>delegate()</code>函数两者类似，但是<code>live()</code>函数在执行速度，灵活性和CSS选择器支持方面较<code>delegate()</code>差些</li><li><code>.on()</code>则是最新的1.9版本整合了之前的三种方式的新事件绑定机制（在Jquery1.7中添加，相应off()也添加）</li><li>jquery1.4 及之前的版本，由<code>.click()</code>或 <code>bind()</code>方法绑定的事件，不能适用脚本创建的新元素：即是说页面加载完成后，再动态创建的DOM元素并不能响应之前绑定的事件！<br>旧版本的处理方法是使用.live()方法来代替事件绑定<code>.bind()</code>，使得绑定的事件能适用脚本创建的新元素。<br>但自jq1.7版本开始，官方已明文表示不再推荐使用使用<code>.live()</code>方法，官方解释为：live()调用过程首先将事件方法绑定到了Document，然后，查找Document里是否有匹配元素。<br>这个过程对于性能来说可能比较浪费。官方推荐将<code>.live()</code>改成<code>delegate()</code>方法，适用脚本创建的新元素。<br>jq1.8开始，官方又再次申明：如果你开发最新版本的jQuery，完全可以使用<code>on()</code>方法来处理所有的事件绑定，避免过多的方法调用,因为其实在最新版本的jQuery类库中，所有以上旧版方法在后面其实都是调用<code>on()</code>方法。</li></ul></blockquote><blockquote><p>移除事件方法</p></blockquote><pre><code class="js">$( &quot;div p&quot; ).unbind( &quot;click&quot;, handler );$( &quot;div&quot; ).undelegate( &quot;p&quot;, &quot;click&quot;, handler );$( &quot;div&quot; ).off( &quot;click&quot;, &quot;p&quot;, handler );//简便写法：$(&quot;div p&quot;).unbind(&quot;click&quot;).bind(&quot;click&quot;,function () {});$(&quot;div p&quot;).undelegate(&quot;click&quot;).delegate(&quot;click&quot;,function () {});$(&quot;div p&quot;).off(&quot;click&quot;).on(&quot;click&quot;,function () {});</code></pre><blockquote><p>总结<br>1.选择器匹配到的元素比较多时，不要用bind()迭代绑定<br>2.用id选择器时，可以用bind()<br>3.需要给动态添加的元素绑定时，用delegate()或者on()<br>4.用delegate()和on()方法，dom树不要太深<br>5.jQuery推出<code>on()</code>的目的有2个，一是为了统一接口，二是为了提高性能，所以从现在开始用<code>on()</code>替换<code>bind()</code>, <code>live()</code>, <code>delegate</code>吧。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> jquery </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> jquery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript使用示例</title>
      <link href="/2019/12/24/javascript/"/>
      <url>/2019/12/24/javascript/</url>
      
        <content type="html"><![CDATA[<p>使用过的方法,函数 一些笔记<br>笔记慢慢整理</p><a id="more"></a><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><h3 id="遍历table"><a href="#遍历table" class="headerlink" title="遍历table"></a>遍历table</h3><pre><code class="js">var tb = document.getElementById(&#39;tab&#39;);// table 的 idvar rows = tb.rows;// 获取表格所有行for(var i = 0; i&lt;rows.length; i++ ){   for(var j = 0; j&lt;rows[i].cells.length; j++ ){ // 遍历该行的 td       alert(&quot;第&quot;+(i+1)+&quot;行，第&quot;+(j+1)+&quot;个td的值：&quot;+rows[i].cells[j].innerHTML+&quot;。&quot;);// 输出每个td的内容   }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo文章格式示例</title>
      <link href="/2019/12/23/hexo-dome/"/>
      <url>/2019/12/23/hexo-dome/</url>
      
        <content type="html"><![CDATA[<p>整理一些写文章时各种样式写法示例(针对不同主题各有差异)<br>文章的源文件地址在<a href="https://github.com/kylin-lawliet/SharedDocuments/" target="_blank" rel="noopener">在共享文件仓库</a>文件夹路径:/hexo/demo.md</p><a id="more"></a><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><h2 id="标题排版"><a href="#标题排版" class="headerlink" title="标题排版"></a>标题排版</h2><blockquote><p>每加<code>#</code>代表一级标题</p></blockquote><h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><p>无样式</p><blockquote><p>加背景</p></blockquote><blockquote><blockquote><p>双层背景</p></blockquote></blockquote><blockquote><ul><li>有背景列表标记<ul><li>有背景列表标记</li></ul></li></ul></blockquote><ul><li>无背景列表标记<ul><li>如果设置子列表中间不可以有空行</li></ul></li></ul><pre><code class="xml">function admin(e) {    // 代码块}</code></pre><h2 id="字体样式"><a href="#字体样式" class="headerlink" title="字体样式"></a>字体样式</h2><ul><li><strong>加粗字体</strong> </li><li><strong><em>斜体字体</em></strong></li><li><code>添加字体高亮一</code> </li><li><code>添加字体高亮二</code> </li><li><del>删除线</del></li></ul><h2 id="各种连接写法"><a href="#各种连接写法" class="headerlink" title="各种连接写法"></a>各种连接写法</h2><blockquote><p><a href="https://www.kylin-blackcat.com/" target="_blank" rel="noopener">https://www.kylin-blackcat.com/</a><br><a href="www.kylin-blackcat.com">地址</a><br><a href="https://www.kylin-blackcat.com/" target="_blank" rel="noopener">地址</a></p></blockquote><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><table><thead><tr><th align="center">-</th><th align="center">表头</th><th align="center">表头</th><th align="center">表头</th><th align="center">表头</th><th align="left">表头</th><th>表头</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">内容内容内容</td><td align="center">内容内容内容</td><td align="center">x</td><td align="center">√</td><td align="left">—</td><td>内容</td></tr><tr><td align="center">2</td><td align="center">内容</td><td align="center">内容</td><td align="center">内容</td><td align="center">内容</td><td align="left"></td><td>内容</td></tr></tbody></table><h2 id="引入图片"><a href="#引入图片" class="headerlink" title="引入图片"></a>引入图片</h2><blockquote><p><img src="/img/avatar.png" alt=""></p></blockquote><h2 id="站内文章跳转"><a href="#站内文章跳转" class="headerlink" title="站内文章跳转"></a>站内文章跳转</h2><blockquote><p>文章头部需添加<code>permalink: XXX</code>属性<br>示例 ：<a href="/2019/12/22/hexo/" title="hexo建站相关">hexo建站相关</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo建站相关</title>
      <link href="/2019/12/22/hexo/"/>
      <url>/2019/12/22/hexo/</url>
      
        <content type="html"><![CDATA[<p>本篇文章主要是整理记录使用Hexo建站过程笔记以及踩过的坑</p><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="Win安装node，npm"><a href="#Win安装node，npm" class="headerlink" title="Win安装node，npm"></a>Win安装node，npm</h3><ul><li><strong>下载node</strong>:<a href="https://nodejs.org/zh-cn/download/" target="_blank" rel="noopener">node下载地址</a> </li></ul><blockquote><p><img src="/img/hexo/hexo-node1.png" alt="下载"></p></blockquote><ul><li><strong>解压node</strong>:创建两个文件node-cache，node-global用来指定npm的模块路径和缓存路径</li></ul><blockquote><p><img src="/img/hexo/hexo-node2.png" alt="解压"></p></blockquote><ul><li><strong>配置node</strong>:在系统变量下新建一个NODE_HOME变量，把新建的NODE_HOME添加到PATH中</li></ul><pre><code class="lunix">NODE_HOMED:\Software\node-v12.14.0-win-x64\</code></pre><blockquote><p><img src="/img/hexo/hexo-node3.png" alt="配置"></p></blockquote><pre><code class="lunix">%NODE_HOME%%NODE_HOME%\node-global</code></pre><blockquote><p><img src="/img/hexo/hexo-node4.png" alt="配置"></p></blockquote><ul><li><strong>下载npm</strong>:打开cmd，进入node解压文件夹下，配置刚才新建的两个文件夹</li></ul><pre><code class="lunix">npm config set prefix &quot;D:\Software\node-v12.14.0-win-x64\node-global&quot;npm config set cache &quot;D:\Software\node-v12.14.0-win-x64\node-cache&quot;</code></pre><ul><li><strong>配置npm</strong>:设置淘宝为国内镜像源(相当于maven设置阿里是国内的远程镜像仓库)</li></ul><pre><code class="lunix">npm config set registry https://registry.npm.taobao.org</code></pre><ul><li>其他命令</li></ul><pre><code class="lunix">npm config get registry // 查看设置的国内镜像对不对node --version // 查看安装的node版本npm --version // 查看安装的npm版本</code></pre><h3 id="Win安装-hexo"><a href="#Win安装-hexo" class="headerlink" title="Win安装 hexo"></a>Win安装 hexo</h3><blockquote><p>创建一个文件夹，存放hexo文件</p></blockquote><pre><code class="lunix">cd 到创建的文件夹下npm install -g hexo-cli // 下载hexohexo init // 初始化这个文件夹hexo generate // 生成默认主题和默认文章-Helloworldhexo server //启动服务</code></pre><blockquote><p> <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 本地预览</p></blockquote><blockquote><p>文件夹目录</p><ul><li>node_modules: 依赖包</li><li>public：存放生成的页面</li><li>scaffolds：生成文章的一些模板</li><li>source：用来存放你的文章</li><li>themes：主题文件</li><li>** _config.yml: 博客的配置文件**</li></ul></blockquote><h3 id="修改主题"><a href="#修改主题" class="headerlink" title="修改主题"></a>修改主题</h3><blockquote><p>主题下载地址<a href="https://hexo.io/themes/" target="_blank" rel="noopener">hexo.io/themes</a>，<a href="https://github.com/hexojs/hexo/wiki/Themes" target="_blank" rel="noopener">wiki/Themes</a>，<a href="https://www.zhihu.com/question/24422335" target="_blank" rel="noopener">zhihu</a></p></blockquote><ul><li>打开git bath</li></ul><pre><code class="lunix">cd 到hexo安装文件夹根目录git clone https://github.com/MOxFIVE/hexo-theme-yelee.git themes/yelee </code></pre><blockquote><p>修改hexo根目录下的_config.yml 属性:<code>theme: yelee</code></p></blockquote><h3 id="更新主题"><a href="#更新主题" class="headerlink" title="更新主题"></a>更新主题</h3><ul><li>如果作者有改动主题</li></ul><pre><code class="lunix">cd hexo安装文件夹根目录/themes/yeleegit pull origin master </code></pre><h3 id="绑定个人域名"><a href="#绑定个人域名" class="headerlink" title="绑定个人域名"></a>绑定个人域名</h3><blockquote><ul><li>1.购买域名(具体运营商，购买步骤自行百度)</li><li>2.在域名控制台中&gt;&gt;看到购买的域名&gt;&gt;点<strong>解析</strong>进去</li><li>3.添加两条CNAME解析(百度其他教程有说配置ip，但是不建议)<br><img src="/img/hexo/hexo1.png" alt="解析"></li><li>4.登陆github选择gitpage仓库，选择settings，下滑找到Github Pages 在Custom domain里填入你的域名，然后点击Save或者在 hexo 项目下，source 文件夹下面创建 CNAME 文件（没有后缀名的），在里面写上你的域名。</li><li>5.访问成功</li></ul></blockquote><blockquote><p><strong>PS:</strong><br><strong>如果想要本地访问域名使用</strong><br>把记录类型改为:A，记录值改为:本地ip，但是与上方配置不能同时存在<br><strong>绑定域名分两种情况:带www和不带www</strong></p><ul><li>如果你填写的是没有www的，比如 <code>mygit.me</code>，那么无论是访问 <code>http://www.mygit.me</code> 还是 <code>http://mygit.me</code>，都会自动跳转到 <code>http://mygit.me</code></li><li>如果你填写的是带www的，比如 <code>www.mygit.me</code>，那么无论是访问 <code>http://www.mygit.me</code> 还是 <code>http://mygit.me</code>，都会自动跳转到 <code>http://www.mygit.me</code></li><li>如果你填写的是其它子域名，比如 <code>abc.mygit.me</code>，那么访问 <code>http://abc.mygit.me</code> 没问题，但是访问 <code>http://mygit.me</code>，不会自动跳转到 <code>http://abc.mygit.me</code><br>绑定了新域名之后 原来的<code>xxx.github.io</code>并没有失效，会自动跳转到你的新域名。</li></ul></blockquote><h3 id="备份Hexo博客源文件"><a href="#备份Hexo博客源文件" class="headerlink" title="备份Hexo博客源文件"></a>备份Hexo博客源文件</h3><h4 id="第一次备份"><a href="#第一次备份" class="headerlink" title="第一次备份"></a>第一次备份</h4><blockquote><p>在Github下创建一个新的仓库，取名为XXX(与本地的hexo源码文件夹同名)</p></blockquote><pre><code class="linux">cd 本地的hexo文件夹git init  加载仓库git remote add origin git@github.com:kylin-lawliet/blackcat.git 设置远程仓库地址git pull origin master 更新git add . 添加到本地仓库git commit -m &quot;备注&quot;  源码在本地的提交git push origin master 将本地的仓库文件推送到Github</code></pre><h4 id="更换开发环境"><a href="#更换开发环境" class="headerlink" title="更换开发环境"></a>更换开发环境</h4><blockquote><p>克隆过来的文件没有之前下载的themes主题文件，直接把之前的文件复制过来，或再去Git下载主题。 </p></blockquote><pre><code class="linux">git clone git@github.com:kylin-lawliet/blackcat.git 设置远程仓库地址cd  blackcat (克隆后会创建一个文件夹，进入文件夹内)修改文件后（或直接把之前环境文件复制过来）git add . 添加到本地仓库git commit -m &quot;备注&quot;  源码在本地的提交git push origin master 将本地的仓库文件推送到Github</code></pre><h4 id="更新同步"><a href="#更新同步" class="headerlink" title="更新同步"></a>更新同步</h4><pre><code class="linux">git add .git commit -m &quot;源文件更新&quot;git push origin master</code></pre><h4 id="远程仓库有更新"><a href="#远程仓库有更新" class="headerlink" title="远程仓库有更新"></a>远程仓库有更新</h4><pre><code class="linux">git pull origin master</code></pre><p>还有另一种方式的<a href="https://anson2416.github.io/posts/c4d910e6/" target="_blank" rel="noopener">shelljs模块</a>因为懒没有去尝试</p><h2 id="主题使用"><a href="#主题使用" class="headerlink" title="主题使用"></a>主题使用</h2><h3 id="按时间排序（默认即按日期排序）"><a href="#按时间排序（默认即按日期排序）" class="headerlink" title="按时间排序（默认即按日期排序）"></a>按时间排序（默认即按日期排序）</h3><pre><code class="linux">npm uninstall hexo-generator-index --savenpm install hexo-generator-index-pin-top --save</code></pre><h2 id="踩过的坑"><a href="#踩过的坑" class="headerlink" title="踩过的坑"></a>踩过的坑</h2><p>记录的问题都是本人建站时所遇到的，仅供参考</p><h3 id="无法访问此网站"><a href="#无法访问此网站" class="headerlink" title="无法访问此网站"></a>无法访问此网站</h3><blockquote><p>别人的电脑都能访问你的网址，但你自己却访问不了。出现此问题，可能会是dns缓存的问题！</p></blockquote><pre><code class="yml">ipconfig /flushdns</code></pre><h3 id="出现报错"><a href="#出现报错" class="headerlink" title="出现报错"></a>出现报错</h3><p><img src="/img/hexo/hexo2.png" alt="问题"></p><blockquote><ul><li>1.找不到路径(菜单连接配置路径不正确)</li><li>2.修改config.yml没有重新启动服务</li><li>3.页面(不是文章)中添加不正确属性 如:页面加入categories属性</li></ul></blockquote><h3 id="未找到相关的Issues进行评论"><a href="#未找到相关的Issues进行评论" class="headerlink" title="未找到相关的Issues进行评论"></a>未找到相关的Issues进行评论</h3><blockquote><ul><li>先建一个名gitalk-commnet(名称随意)的评论仓库</li><li>登陆<code>github</code> 进入<code>seting</code> 在左菜单找到<code>Developer setting</code> 进入选择<code>OAuth Apps</code> 新建</li></ul></blockquote><p><img src="/img/hexo/hexo-bug1.png" alt="问题"></p><p>没有域名就填写<code>https://xxx.github.io/</code><br>注册成功后可以看到<code>client_id</code>与<code>client_secret</code></p><blockquote><p>修改主题配置文件<code>_config.yml</code></p></blockquote><p><img src="/img/hexo/hexo-bug2.png" alt="问题"></p><h3 id="代码块样式不起作用"><a href="#代码块样式不起作用" class="headerlink" title="代码块样式不起作用"></a>代码块样式不起作用</h3><blockquote><p>将主题配置文件中<code>highlight</code>关闭然后运行 在修改回来修改样式之后执行命令</p></blockquote><pre><code class="linux">hexo clean &amp; hexo g &amp; hexo s</code></pre><h2 id="hexo命令"><a href="#hexo命令" class="headerlink" title="hexo命令"></a>hexo命令</h2><h3 id="创建命令"><a href="#创建命令" class="headerlink" title="创建命令"></a>创建命令</h3><blockquote><p>hexo new “postName” 新建文章<br>hexo new page “pageName” 新建页面<br>hexo new page tags 创建标签页面<br>hexo new page categories 创建分类页面<br>hexo new page about 创建关于我页面</p></blockquote><h3 id="常规命令"><a href="#常规命令" class="headerlink" title="常规命令"></a>常规命令</h3><blockquote><p>hexo generate 生成静态页面至public目录<br>hexo server 开启预览访问端口（默认端口4000，ctrl + c关闭server）<br>hexo deploy 部署到GitHub<br>hexo help 查看帮助<br>hexo version 查看Hexo的版本</p></blockquote><h3 id="简化命令"><a href="#简化命令" class="headerlink" title="简化命令"></a>简化命令</h3><blockquote><p>hexo g == hexo generate<br>hexo d == hexo deploy<br>hexo s == hexo server<br>hexo s -g -p 4001 hexo指定端口运行<br>hexo s -g 生成并本地预览<br>hexo d -g 生成并上传</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git，hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
